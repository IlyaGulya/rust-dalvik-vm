// Generated from SmaliParser.g4 by ANTLR 4.8
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(nonstandard_style)]
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_braces)]
use antlr_rust::PredictionContextCache;
use antlr_rust::parser::{Parser, BaseParser, ParserRecog, ParserNodeType};
use antlr_rust::token_stream::TokenStream;
use antlr_rust::TokenSource;
use antlr_rust::parser_atn_simulator::ParserATNSimulator;
use antlr_rust::errors::*;
use antlr_rust::rule_context::{BaseRuleContext, CustomRuleContext, RuleContext};
use antlr_rust::recognizer::{Recognizer,Actions};
use antlr_rust::atn_deserializer::ATNDeserializer;
use antlr_rust::dfa::DFA;
use antlr_rust::atn::{ATN, INVALID_ALT};
use antlr_rust::error_strategy::{ErrorStrategy, DefaultErrorStrategy};
use antlr_rust::parser_rule_context::{BaseParserRuleContext, ParserRuleContext,cast,cast_mut};
use antlr_rust::tree::*;
use antlr_rust::token::{TOKEN_EOF,OwningToken,Token};
use antlr_rust::int_stream::EOF;
use antlr_rust::vocabulary::{Vocabulary,VocabularyImpl};
use antlr_rust::token_factory::{CommonTokenFactory,TokenFactory, TokenAware};
use super::smaliparserlistener::*;
use antlr_rust::lazy_static;
use antlr_rust::{TidAble,TidExt};

use std::marker::PhantomData;
use std::sync::Arc;
use std::rc::Rc;
use std::convert::TryFrom;
use std::cell::RefCell;
use std::ops::{DerefMut, Deref};
use std::borrow::{Borrow,BorrowMut};
use std::any::{Any,TypeId};

		pub const QUALIFIED_TYPE_NAME:isize=1; 
		pub const VOID_TYPE:isize=2; 
		pub const BOOLEAN_TYPE:isize=3; 
		pub const BYTE_TYPE:isize=4; 
		pub const SHORT_TYPE:isize=5; 
		pub const CHAR_TYPE:isize=6; 
		pub const INT_TYPE:isize=7; 
		pub const LONG_TYPE:isize=8; 
		pub const FLOAT_TYPE:isize=9; 
		pub const DOUBLE_TYPE:isize=10; 
		pub const COMPOUND_METHOD_ARG_LITERAL:isize=11; 
		pub const LBRACK:isize=12; 
		pub const RBRACK:isize=13; 
		pub const LPAREN:isize=14; 
		pub const RPAREN:isize=15; 
		pub const LBRACE:isize=16; 
		pub const RBRACE:isize=17; 
		pub const COLON:isize=18; 
		pub const ASSIGN:isize=19; 
		pub const DOT:isize=20; 
		pub const SUB:isize=21; 
		pub const COMMA:isize=22; 
		pub const SLASH:isize=23; 
		pub const LT:isize=24; 
		pub const GT:isize=25; 
		pub const ARROW:isize=26; 
		pub const SEMI:isize=27; 
		pub const METHOD_DIRECTIVE:isize=28; 
		pub const METHOD_END_DIRECTIVE:isize=29; 
		pub const CLASS_DIRECTIVE:isize=30; 
		pub const SOURCE_DIRECTIVE:isize=31; 
		pub const SUPER_DIRECTIVE:isize=32; 
		pub const FIELD_DIRECTIVE:isize=33; 
		pub const REGISTERS_DIRECTIVE:isize=34; 
		pub const LOCALS_DIRECTIVE:isize=35; 
		pub const PARAM_DIRECTIVE:isize=36; 
		pub const LINE_DIRECTIVE:isize=37; 
		pub const CATCH_DIRECTIVE:isize=38; 
		pub const CATCHALL_DIRECTIVE:isize=39; 
		pub const ANNOTATION_DIRECTIVE:isize=40; 
		pub const ANNOTATION_END_DIRECTIVE:isize=41; 
		pub const LOCAL_DIRECTIVE:isize=42; 
		pub const LOCAL_END_DIRECTIVE:isize=43; 
		pub const RESTART_LOCAL_DIRECTIVE:isize=44; 
		pub const PACKED_SWITCH_DIRECTIVE:isize=45; 
		pub const PACKED_SWITCH_END_DIRECTIVE:isize=46; 
		pub const ARRAY_DATA_DIRECTIVE:isize=47; 
		pub const ARRAY_DATA_END_DIRECTIVE:isize=48; 
		pub const SPARSE_SWITCH_DIRECTIVE:isize=49; 
		pub const SPARSE_SWITCH_END_DIRECTIVE:isize=50; 
		pub const PARAM_END_DIRECTIVE:isize=51; 
		pub const PUBLIC:isize=52; 
		pub const PRIVATE:isize=53; 
		pub const PROTECTED:isize=54; 
		pub const FINAL:isize=55; 
		pub const ANNOTATION:isize=56; 
		pub const STATIC:isize=57; 
		pub const SYNTHETIC:isize=58; 
		pub const CONSTRUCTOR:isize=59; 
		pub const ABSTRACT:isize=60; 
		pub const ENUM:isize=61; 
		pub const INTERFACE:isize=62; 
		pub const TRANSIENT:isize=63; 
		pub const BRIDGE:isize=64; 
		pub const DECLARED_SYNCHRONIZED:isize=65; 
		pub const VOLATILE:isize=66; 
		pub const STRICTFP:isize=67; 
		pub const VARARGS:isize=68; 
		pub const NATIVE:isize=69; 
		pub const OP_NOP:isize=70; 
		pub const OP_MOVE:isize=71; 
		pub const OP_MOVE_FROM16:isize=72; 
		pub const OP_MOVE_16:isize=73; 
		pub const OP_MOVE_WIDE:isize=74; 
		pub const OP_MOVE_WIDE_FROM16:isize=75; 
		pub const OP_MOVE_WIDE_16:isize=76; 
		pub const OP_MOVE_OBJECT:isize=77; 
		pub const OP_MOVE_OBJECT_FROM16:isize=78; 
		pub const OP_MOVE_OBJECT_16:isize=79; 
		pub const OP_MOVE_RESULT:isize=80; 
		pub const OP_MOVE_RESULT_WIDE:isize=81; 
		pub const OP_MOVE_RESULT_OBJECT:isize=82; 
		pub const OP_MOVE_EXCEPTION:isize=83; 
		pub const OP_RETURN_VOID:isize=84; 
		pub const OP_RETURN:isize=85; 
		pub const OP_RETURN_WIDE:isize=86; 
		pub const OP_RETURN_OBJECT:isize=87; 
		pub const OP_CONST_4:isize=88; 
		pub const OP_CONST_16:isize=89; 
		pub const OP_CONST:isize=90; 
		pub const OP_CONST_HIGH16:isize=91; 
		pub const OP_CONST_WIDE_16:isize=92; 
		pub const OP_CONST_WIDE_32:isize=93; 
		pub const OP_CONST_WIDE:isize=94; 
		pub const OP_CONST_WIDE_HIGH16:isize=95; 
		pub const OP_CONST_STRING:isize=96; 
		pub const OP_CONST_STRING_JUMBO:isize=97; 
		pub const OP_CONST_CLASS:isize=98; 
		pub const OP_MONITOR_ENTER:isize=99; 
		pub const OP_MONITOR_EXIT:isize=100; 
		pub const OP_CHECK_CAST:isize=101; 
		pub const OP_INSTANCE_OF:isize=102; 
		pub const OP_ARRAY_LENGTH:isize=103; 
		pub const OP_NEW_INSTANCE:isize=104; 
		pub const OP_NEW_ARRAY:isize=105; 
		pub const OP_FILLED_NEW_ARRAY:isize=106; 
		pub const OP_FILLED_NEW_ARRAY_RANGE:isize=107; 
		pub const OP_FILL_ARRAY_DATA:isize=108; 
		pub const OP_THROW:isize=109; 
		pub const OP_GOTO:isize=110; 
		pub const OP_GOTO_16:isize=111; 
		pub const OP_GOTO_32:isize=112; 
		pub const OP_CMPL_FLOAT:isize=113; 
		pub const OP_CMPG_FLOAT:isize=114; 
		pub const OP_CMPL_DOUBLE:isize=115; 
		pub const OP_CMPG_DOUBLE:isize=116; 
		pub const OP_CMP_LONG:isize=117; 
		pub const OP_IF_EQ:isize=118; 
		pub const OP_IF_NE:isize=119; 
		pub const OP_IF_LT:isize=120; 
		pub const OP_IF_GE:isize=121; 
		pub const OP_IF_GT:isize=122; 
		pub const OP_IF_LE:isize=123; 
		pub const OP_IF_EQZ:isize=124; 
		pub const OP_IF_NEZ:isize=125; 
		pub const OP_IF_LTZ:isize=126; 
		pub const OP_IF_GEZ:isize=127; 
		pub const OP_IF_GTZ:isize=128; 
		pub const OP_IF_LEZ:isize=129; 
		pub const OP_AGET:isize=130; 
		pub const OP_AGET_WIDE:isize=131; 
		pub const OP_AGET_OBJECT:isize=132; 
		pub const OP_AGET_BOOLEAN:isize=133; 
		pub const OP_AGET_BYTE:isize=134; 
		pub const OP_AGET_CHAR:isize=135; 
		pub const OP_AGET_SHORT:isize=136; 
		pub const OP_APUT:isize=137; 
		pub const OP_APUT_WIDE:isize=138; 
		pub const OP_APUT_OBJECT:isize=139; 
		pub const OP_APUT_BOOLEAN:isize=140; 
		pub const OP_APUT_BYTE:isize=141; 
		pub const OP_APUT_CHAR:isize=142; 
		pub const OP_APUT_SHORT:isize=143; 
		pub const OP_IGET:isize=144; 
		pub const OP_IGET_WIDE:isize=145; 
		pub const OP_IGET_OBJECT:isize=146; 
		pub const OP_IGET_BOOLEAN:isize=147; 
		pub const OP_IGET_BYTE:isize=148; 
		pub const OP_IGET_CHAR:isize=149; 
		pub const OP_IGET_SHORT:isize=150; 
		pub const OP_IPUT:isize=151; 
		pub const OP_IPUT_WIDE:isize=152; 
		pub const OP_IPUT_OBJECT:isize=153; 
		pub const OP_IPUT_BOOLEAN:isize=154; 
		pub const OP_IPUT_BYTE:isize=155; 
		pub const OP_IPUT_CHAR:isize=156; 
		pub const OP_IPUT_SHORT:isize=157; 
		pub const OP_SGET:isize=158; 
		pub const OP_SGET_WIDE:isize=159; 
		pub const OP_SGET_OBJECT:isize=160; 
		pub const OP_SGET_BOOLEAN:isize=161; 
		pub const OP_SGET_BYTE:isize=162; 
		pub const OP_SGET_CHAR:isize=163; 
		pub const OP_SGET_SHORT:isize=164; 
		pub const OP_SPUT:isize=165; 
		pub const OP_SPUT_WIDE:isize=166; 
		pub const OP_SPUT_OBJECT:isize=167; 
		pub const OP_SPUT_BOOLEAN:isize=168; 
		pub const OP_SPUT_BYTE:isize=169; 
		pub const OP_SPUT_CHAR:isize=170; 
		pub const OP_SPUT_SHORT:isize=171; 
		pub const OP_INVOKE_VIRTUAL:isize=172; 
		pub const OP_INVOKE_SUPER:isize=173; 
		pub const OP_INVOKE_DIRECT:isize=174; 
		pub const OP_INVOKE_STATIC:isize=175; 
		pub const OP_INVOKE_INTERFACE:isize=176; 
		pub const OP_INVOKE_VIRTUAL_RANGE:isize=177; 
		pub const OP_INVOKE_SUPER_RANGE:isize=178; 
		pub const OP_INVOKE_DIRECT_RANGE:isize=179; 
		pub const OP_INVOKE_STATIC_RANGE:isize=180; 
		pub const OP_INVOKE_INTERFACE_RANGE:isize=181; 
		pub const OP_NEG_INT:isize=182; 
		pub const OP_NOT_INT:isize=183; 
		pub const OP_NEG_LONG:isize=184; 
		pub const OP_NOT_LONG:isize=185; 
		pub const OP_NEG_FLOAT:isize=186; 
		pub const OP_NEG_DOUBLE:isize=187; 
		pub const OP_INT_TO_LONG:isize=188; 
		pub const OP_INT_TO_FLOAT:isize=189; 
		pub const OP_INT_TO_DOUBLE:isize=190; 
		pub const OP_LONG_TO_INT:isize=191; 
		pub const OP_LONG_TO_FLOAT:isize=192; 
		pub const OP_LONG_TO_DOUBLE:isize=193; 
		pub const OP_FLOAT_TO_INT:isize=194; 
		pub const OP_FLOAT_TO_LONG:isize=195; 
		pub const OP_FLOAT_TO_DOUBLE:isize=196; 
		pub const OP_DOUBLE_TO_INT:isize=197; 
		pub const OP_DOUBLE_TO_LONG:isize=198; 
		pub const OP_DOUBLE_TO_FLOAT:isize=199; 
		pub const OP_INT_TO_BYTE:isize=200; 
		pub const OP_INT_TO_CHAR:isize=201; 
		pub const OP_INT_TO_SHORT:isize=202; 
		pub const OP_ADD_INT:isize=203; 
		pub const OP_SUB_INT:isize=204; 
		pub const OP_MUL_INT:isize=205; 
		pub const OP_DIV_INT:isize=206; 
		pub const OP_REM_INT:isize=207; 
		pub const OP_AND_INT:isize=208; 
		pub const OP_OR_INT:isize=209; 
		pub const OP_XOR_INT:isize=210; 
		pub const OP_SHL_INT:isize=211; 
		pub const OP_SHR_INT:isize=212; 
		pub const OP_USHR_INT:isize=213; 
		pub const OP_ADD_LONG:isize=214; 
		pub const OP_SUB_LONG:isize=215; 
		pub const OP_MUL_LONG:isize=216; 
		pub const OP_DIV_LONG:isize=217; 
		pub const OP_REM_LONG:isize=218; 
		pub const OP_AND_LONG:isize=219; 
		pub const OP_OR_LONG:isize=220; 
		pub const OP_XOR_LONG:isize=221; 
		pub const OP_SHL_LONG:isize=222; 
		pub const OP_SHR_LONG:isize=223; 
		pub const OP_USHR_LONG:isize=224; 
		pub const OP_ADD_FLOAT:isize=225; 
		pub const OP_SUB_FLOAT:isize=226; 
		pub const OP_MUL_FLOAT:isize=227; 
		pub const OP_DIV_FLOAT:isize=228; 
		pub const OP_REM_FLOAT:isize=229; 
		pub const OP_ADD_DOUBLE:isize=230; 
		pub const OP_SUB_DOUBLE:isize=231; 
		pub const OP_MUL_DOUBLE:isize=232; 
		pub const OP_DIV_DOUBLE:isize=233; 
		pub const OP_REM_DOUBLE:isize=234; 
		pub const OP_ADD_INT_2ADDR:isize=235; 
		pub const OP_SUB_INT_2ADDR:isize=236; 
		pub const OP_MUL_INT_2ADDR:isize=237; 
		pub const OP_DIV_INT_2ADDR:isize=238; 
		pub const OP_REM_INT_2ADDR:isize=239; 
		pub const OP_AND_INT_2ADDR:isize=240; 
		pub const OP_OR_INT_2ADDR:isize=241; 
		pub const OP_XOR_INT_2ADDR:isize=242; 
		pub const OP_SHL_INT_2ADDR:isize=243; 
		pub const OP_SHR_INT_2ADDR:isize=244; 
		pub const OP_USHR_INT_2ADDR:isize=245; 
		pub const OP_ADD_LONG_2ADDR:isize=246; 
		pub const OP_SUB_LONG_2ADDR:isize=247; 
		pub const OP_MUL_LONG_2ADDR:isize=248; 
		pub const OP_DIV_LONG_2ADDR:isize=249; 
		pub const OP_REM_LONG_2ADDR:isize=250; 
		pub const OP_AND_LONG_2ADDR:isize=251; 
		pub const OP_OR_LONG_2ADDR:isize=252; 
		pub const OP_XOR_LONG_2ADDR:isize=253; 
		pub const OP_SHL_LONG_2ADDR:isize=254; 
		pub const OP_SHR_LONG_2ADDR:isize=255; 
		pub const OP_USHR_LONG_2ADDR:isize=256; 
		pub const OP_ADD_FLOAT_2ADDR:isize=257; 
		pub const OP_SUB_FLOAT_2ADDR:isize=258; 
		pub const OP_MUL_FLOAT_2ADDR:isize=259; 
		pub const OP_DIV_FLOAT_2ADDR:isize=260; 
		pub const OP_REM_FLOAT_2ADDR:isize=261; 
		pub const OP_ADD_DOUBLE_2ADDR:isize=262; 
		pub const OP_SUB_DOUBLE_2ADDR:isize=263; 
		pub const OP_MUL_DOUBLE_2ADDR:isize=264; 
		pub const OP_DIV_DOUBLE_2ADDR:isize=265; 
		pub const OP_REM_DOUBLE_2ADDR:isize=266; 
		pub const OP_ADD_INT_LIT16:isize=267; 
		pub const OP_RSUB_INT:isize=268; 
		pub const OP_MUL_INT_LIT16:isize=269; 
		pub const OP_DIV_INT_LIT16:isize=270; 
		pub const OP_REM_INT_LIT16:isize=271; 
		pub const OP_AND_INT_LIT16:isize=272; 
		pub const OP_OR_INT_LIT16:isize=273; 
		pub const OP_XOR_INT_LIT16:isize=274; 
		pub const OP_ADD_INT_LIT8:isize=275; 
		pub const OP_RSUB_INT_LIT8:isize=276; 
		pub const OP_MUL_INT_LIT8:isize=277; 
		pub const OP_DIV_INT_LIT8:isize=278; 
		pub const OP_REM_INT_LIT8:isize=279; 
		pub const OP_AND_INT_LIT8:isize=280; 
		pub const OP_OR_INT_LIT8:isize=281; 
		pub const OP_XOR_INT_LIT8:isize=282; 
		pub const OP_SHL_INT_LIT8:isize=283; 
		pub const OP_SHR_INT_LIT8:isize=284; 
		pub const OP_USHR_INT_LIT8:isize=285; 
		pub const OP_INVOKE_POLYMORPHIC:isize=286; 
		pub const OP_INVOKE_POLYMORPHIC_RANGE:isize=287; 
		pub const OP_INVOKE_CUSTOM:isize=288; 
		pub const OP_INVOKE_CUSTOM_RANGE:isize=289; 
		pub const OP_CONST_METHOD_HANDLE:isize=290; 
		pub const OP_CONST_METHOD_TYPE:isize=291; 
		pub const OP_PACKED_SWITCH:isize=292; 
		pub const OP_SPARSE_SWITCH:isize=293; 
		pub const DECIMAL_LITERAL:isize=294; 
		pub const HEX_LITERAL:isize=295; 
		pub const OCT_LITERAL:isize=296; 
		pub const BINARY_LITERAL:isize=297; 
		pub const FLOAT_LITERAL:isize=298; 
		pub const HEX_FLOAT_LITERAL:isize=299; 
		pub const BOOL_LITERAL:isize=300; 
		pub const NULL_LITERAL:isize=301; 
		pub const CHAR_LITERAL:isize=302; 
		pub const STRING_LITERAL:isize=303; 
		pub const IDENTIFIER:isize=304; 
		pub const WS:isize=305; 
		pub const LINE_COMMENT:isize=306;
	pub const RULE_registerIdentifier:usize = 0; 
	pub const RULE_stringLiteral:usize = 1; 
	pub const RULE_negativeNumericLiteral:usize = 2; 
	pub const RULE_decimalNumericLiteral:usize = 3; 
	pub const RULE_hexNumericLiteral:usize = 4; 
	pub const RULE_octNumericLiteral:usize = 5; 
	pub const RULE_binaryNumericLiteral:usize = 6; 
	pub const RULE_floatNumericLiteral:usize = 7; 
	pub const RULE_hexFloatLiteral:usize = 8; 
	pub const RULE_positiveNumericLiteral:usize = 9; 
	pub const RULE_numericLiteral:usize = 10; 
	pub const RULE_identifier:usize = 11; 
	pub const RULE_referenceType:usize = 12; 
	pub const RULE_voidType:usize = 13; 
	pub const RULE_booleanType:usize = 14; 
	pub const RULE_byteType:usize = 15; 
	pub const RULE_shortType:usize = 16; 
	pub const RULE_charType:usize = 17; 
	pub const RULE_intType:usize = 18; 
	pub const RULE_longType:usize = 19; 
	pub const RULE_floatType:usize = 20; 
	pub const RULE_doubleType:usize = 21; 
	pub const RULE_primitiveType:usize = 22; 
	pub const RULE_nonArrayType:usize = 23; 
	pub const RULE_methodParameterLiteral:usize = 24; 
	pub const RULE_arrayType:usize = 25; 
	pub const RULE_referenceOrArrayType:usize = 26; 
	pub const RULE_nonVoidType:usize = 27; 
	pub const RULE_anyType:usize = 28; 
	pub const RULE_nullLiteral:usize = 29; 
	pub const RULE_booleanLiteral:usize = 30; 
	pub const RULE_assignableValue:usize = 31; 
	pub const RULE_classModifier:usize = 32; 
	pub const RULE_methodModifier:usize = 33; 
	pub const RULE_fieldModifier:usize = 34; 
	pub const RULE_labelName:usize = 35; 
	pub const RULE_label:usize = 36; 
	pub const RULE_leftRegister:usize = 37; 
	pub const RULE_rightRegister:usize = 38; 
	pub const RULE_registerListRegisters:usize = 39; 
	pub const RULE_registerRange:usize = 40; 
	pub const RULE_registerList:usize = 41; 
	pub const RULE_gotoInstruction:usize = 42; 
	pub const RULE_goto16Instruction:usize = 43; 
	pub const RULE_goto32Instruction:usize = 44; 
	pub const RULE_moveResultInstruction:usize = 45; 
	pub const RULE_moveResultWideInstruction:usize = 46; 
	pub const RULE_moveResultObjectInstruction:usize = 47; 
	pub const RULE_moveExceptionInstruction:usize = 48; 
	pub const RULE_returnInstruction:usize = 49; 
	pub const RULE_returnWideInstruction:usize = 50; 
	pub const RULE_returnObjectInstruction:usize = 51; 
	pub const RULE_monitorEnterInstruction:usize = 52; 
	pub const RULE_monitorExitInstruction:usize = 53; 
	pub const RULE_throwInstruction:usize = 54; 
	pub const RULE_returnVoidInstruction:usize = 55; 
	pub const RULE_nopInstruction:usize = 56; 
	pub const RULE_moveInstruction:usize = 57; 
	pub const RULE_moveFrom16Instruction:usize = 58; 
	pub const RULE_move16Instruction:usize = 59; 
	pub const RULE_moveWideInstruction:usize = 60; 
	pub const RULE_moveWideFrom16Instruction:usize = 61; 
	pub const RULE_moveWide16Instruction:usize = 62; 
	pub const RULE_moveObjectInstruction:usize = 63; 
	pub const RULE_moveObjectFrom16Instruction:usize = 64; 
	pub const RULE_moveObject16Instruction:usize = 65; 
	pub const RULE_constInstruction:usize = 66; 
	pub const RULE_const4Instruction:usize = 67; 
	pub const RULE_const16Instruction:usize = 68; 
	pub const RULE_constHigh16Instruction:usize = 69; 
	pub const RULE_constWide16Instruction:usize = 70; 
	pub const RULE_constWide32Instruction:usize = 71; 
	pub const RULE_constWideInstruction:usize = 72; 
	pub const RULE_constWideHigh16Instruction:usize = 73; 
	pub const RULE_constString:usize = 74; 
	pub const RULE_constStringJumbo:usize = 75; 
	pub const RULE_constClass:usize = 76; 
	pub const RULE_sGetInstruction:usize = 77; 
	pub const RULE_sGetWideInstruction:usize = 78; 
	pub const RULE_sGetObjectInstruction:usize = 79; 
	pub const RULE_sGetBooleanInstruction:usize = 80; 
	pub const RULE_sGetByteInstruction:usize = 81; 
	pub const RULE_sGetCharInstruction:usize = 82; 
	pub const RULE_sGetShortInstruction:usize = 83; 
	pub const RULE_sPutInstruction:usize = 84; 
	pub const RULE_sPutWideInstruction:usize = 85; 
	pub const RULE_sPutObjectInstruction:usize = 86; 
	pub const RULE_sPutBooleanInstruction:usize = 87; 
	pub const RULE_sPutByteInstruction:usize = 88; 
	pub const RULE_sPutCharInstruction:usize = 89; 
	pub const RULE_sPutShortInstruction:usize = 90; 
	pub const RULE_invokeVirtualInstruction:usize = 91; 
	pub const RULE_invokeSuperInstruction:usize = 92; 
	pub const RULE_invokeDirectInstruction:usize = 93; 
	pub const RULE_invokeStaticInstruction:usize = 94; 
	pub const RULE_invokeInterfaceInstruction:usize = 95; 
	pub const RULE_invokeVirtualRangeInstruction:usize = 96; 
	pub const RULE_invokeSuperRangeInstruction:usize = 97; 
	pub const RULE_invokeDirectRangeInstruction:usize = 98; 
	pub const RULE_invokeStaticRangeInstruction:usize = 99; 
	pub const RULE_invokeInterfaceRangeInstruction:usize = 100; 
	pub const RULE_intToLongInstruction:usize = 101; 
	pub const RULE_intToFloatInstruction:usize = 102; 
	pub const RULE_intToDoubleInstruction:usize = 103; 
	pub const RULE_longToIntInstruction:usize = 104; 
	pub const RULE_longToFloatInstruction:usize = 105; 
	pub const RULE_longToDoubleInstruction:usize = 106; 
	pub const RULE_floatToIntInstruction:usize = 107; 
	pub const RULE_floatToLongInstruction:usize = 108; 
	pub const RULE_floatToDoubleInstruction:usize = 109; 
	pub const RULE_doubleToIntInstruction:usize = 110; 
	pub const RULE_doubleToLongInstruction:usize = 111; 
	pub const RULE_doubleToFloatInstruction:usize = 112; 
	pub const RULE_intToByteInstruction:usize = 113; 
	pub const RULE_intToCharInstruction:usize = 114; 
	pub const RULE_intToShortInstruction:usize = 115; 
	pub const RULE_ifLabel:usize = 116; 
	pub const RULE_ifEqzInstruction:usize = 117; 
	pub const RULE_ifNezInstruction:usize = 118; 
	pub const RULE_ifLtzInstruction:usize = 119; 
	pub const RULE_ifGezInstruction:usize = 120; 
	pub const RULE_ifGtzInstruction:usize = 121; 
	pub const RULE_ifLezInstruction:usize = 122; 
	pub const RULE_negIntInstruction:usize = 123; 
	pub const RULE_notIntInstruction:usize = 124; 
	pub const RULE_negLongInstruction:usize = 125; 
	pub const RULE_notLongInstruction:usize = 126; 
	pub const RULE_negFloatInstruction:usize = 127; 
	pub const RULE_negDoubleInstruction:usize = 128; 
	pub const RULE_ifEqInstruction:usize = 129; 
	pub const RULE_ifNeInstruction:usize = 130; 
	pub const RULE_ifLtInstruction:usize = 131; 
	pub const RULE_ifGeInstruction:usize = 132; 
	pub const RULE_ifGtInstruction:usize = 133; 
	pub const RULE_ifLeInstruction:usize = 134; 
	pub const RULE_addInt2addrInstruction:usize = 135; 
	pub const RULE_subInt2addrInstruction:usize = 136; 
	pub const RULE_mulInt2addrInstruction:usize = 137; 
	pub const RULE_divInt2addrInstruction:usize = 138; 
	pub const RULE_remInt2addrInstruction:usize = 139; 
	pub const RULE_andInt2addrInstruction:usize = 140; 
	pub const RULE_orInt2addrInstruction:usize = 141; 
	pub const RULE_xorInt2addrInstruction:usize = 142; 
	pub const RULE_shlInt2addrInstruction:usize = 143; 
	pub const RULE_shrInt2addrInstruction:usize = 144; 
	pub const RULE_ushrInt2addrInstruction:usize = 145; 
	pub const RULE_addLong2addrInstruction:usize = 146; 
	pub const RULE_subLong2addrInstruction:usize = 147; 
	pub const RULE_mulLong2addrInstruction:usize = 148; 
	pub const RULE_divLong2addrInstruction:usize = 149; 
	pub const RULE_remLong2addrInstruction:usize = 150; 
	pub const RULE_andLong2addrInstruction:usize = 151; 
	pub const RULE_orLong2addrInstruction:usize = 152; 
	pub const RULE_xorLong2addrInstruction:usize = 153; 
	pub const RULE_shlLong2addrInstruction:usize = 154; 
	pub const RULE_shrLong2addrInstruction:usize = 155; 
	pub const RULE_ushrLong2addrInstruction:usize = 156; 
	pub const RULE_addFloat2addrInstruction:usize = 157; 
	pub const RULE_subFloat2addrInstruction:usize = 158; 
	pub const RULE_mulFloat2addrInstruction:usize = 159; 
	pub const RULE_divFloat2addrInstruction:usize = 160; 
	pub const RULE_remFloat2addrInstruction:usize = 161; 
	pub const RULE_addDouble2addrInstruction:usize = 162; 
	pub const RULE_subDouble2addrInstruction:usize = 163; 
	pub const RULE_mulDouble2addrInstruction:usize = 164; 
	pub const RULE_divDouble2addrInstruction:usize = 165; 
	pub const RULE_remDouble2addrInstruction:usize = 166; 
	pub const RULE_cmplFloatInstruction:usize = 167; 
	pub const RULE_cmpgFloatInstruction:usize = 168; 
	pub const RULE_cmplDoubleInstruction:usize = 169; 
	pub const RULE_cmpgDoubleInstruction:usize = 170; 
	pub const RULE_cmpLongInstruction:usize = 171; 
	pub const RULE_field:usize = 172; 
	pub const RULE_arrayRegister:usize = 173; 
	pub const RULE_indexRegister:usize = 174; 
	pub const RULE_instanceRegister:usize = 175; 
	pub const RULE_sourceRegister:usize = 176; 
	pub const RULE_targetRegister:usize = 177; 
	pub const RULE_instanceField:usize = 178; 
	pub const RULE_agetInstruction:usize = 179; 
	pub const RULE_agetWideInstruction:usize = 180; 
	pub const RULE_agetObjectInstruction:usize = 181; 
	pub const RULE_agetBooleanInstruction:usize = 182; 
	pub const RULE_agetByteInstruction:usize = 183; 
	pub const RULE_agetCharInstruction:usize = 184; 
	pub const RULE_agetShortInstruction:usize = 185; 
	pub const RULE_aputInstruction:usize = 186; 
	pub const RULE_aputWideInstruction:usize = 187; 
	pub const RULE_aputObjectInstruction:usize = 188; 
	pub const RULE_aputBooleanInstruction:usize = 189; 
	pub const RULE_aputByteInstruction:usize = 190; 
	pub const RULE_aputCharInstruction:usize = 191; 
	pub const RULE_aputShortInstruction:usize = 192; 
	pub const RULE_igetInstruction:usize = 193; 
	pub const RULE_igetWideInstruction:usize = 194; 
	pub const RULE_igetObjectInstruction:usize = 195; 
	pub const RULE_igetBooleanInstruction:usize = 196; 
	pub const RULE_igetByteInstruction:usize = 197; 
	pub const RULE_igetCharInstruction:usize = 198; 
	pub const RULE_igetShortInstruction:usize = 199; 
	pub const RULE_iputInstruction:usize = 200; 
	pub const RULE_iputWideInstruction:usize = 201; 
	pub const RULE_iputObjectInstruction:usize = 202; 
	pub const RULE_iputBooleanInstruction:usize = 203; 
	pub const RULE_iputByteInstruction:usize = 204; 
	pub const RULE_iputCharInstruction:usize = 205; 
	pub const RULE_iputShortInstruction:usize = 206; 
	pub const RULE_addIntInstruction:usize = 207; 
	pub const RULE_subIntInstruction:usize = 208; 
	pub const RULE_mulIntInstruction:usize = 209; 
	pub const RULE_divIntInstruction:usize = 210; 
	pub const RULE_remIntInstruction:usize = 211; 
	pub const RULE_andIntInstruction:usize = 212; 
	pub const RULE_orIntInstruction:usize = 213; 
	pub const RULE_xorIntInstruction:usize = 214; 
	pub const RULE_shlIntInstruction:usize = 215; 
	pub const RULE_shrIntInstruction:usize = 216; 
	pub const RULE_ushrIntInstruction:usize = 217; 
	pub const RULE_rsubIntInstruction:usize = 218; 
	pub const RULE_addLongInstruction:usize = 219; 
	pub const RULE_subLongInstruction:usize = 220; 
	pub const RULE_mulLongInstruction:usize = 221; 
	pub const RULE_divLongInstruction:usize = 222; 
	pub const RULE_remLongInstruction:usize = 223; 
	pub const RULE_andLongInstruction:usize = 224; 
	pub const RULE_orLongInstruction:usize = 225; 
	pub const RULE_xorLongInstruction:usize = 226; 
	pub const RULE_shlLongInstruction:usize = 227; 
	pub const RULE_shrLongInstruction:usize = 228; 
	pub const RULE_ushrLongInstruction:usize = 229; 
	pub const RULE_addFloatInstruction:usize = 230; 
	pub const RULE_subFloatInstruction:usize = 231; 
	pub const RULE_mulFloatInstruction:usize = 232; 
	pub const RULE_divFloatInstruction:usize = 233; 
	pub const RULE_remFloatInstruction:usize = 234; 
	pub const RULE_addDoubleInstruction:usize = 235; 
	pub const RULE_subDoubleInstruction:usize = 236; 
	pub const RULE_mulDoubleInstruction:usize = 237; 
	pub const RULE_divDoubleInstruction:usize = 238; 
	pub const RULE_remDoubleInstruction:usize = 239; 
	pub const RULE_addIntLit16Instruction:usize = 240; 
	pub const RULE_mulIntLit16Instruction:usize = 241; 
	pub const RULE_divIntLit16Instruction:usize = 242; 
	pub const RULE_remIntLit16Instruction:usize = 243; 
	pub const RULE_andIntLit16Instruction:usize = 244; 
	pub const RULE_orIntLit16Instruction:usize = 245; 
	pub const RULE_xorIntLit16Instruction:usize = 246; 
	pub const RULE_addIntLit8Instruction:usize = 247; 
	pub const RULE_rsubIntLit8Instruction:usize = 248; 
	pub const RULE_mulIntLit8Instruction:usize = 249; 
	pub const RULE_divIntLit8Instruction:usize = 250; 
	pub const RULE_remIntLit8Instruction:usize = 251; 
	pub const RULE_andIntLit8Instruction:usize = 252; 
	pub const RULE_orIntLit8Instruction:usize = 253; 
	pub const RULE_xorIntLit8Instruction:usize = 254; 
	pub const RULE_shlIntLit8Instruction:usize = 255; 
	pub const RULE_shrIntLit8Instruction:usize = 256; 
	pub const RULE_ushrIntLit8Instruction:usize = 257; 
	pub const RULE_newInstanceType:usize = 258; 
	pub const RULE_newInstanceInstruction:usize = 259; 
	pub const RULE_checkCastType:usize = 260; 
	pub const RULE_checkCastInstruction:usize = 261; 
	pub const RULE_arrayLengthInstruction:usize = 262; 
	pub const RULE_arrayElementType:usize = 263; 
	pub const RULE_arrayElementRegisterRange:usize = 264; 
	pub const RULE_arrayElementRegisters:usize = 265; 
	pub const RULE_filledNewArrayRangeInstruction:usize = 266; 
	pub const RULE_filledNewArrayInstruction:usize = 267; 
	pub const RULE_filledArrayDataLabel:usize = 268; 
	pub const RULE_fillArrayDataInstruction:usize = 269; 
	pub const RULE_checkInstanceType:usize = 270; 
	pub const RULE_instanceOfInstruction:usize = 271; 
	pub const RULE_arraySizeRegister:usize = 272; 
	pub const RULE_newArrayInstruction:usize = 273; 
	pub const RULE_packedSwitchRegister:usize = 274; 
	pub const RULE_packedSwitchLabel:usize = 275; 
	pub const RULE_sparseSwitchRegister:usize = 276; 
	pub const RULE_sparseSwitchLabel:usize = 277; 
	pub const RULE_packedSwitchInstruction:usize = 278; 
	pub const RULE_sparseSwitchInstruction:usize = 279; 
	pub const RULE_invokePolymorphicInstruction:usize = 280; 
	pub const RULE_invokePolymorphicRangeInstruction:usize = 281; 
	pub const RULE_invokeCustomInstruction:usize = 282; 
	pub const RULE_invokeCustomRangeInstruction:usize = 283; 
	pub const RULE_invokeConstMethodHandleInstruction:usize = 284; 
	pub const RULE_invokeConstMethodTypeInstruction:usize = 285; 
	pub const RULE_binaryInstruction:usize = 286; 
	pub const RULE_ternaryInstruction:usize = 287; 
	pub const RULE_instruction:usize = 288; 
	pub const RULE_methodInvocationTarget:usize = 289; 
	pub const RULE_fieldInvocationTarget:usize = 290; 
	pub const RULE_fieldName:usize = 291; 
	pub const RULE_fieldType:usize = 292; 
	pub const RULE_fieldNameAndType:usize = 293; 
	pub const RULE_fieldDirective:usize = 294; 
	pub const RULE_className:usize = 295; 
	pub const RULE_classDirective:usize = 296; 
	pub const RULE_superName:usize = 297; 
	pub const RULE_superDirective:usize = 298; 
	pub const RULE_sourceName:usize = 299; 
	pub const RULE_sourceDirective:usize = 300; 
	pub const RULE_methodIdentifier:usize = 301; 
	pub const RULE_methodReturnType:usize = 302; 
	pub const RULE_methodParameterType:usize = 303; 
	pub const RULE_methodArguments:usize = 304; 
	pub const RULE_methodSignature:usize = 305; 
	pub const RULE_methodDeclaration:usize = 306; 
	pub const RULE_annotationScope:usize = 307; 
	pub const RULE_annotationType:usize = 308; 
	pub const RULE_annotationFieldValue:usize = 309; 
	pub const RULE_annotationValueScoped:usize = 310; 
	pub const RULE_annotationField:usize = 311; 
	pub const RULE_annotationDirective:usize = 312; 
	pub const RULE_locaDirectiveVariableName:usize = 313; 
	pub const RULE_localDirectiveType:usize = 314; 
	pub const RULE_localDirectiveGenericHint:usize = 315; 
	pub const RULE_localDirectiveRegister:usize = 316; 
	pub const RULE_localDirective:usize = 317; 
	pub const RULE_localEndDirective:usize = 318; 
	pub const RULE_localRestartDirective:usize = 319; 
	pub const RULE_lineLabel:usize = 320; 
	pub const RULE_methodBodyStatement:usize = 321; 
	pub const RULE_methodBody:usize = 322; 
	pub const RULE_packedSwitchIdent:usize = 323; 
	pub const RULE_packedSwitchDirectiveLabel:usize = 324; 
	pub const RULE_packedSwitchDirectiveLabels:usize = 325; 
	pub const RULE_packedSwitchDirective:usize = 326; 
	pub const RULE_methodDirective:usize = 327; 
	pub const RULE_registersDirective:usize = 328; 
	pub const RULE_localsDirective:usize = 329; 
	pub const RULE_simpleParamDirective:usize = 330; 
	pub const RULE_extendedParamDirective:usize = 331; 
	pub const RULE_paramDirective:usize = 332; 
	pub const RULE_lineDirective:usize = 333; 
	pub const RULE_catchFromLabel:usize = 334; 
	pub const RULE_catchToLabel:usize = 335; 
	pub const RULE_catchGotoLabel:usize = 336; 
	pub const RULE_catchExceptionType:usize = 337; 
	pub const RULE_catchDirective:usize = 338; 
	pub const RULE_catchAllDirective:usize = 339; 
	pub const RULE_arrayDataDirective:usize = 340; 
	pub const RULE_arrayDataEntry:usize = 341; 
	pub const RULE_sparseSwitchDirectiveValue:usize = 342; 
	pub const RULE_sparseSwitchDirective:usize = 343; 
	pub const RULE_statement:usize = 344; 
	pub const RULE_parse:usize = 345;
	pub const ruleNames: [&'static str; 346] =  [
		"registerIdentifier", "stringLiteral", "negativeNumericLiteral", "decimalNumericLiteral", 
		"hexNumericLiteral", "octNumericLiteral", "binaryNumericLiteral", "floatNumericLiteral", 
		"hexFloatLiteral", "positiveNumericLiteral", "numericLiteral", "identifier", 
		"referenceType", "voidType", "booleanType", "byteType", "shortType", "charType", 
		"intType", "longType", "floatType", "doubleType", "primitiveType", "nonArrayType", 
		"methodParameterLiteral", "arrayType", "referenceOrArrayType", "nonVoidType", 
		"anyType", "nullLiteral", "booleanLiteral", "assignableValue", "classModifier", 
		"methodModifier", "fieldModifier", "labelName", "label", "leftRegister", 
		"rightRegister", "registerListRegisters", "registerRange", "registerList", 
		"gotoInstruction", "goto16Instruction", "goto32Instruction", "moveResultInstruction", 
		"moveResultWideInstruction", "moveResultObjectInstruction", "moveExceptionInstruction", 
		"returnInstruction", "returnWideInstruction", "returnObjectInstruction", 
		"monitorEnterInstruction", "monitorExitInstruction", "throwInstruction", 
		"returnVoidInstruction", "nopInstruction", "moveInstruction", "moveFrom16Instruction", 
		"move16Instruction", "moveWideInstruction", "moveWideFrom16Instruction", 
		"moveWide16Instruction", "moveObjectInstruction", "moveObjectFrom16Instruction", 
		"moveObject16Instruction", "constInstruction", "const4Instruction", "const16Instruction", 
		"constHigh16Instruction", "constWide16Instruction", "constWide32Instruction", 
		"constWideInstruction", "constWideHigh16Instruction", "constString", "constStringJumbo", 
		"constClass", "sGetInstruction", "sGetWideInstruction", "sGetObjectInstruction", 
		"sGetBooleanInstruction", "sGetByteInstruction", "sGetCharInstruction", 
		"sGetShortInstruction", "sPutInstruction", "sPutWideInstruction", "sPutObjectInstruction", 
		"sPutBooleanInstruction", "sPutByteInstruction", "sPutCharInstruction", 
		"sPutShortInstruction", "invokeVirtualInstruction", "invokeSuperInstruction", 
		"invokeDirectInstruction", "invokeStaticInstruction", "invokeInterfaceInstruction", 
		"invokeVirtualRangeInstruction", "invokeSuperRangeInstruction", "invokeDirectRangeInstruction", 
		"invokeStaticRangeInstruction", "invokeInterfaceRangeInstruction", "intToLongInstruction", 
		"intToFloatInstruction", "intToDoubleInstruction", "longToIntInstruction", 
		"longToFloatInstruction", "longToDoubleInstruction", "floatToIntInstruction", 
		"floatToLongInstruction", "floatToDoubleInstruction", "doubleToIntInstruction", 
		"doubleToLongInstruction", "doubleToFloatInstruction", "intToByteInstruction", 
		"intToCharInstruction", "intToShortInstruction", "ifLabel", "ifEqzInstruction", 
		"ifNezInstruction", "ifLtzInstruction", "ifGezInstruction", "ifGtzInstruction", 
		"ifLezInstruction", "negIntInstruction", "notIntInstruction", "negLongInstruction", 
		"notLongInstruction", "negFloatInstruction", "negDoubleInstruction", "ifEqInstruction", 
		"ifNeInstruction", "ifLtInstruction", "ifGeInstruction", "ifGtInstruction", 
		"ifLeInstruction", "addInt2addrInstruction", "subInt2addrInstruction", 
		"mulInt2addrInstruction", "divInt2addrInstruction", "remInt2addrInstruction", 
		"andInt2addrInstruction", "orInt2addrInstruction", "xorInt2addrInstruction", 
		"shlInt2addrInstruction", "shrInt2addrInstruction", "ushrInt2addrInstruction", 
		"addLong2addrInstruction", "subLong2addrInstruction", "mulLong2addrInstruction", 
		"divLong2addrInstruction", "remLong2addrInstruction", "andLong2addrInstruction", 
		"orLong2addrInstruction", "xorLong2addrInstruction", "shlLong2addrInstruction", 
		"shrLong2addrInstruction", "ushrLong2addrInstruction", "addFloat2addrInstruction", 
		"subFloat2addrInstruction", "mulFloat2addrInstruction", "divFloat2addrInstruction", 
		"remFloat2addrInstruction", "addDouble2addrInstruction", "subDouble2addrInstruction", 
		"mulDouble2addrInstruction", "divDouble2addrInstruction", "remDouble2addrInstruction", 
		"cmplFloatInstruction", "cmpgFloatInstruction", "cmplDoubleInstruction", 
		"cmpgDoubleInstruction", "cmpLongInstruction", "field", "arrayRegister", 
		"indexRegister", "instanceRegister", "sourceRegister", "targetRegister", 
		"instanceField", "agetInstruction", "agetWideInstruction", "agetObjectInstruction", 
		"agetBooleanInstruction", "agetByteInstruction", "agetCharInstruction", 
		"agetShortInstruction", "aputInstruction", "aputWideInstruction", "aputObjectInstruction", 
		"aputBooleanInstruction", "aputByteInstruction", "aputCharInstruction", 
		"aputShortInstruction", "igetInstruction", "igetWideInstruction", "igetObjectInstruction", 
		"igetBooleanInstruction", "igetByteInstruction", "igetCharInstruction", 
		"igetShortInstruction", "iputInstruction", "iputWideInstruction", "iputObjectInstruction", 
		"iputBooleanInstruction", "iputByteInstruction", "iputCharInstruction", 
		"iputShortInstruction", "addIntInstruction", "subIntInstruction", "mulIntInstruction", 
		"divIntInstruction", "remIntInstruction", "andIntInstruction", "orIntInstruction", 
		"xorIntInstruction", "shlIntInstruction", "shrIntInstruction", "ushrIntInstruction", 
		"rsubIntInstruction", "addLongInstruction", "subLongInstruction", "mulLongInstruction", 
		"divLongInstruction", "remLongInstruction", "andLongInstruction", "orLongInstruction", 
		"xorLongInstruction", "shlLongInstruction", "shrLongInstruction", "ushrLongInstruction", 
		"addFloatInstruction", "subFloatInstruction", "mulFloatInstruction", "divFloatInstruction", 
		"remFloatInstruction", "addDoubleInstruction", "subDoubleInstruction", 
		"mulDoubleInstruction", "divDoubleInstruction", "remDoubleInstruction", 
		"addIntLit16Instruction", "mulIntLit16Instruction", "divIntLit16Instruction", 
		"remIntLit16Instruction", "andIntLit16Instruction", "orIntLit16Instruction", 
		"xorIntLit16Instruction", "addIntLit8Instruction", "rsubIntLit8Instruction", 
		"mulIntLit8Instruction", "divIntLit8Instruction", "remIntLit8Instruction", 
		"andIntLit8Instruction", "orIntLit8Instruction", "xorIntLit8Instruction", 
		"shlIntLit8Instruction", "shrIntLit8Instruction", "ushrIntLit8Instruction", 
		"newInstanceType", "newInstanceInstruction", "checkCastType", "checkCastInstruction", 
		"arrayLengthInstruction", "arrayElementType", "arrayElementRegisterRange", 
		"arrayElementRegisters", "filledNewArrayRangeInstruction", "filledNewArrayInstruction", 
		"filledArrayDataLabel", "fillArrayDataInstruction", "checkInstanceType", 
		"instanceOfInstruction", "arraySizeRegister", "newArrayInstruction", "packedSwitchRegister", 
		"packedSwitchLabel", "sparseSwitchRegister", "sparseSwitchLabel", "packedSwitchInstruction", 
		"sparseSwitchInstruction", "invokePolymorphicInstruction", "invokePolymorphicRangeInstruction", 
		"invokeCustomInstruction", "invokeCustomRangeInstruction", "invokeConstMethodHandleInstruction", 
		"invokeConstMethodTypeInstruction", "binaryInstruction", "ternaryInstruction", 
		"instruction", "methodInvocationTarget", "fieldInvocationTarget", "fieldName", 
		"fieldType", "fieldNameAndType", "fieldDirective", "className", "classDirective", 
		"superName", "superDirective", "sourceName", "sourceDirective", "methodIdentifier", 
		"methodReturnType", "methodParameterType", "methodArguments", "methodSignature", 
		"methodDeclaration", "annotationScope", "annotationType", "annotationFieldValue", 
		"annotationValueScoped", "annotationField", "annotationDirective", "locaDirectiveVariableName", 
		"localDirectiveType", "localDirectiveGenericHint", "localDirectiveRegister", 
		"localDirective", "localEndDirective", "localRestartDirective", "lineLabel", 
		"methodBodyStatement", "methodBody", "packedSwitchIdent", "packedSwitchDirectiveLabel", 
		"packedSwitchDirectiveLabels", "packedSwitchDirective", "methodDirective", 
		"registersDirective", "localsDirective", "simpleParamDirective", "extendedParamDirective", 
		"paramDirective", "lineDirective", "catchFromLabel", "catchToLabel", "catchGotoLabel", 
		"catchExceptionType", "catchDirective", "catchAllDirective", "arrayDataDirective", 
		"arrayDataEntry", "sparseSwitchDirectiveValue", "sparseSwitchDirective", 
		"statement", "parse"
	];


	pub const _LITERAL_NAMES: [Option<&'static str>;302] = [
		None, None, Some("'V'"), Some("'Z'"), Some("'B'"), Some("'S'"), Some("'C'"), 
		Some("'I'"), Some("'J'"), Some("'F'"), Some("'D'"), None, Some("'['"), 
		Some("']'"), Some("'('"), Some("')'"), Some("'{'"), Some("'}'"), Some("':'"), 
		Some("'='"), Some("'.'"), Some("'-'"), Some("','"), Some("'/'"), Some("'<'"), 
		Some("'>'"), Some("'->'"), Some("';'"), Some("'.method'"), Some("'.end method'"), 
		Some("'.class'"), Some("'.source'"), Some("'.super'"), Some("'.field'"), 
		Some("'.registers'"), Some("'.locals'"), Some("'.param'"), Some("'.line'"), 
		Some("'.catch'"), Some("'.catchall'"), Some("'.annotation'"), Some("'.end annotation'"), 
		Some("'.local'"), Some("'.end local'"), Some("'.restart local'"), Some("'.packed-switch'"), 
		Some("'.end packed-switch'"), Some("'.array-data'"), Some("'.end array-data'"), 
		Some("'.sparse-switch'"), Some("'.end sparse-switch'"), Some("'.end param'"), 
		Some("'public'"), Some("'private'"), Some("'protected'"), Some("'final'"), 
		Some("'annotation'"), Some("'static'"), Some("'synthetic'"), Some("'constructor'"), 
		Some("'abstract'"), Some("'enum'"), Some("'interface'"), Some("'transient'"), 
		Some("'bridge'"), Some("'declared-synchronized'"), Some("'volatile'"), 
		Some("'strictfp'"), Some("'varargs'"), Some("'native'"), Some("'nop'"), 
		Some("'move'"), Some("'move/from16'"), Some("'move/16'"), Some("'move-wide'"), 
		Some("'move-wide/from16'"), Some("'move-wide/16'"), Some("'move-object'"), 
		Some("'move-object/from16'"), Some("'move-object/16'"), Some("'move-result'"), 
		Some("'move-result-wide'"), Some("'move-result-object'"), Some("'move-exception'"), 
		Some("'return-void'"), Some("'return'"), Some("'return-wide'"), Some("'return-object'"), 
		Some("'const/4'"), Some("'const/16'"), Some("'const'"), Some("'const/high16'"), 
		Some("'const-wide/16'"), Some("'const-wide/32'"), Some("'const-wide'"), 
		Some("'const-wide/high16'"), Some("'const-string'"), Some("'const-string/jumbo'"), 
		Some("'const-class'"), Some("'monitor-enter'"), Some("'monitor-exit'"), 
		Some("'check-cast'"), Some("'instance-of'"), Some("'array-length'"), Some("'new-instance'"), 
		Some("'new-array'"), Some("'filled-new-array'"), Some("'filled-new-array/range'"), 
		Some("'fill-array-data'"), Some("'throw'"), Some("'goto'"), Some("'goto/16'"), 
		Some("'goto/32'"), Some("'cmpl-float'"), Some("'cmpg-float'"), Some("'cmpl-double'"), 
		Some("'cmpg-double'"), Some("'cmp-long'"), Some("'if-eq'"), Some("'if-ne'"), 
		Some("'if-lt'"), Some("'if-ge'"), Some("'if-gt'"), Some("'if-le'"), Some("'if-eqz'"), 
		Some("'if-nez'"), Some("'if-ltz'"), Some("'if-gez'"), Some("'if-gtz'"), 
		Some("'if-lez'"), Some("'aget'"), Some("'aget-wide'"), Some("'aget-object'"), 
		Some("'aget-boolean'"), Some("'aget-byte'"), Some("'aget-char'"), Some("'aget-short'"), 
		Some("'aput'"), Some("'aput-wide'"), Some("'aput-object'"), Some("'aput-boolean'"), 
		Some("'aput-byte'"), Some("'aput-char'"), Some("'aput-short'"), Some("'iget'"), 
		Some("'iget-wide'"), Some("'iget-object'"), Some("'iget-boolean'"), Some("'iget-byte'"), 
		Some("'iget-char'"), Some("'iget-short'"), Some("'iput'"), Some("'iput-wide'"), 
		Some("'iput-object'"), Some("'iput-boolean'"), Some("'iput-byte'"), Some("'iput-char'"), 
		Some("'iput-short'"), Some("'sget'"), Some("'sget-wide'"), Some("'sget-object'"), 
		Some("'sget-boolean'"), Some("'sget-byte'"), Some("'sget-char'"), Some("'sget-short'"), 
		Some("'sput'"), Some("'sput-wide'"), Some("'sput-object'"), Some("'sput-boolean'"), 
		Some("'sput-byte'"), Some("'sput-char'"), Some("'sput-short'"), Some("'invoke-virtual'"), 
		Some("'invoke-super'"), Some("'invoke-direct'"), Some("'invoke-static'"), 
		Some("'invoke-interface'"), Some("'invoke-virtual/range'"), Some("'invoke-super/range'"), 
		Some("'invoke-direct/range'"), Some("'invoke-static/range'"), Some("'invoke-interface/range'"), 
		Some("'neg-int'"), Some("'not-int'"), Some("'neg-long'"), Some("'not-long'"), 
		Some("'neg-float'"), Some("'neg-double'"), Some("'int-to-long'"), Some("'int-to-float'"), 
		Some("'int-to-double'"), Some("'long-to-int'"), Some("'long-to-float'"), 
		Some("'long-to-double'"), Some("'float-to-int'"), Some("'float-to-long'"), 
		Some("'float-to-double'"), Some("'double-to-int'"), Some("'double-to-long'"), 
		Some("'double-to-float'"), Some("'int-to-byte'"), Some("'int-to-char'"), 
		Some("'int-to-short'"), Some("'add-int'"), Some("'sub-int'"), Some("'mul-int'"), 
		Some("'div-int'"), Some("'rem-int'"), Some("'and-int'"), Some("'or-int'"), 
		Some("'xor-int'"), Some("'shl-int'"), Some("'shr-int'"), Some("'ushr-int'"), 
		Some("'add-long'"), Some("'sub-long'"), Some("'mul-long'"), Some("'div-long'"), 
		Some("'rem-long'"), Some("'and-long'"), Some("'or-long'"), Some("'xor-long'"), 
		Some("'shl-long'"), Some("'shr-long'"), Some("'ushr-long'"), Some("'add-float'"), 
		Some("'sub-float'"), Some("'mul-float'"), Some("'div-float'"), Some("'rem-float'"), 
		Some("'add-double'"), Some("'sub-double'"), Some("'mul-double'"), Some("'div-double'"), 
		Some("'rem-double'"), Some("'add-int/2addr'"), Some("'sub-int/2addr'"), 
		Some("'mul-int/2addr'"), Some("'div-int/2addr'"), Some("'rem-int/2addr'"), 
		Some("'and-int/2addr'"), Some("'or-int/2addr'"), Some("'xor-int/2addr'"), 
		Some("'shl-int/2addr'"), Some("'shr-int/2addr'"), Some("'ushr-int/2addr'"), 
		Some("'add-long/2addr'"), Some("'sub-long/2addr'"), Some("'mul-long/2addr'"), 
		Some("'div-long/2addr'"), Some("'rem-long/2addr'"), Some("'and-long/2addr'"), 
		Some("'or-long/2addr'"), Some("'xor-long/2addr'"), Some("'shl-long/2addr'"), 
		Some("'shr-long/2addr'"), Some("'ushr-long/2addr'"), Some("'add-float/2addr'"), 
		Some("'sub-float/2addr'"), Some("'mul-float/2addr'"), Some("'div-float/2addr'"), 
		Some("'rem-float/2addr'"), Some("'add-double/2addr'"), Some("'sub-double/2addr'"), 
		Some("'mul-double/2addr'"), Some("'div-double/2addr'"), Some("'rem-double/2addr'"), 
		Some("'add-int/lit16'"), Some("'rsub-int'"), Some("'mul-int/lit16'"), 
		Some("'div-int/lit16'"), Some("'rem-int/lit16'"), Some("'and-int/lit16'"), 
		Some("'or-int/lit16'"), Some("'xor-int/lit16'"), Some("'add-int/lit8'"), 
		Some("'rsub-int/lit8'"), Some("'mul-int/lit8'"), Some("'div-int/lit8'"), 
		Some("'rem-int/lit8'"), Some("'and-int/lit8'"), Some("'or-int/lit8'"), 
		Some("'xor-int/lit8'"), Some("'shl-int/lit8'"), Some("'shr-int/lit8'"), 
		Some("'ushr-int/lit8'"), Some("'invoke-polymorphic'"), Some("'invoke-polymorphic/range'"), 
		Some("'invoke-custom'"), Some("'invoke-custom/range'"), Some("'const-method-handle'"), 
		Some("'const-method-type'"), Some("'packed-switch'"), Some("'sparse-switch'"), 
		None, None, None, None, None, None, None, Some("'null'")
	];
	pub const _SYMBOLIC_NAMES: [Option<&'static str>;307]  = [
		None, Some("QUALIFIED_TYPE_NAME"), Some("VOID_TYPE"), Some("BOOLEAN_TYPE"), 
		Some("BYTE_TYPE"), Some("SHORT_TYPE"), Some("CHAR_TYPE"), Some("INT_TYPE"), 
		Some("LONG_TYPE"), Some("FLOAT_TYPE"), Some("DOUBLE_TYPE"), Some("COMPOUND_METHOD_ARG_LITERAL"), 
		Some("LBRACK"), Some("RBRACK"), Some("LPAREN"), Some("RPAREN"), Some("LBRACE"), 
		Some("RBRACE"), Some("COLON"), Some("ASSIGN"), Some("DOT"), Some("SUB"), 
		Some("COMMA"), Some("SLASH"), Some("LT"), Some("GT"), Some("ARROW"), Some("SEMI"), 
		Some("METHOD_DIRECTIVE"), Some("METHOD_END_DIRECTIVE"), Some("CLASS_DIRECTIVE"), 
		Some("SOURCE_DIRECTIVE"), Some("SUPER_DIRECTIVE"), Some("FIELD_DIRECTIVE"), 
		Some("REGISTERS_DIRECTIVE"), Some("LOCALS_DIRECTIVE"), Some("PARAM_DIRECTIVE"), 
		Some("LINE_DIRECTIVE"), Some("CATCH_DIRECTIVE"), Some("CATCHALL_DIRECTIVE"), 
		Some("ANNOTATION_DIRECTIVE"), Some("ANNOTATION_END_DIRECTIVE"), Some("LOCAL_DIRECTIVE"), 
		Some("LOCAL_END_DIRECTIVE"), Some("RESTART_LOCAL_DIRECTIVE"), Some("PACKED_SWITCH_DIRECTIVE"), 
		Some("PACKED_SWITCH_END_DIRECTIVE"), Some("ARRAY_DATA_DIRECTIVE"), Some("ARRAY_DATA_END_DIRECTIVE"), 
		Some("SPARSE_SWITCH_DIRECTIVE"), Some("SPARSE_SWITCH_END_DIRECTIVE"), 
		Some("PARAM_END_DIRECTIVE"), Some("PUBLIC"), Some("PRIVATE"), Some("PROTECTED"), 
		Some("FINAL"), Some("ANNOTATION"), Some("STATIC"), Some("SYNTHETIC"), 
		Some("CONSTRUCTOR"), Some("ABSTRACT"), Some("ENUM"), Some("INTERFACE"), 
		Some("TRANSIENT"), Some("BRIDGE"), Some("DECLARED_SYNCHRONIZED"), Some("VOLATILE"), 
		Some("STRICTFP"), Some("VARARGS"), Some("NATIVE"), Some("OP_NOP"), Some("OP_MOVE"), 
		Some("OP_MOVE_FROM16"), Some("OP_MOVE_16"), Some("OP_MOVE_WIDE"), Some("OP_MOVE_WIDE_FROM16"), 
		Some("OP_MOVE_WIDE_16"), Some("OP_MOVE_OBJECT"), Some("OP_MOVE_OBJECT_FROM16"), 
		Some("OP_MOVE_OBJECT_16"), Some("OP_MOVE_RESULT"), Some("OP_MOVE_RESULT_WIDE"), 
		Some("OP_MOVE_RESULT_OBJECT"), Some("OP_MOVE_EXCEPTION"), Some("OP_RETURN_VOID"), 
		Some("OP_RETURN"), Some("OP_RETURN_WIDE"), Some("OP_RETURN_OBJECT"), Some("OP_CONST_4"), 
		Some("OP_CONST_16"), Some("OP_CONST"), Some("OP_CONST_HIGH16"), Some("OP_CONST_WIDE_16"), 
		Some("OP_CONST_WIDE_32"), Some("OP_CONST_WIDE"), Some("OP_CONST_WIDE_HIGH16"), 
		Some("OP_CONST_STRING"), Some("OP_CONST_STRING_JUMBO"), Some("OP_CONST_CLASS"), 
		Some("OP_MONITOR_ENTER"), Some("OP_MONITOR_EXIT"), Some("OP_CHECK_CAST"), 
		Some("OP_INSTANCE_OF"), Some("OP_ARRAY_LENGTH"), Some("OP_NEW_INSTANCE"), 
		Some("OP_NEW_ARRAY"), Some("OP_FILLED_NEW_ARRAY"), Some("OP_FILLED_NEW_ARRAY_RANGE"), 
		Some("OP_FILL_ARRAY_DATA"), Some("OP_THROW"), Some("OP_GOTO"), Some("OP_GOTO_16"), 
		Some("OP_GOTO_32"), Some("OP_CMPL_FLOAT"), Some("OP_CMPG_FLOAT"), Some("OP_CMPL_DOUBLE"), 
		Some("OP_CMPG_DOUBLE"), Some("OP_CMP_LONG"), Some("OP_IF_EQ"), Some("OP_IF_NE"), 
		Some("OP_IF_LT"), Some("OP_IF_GE"), Some("OP_IF_GT"), Some("OP_IF_LE"), 
		Some("OP_IF_EQZ"), Some("OP_IF_NEZ"), Some("OP_IF_LTZ"), Some("OP_IF_GEZ"), 
		Some("OP_IF_GTZ"), Some("OP_IF_LEZ"), Some("OP_AGET"), Some("OP_AGET_WIDE"), 
		Some("OP_AGET_OBJECT"), Some("OP_AGET_BOOLEAN"), Some("OP_AGET_BYTE"), 
		Some("OP_AGET_CHAR"), Some("OP_AGET_SHORT"), Some("OP_APUT"), Some("OP_APUT_WIDE"), 
		Some("OP_APUT_OBJECT"), Some("OP_APUT_BOOLEAN"), Some("OP_APUT_BYTE"), 
		Some("OP_APUT_CHAR"), Some("OP_APUT_SHORT"), Some("OP_IGET"), Some("OP_IGET_WIDE"), 
		Some("OP_IGET_OBJECT"), Some("OP_IGET_BOOLEAN"), Some("OP_IGET_BYTE"), 
		Some("OP_IGET_CHAR"), Some("OP_IGET_SHORT"), Some("OP_IPUT"), Some("OP_IPUT_WIDE"), 
		Some("OP_IPUT_OBJECT"), Some("OP_IPUT_BOOLEAN"), Some("OP_IPUT_BYTE"), 
		Some("OP_IPUT_CHAR"), Some("OP_IPUT_SHORT"), Some("OP_SGET"), Some("OP_SGET_WIDE"), 
		Some("OP_SGET_OBJECT"), Some("OP_SGET_BOOLEAN"), Some("OP_SGET_BYTE"), 
		Some("OP_SGET_CHAR"), Some("OP_SGET_SHORT"), Some("OP_SPUT"), Some("OP_SPUT_WIDE"), 
		Some("OP_SPUT_OBJECT"), Some("OP_SPUT_BOOLEAN"), Some("OP_SPUT_BYTE"), 
		Some("OP_SPUT_CHAR"), Some("OP_SPUT_SHORT"), Some("OP_INVOKE_VIRTUAL"), 
		Some("OP_INVOKE_SUPER"), Some("OP_INVOKE_DIRECT"), Some("OP_INVOKE_STATIC"), 
		Some("OP_INVOKE_INTERFACE"), Some("OP_INVOKE_VIRTUAL_RANGE"), Some("OP_INVOKE_SUPER_RANGE"), 
		Some("OP_INVOKE_DIRECT_RANGE"), Some("OP_INVOKE_STATIC_RANGE"), Some("OP_INVOKE_INTERFACE_RANGE"), 
		Some("OP_NEG_INT"), Some("OP_NOT_INT"), Some("OP_NEG_LONG"), Some("OP_NOT_LONG"), 
		Some("OP_NEG_FLOAT"), Some("OP_NEG_DOUBLE"), Some("OP_INT_TO_LONG"), Some("OP_INT_TO_FLOAT"), 
		Some("OP_INT_TO_DOUBLE"), Some("OP_LONG_TO_INT"), Some("OP_LONG_TO_FLOAT"), 
		Some("OP_LONG_TO_DOUBLE"), Some("OP_FLOAT_TO_INT"), Some("OP_FLOAT_TO_LONG"), 
		Some("OP_FLOAT_TO_DOUBLE"), Some("OP_DOUBLE_TO_INT"), Some("OP_DOUBLE_TO_LONG"), 
		Some("OP_DOUBLE_TO_FLOAT"), Some("OP_INT_TO_BYTE"), Some("OP_INT_TO_CHAR"), 
		Some("OP_INT_TO_SHORT"), Some("OP_ADD_INT"), Some("OP_SUB_INT"), Some("OP_MUL_INT"), 
		Some("OP_DIV_INT"), Some("OP_REM_INT"), Some("OP_AND_INT"), Some("OP_OR_INT"), 
		Some("OP_XOR_INT"), Some("OP_SHL_INT"), Some("OP_SHR_INT"), Some("OP_USHR_INT"), 
		Some("OP_ADD_LONG"), Some("OP_SUB_LONG"), Some("OP_MUL_LONG"), Some("OP_DIV_LONG"), 
		Some("OP_REM_LONG"), Some("OP_AND_LONG"), Some("OP_OR_LONG"), Some("OP_XOR_LONG"), 
		Some("OP_SHL_LONG"), Some("OP_SHR_LONG"), Some("OP_USHR_LONG"), Some("OP_ADD_FLOAT"), 
		Some("OP_SUB_FLOAT"), Some("OP_MUL_FLOAT"), Some("OP_DIV_FLOAT"), Some("OP_REM_FLOAT"), 
		Some("OP_ADD_DOUBLE"), Some("OP_SUB_DOUBLE"), Some("OP_MUL_DOUBLE"), Some("OP_DIV_DOUBLE"), 
		Some("OP_REM_DOUBLE"), Some("OP_ADD_INT_2ADDR"), Some("OP_SUB_INT_2ADDR"), 
		Some("OP_MUL_INT_2ADDR"), Some("OP_DIV_INT_2ADDR"), Some("OP_REM_INT_2ADDR"), 
		Some("OP_AND_INT_2ADDR"), Some("OP_OR_INT_2ADDR"), Some("OP_XOR_INT_2ADDR"), 
		Some("OP_SHL_INT_2ADDR"), Some("OP_SHR_INT_2ADDR"), Some("OP_USHR_INT_2ADDR"), 
		Some("OP_ADD_LONG_2ADDR"), Some("OP_SUB_LONG_2ADDR"), Some("OP_MUL_LONG_2ADDR"), 
		Some("OP_DIV_LONG_2ADDR"), Some("OP_REM_LONG_2ADDR"), Some("OP_AND_LONG_2ADDR"), 
		Some("OP_OR_LONG_2ADDR"), Some("OP_XOR_LONG_2ADDR"), Some("OP_SHL_LONG_2ADDR"), 
		Some("OP_SHR_LONG_2ADDR"), Some("OP_USHR_LONG_2ADDR"), Some("OP_ADD_FLOAT_2ADDR"), 
		Some("OP_SUB_FLOAT_2ADDR"), Some("OP_MUL_FLOAT_2ADDR"), Some("OP_DIV_FLOAT_2ADDR"), 
		Some("OP_REM_FLOAT_2ADDR"), Some("OP_ADD_DOUBLE_2ADDR"), Some("OP_SUB_DOUBLE_2ADDR"), 
		Some("OP_MUL_DOUBLE_2ADDR"), Some("OP_DIV_DOUBLE_2ADDR"), Some("OP_REM_DOUBLE_2ADDR"), 
		Some("OP_ADD_INT_LIT16"), Some("OP_RSUB_INT"), Some("OP_MUL_INT_LIT16"), 
		Some("OP_DIV_INT_LIT16"), Some("OP_REM_INT_LIT16"), Some("OP_AND_INT_LIT16"), 
		Some("OP_OR_INT_LIT16"), Some("OP_XOR_INT_LIT16"), Some("OP_ADD_INT_LIT8"), 
		Some("OP_RSUB_INT_LIT8"), Some("OP_MUL_INT_LIT8"), Some("OP_DIV_INT_LIT8"), 
		Some("OP_REM_INT_LIT8"), Some("OP_AND_INT_LIT8"), Some("OP_OR_INT_LIT8"), 
		Some("OP_XOR_INT_LIT8"), Some("OP_SHL_INT_LIT8"), Some("OP_SHR_INT_LIT8"), 
		Some("OP_USHR_INT_LIT8"), Some("OP_INVOKE_POLYMORPHIC"), Some("OP_INVOKE_POLYMORPHIC_RANGE"), 
		Some("OP_INVOKE_CUSTOM"), Some("OP_INVOKE_CUSTOM_RANGE"), Some("OP_CONST_METHOD_HANDLE"), 
		Some("OP_CONST_METHOD_TYPE"), Some("OP_PACKED_SWITCH"), Some("OP_SPARSE_SWITCH"), 
		Some("DECIMAL_LITERAL"), Some("HEX_LITERAL"), Some("OCT_LITERAL"), Some("BINARY_LITERAL"), 
		Some("FLOAT_LITERAL"), Some("HEX_FLOAT_LITERAL"), Some("BOOL_LITERAL"), 
		Some("NULL_LITERAL"), Some("CHAR_LITERAL"), Some("STRING_LITERAL"), Some("IDENTIFIER"), 
		Some("WS"), Some("LINE_COMMENT")
	];
	lazy_static!{
	    static ref _shared_context_cache: Arc<PredictionContextCache> = Arc::new(PredictionContextCache::new());
		static ref VOCABULARY: Box<dyn Vocabulary> = Box::new(VocabularyImpl::new(_LITERAL_NAMES.iter(), _SYMBOLIC_NAMES.iter(), None));
	}


type BaseParserType<'input, I> =
	BaseParser<'input,SmaliParserExt<'input>, I, SmaliParserContextType , dyn SmaliParserListener<'input> + 'input >;

type TokenType<'input> = <LocalTokenFactory<'input> as TokenFactory<'input>>::Tok;
pub type LocalTokenFactory<'input> = CommonTokenFactory;

pub type SmaliParserTreeWalker<'input,'a> =
	ParseTreeWalker<'input, 'a, SmaliParserContextType , dyn SmaliParserListener<'input> + 'a>;

/// Parser for SmaliParser grammar
pub struct SmaliParser<'input,I,H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	base:BaseParserType<'input,I>,
	interpreter:Arc<ParserATNSimulator>,
	_shared_context_cache: Box<PredictionContextCache>,
    pub err_handler: H,
}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn get_serialized_atn() -> &'static str { _serializedATN }

    pub fn set_error_strategy(&mut self, strategy: H) {
        self.err_handler = strategy
    }

    pub fn with_strategy(input: I, strategy: H) -> Self {
		antlr_rust::recognizer::check_version("0","3");
		let interpreter = Arc::new(ParserATNSimulator::new(
			_ATN.clone(),
			_decision_to_DFA.clone(),
			_shared_context_cache.clone(),
		));
		Self {
			base: BaseParser::new_base_parser(
				input,
				Arc::clone(&interpreter),
				SmaliParserExt{
					_pd: Default::default(),
				}
			),
			interpreter,
            _shared_context_cache: Box::new(PredictionContextCache::new()),
            err_handler: strategy,
        }
    }

}

type DynStrategy<'input,I> = Box<dyn ErrorStrategy<'input,BaseParserType<'input,I>> + 'input>;

impl<'input, I> SmaliParser<'input, I, DynStrategy<'input,I>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
    pub fn with_dyn_strategy(input: I) -> Self{
    	Self::with_strategy(input,Box::new(DefaultErrorStrategy::new()))
    }
}

impl<'input, I> SmaliParser<'input, I, DefaultErrorStrategy<'input,SmaliParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
    pub fn new(input: I) -> Self{
    	Self::with_strategy(input,DefaultErrorStrategy::new())
    }
}

/// Trait for monomorphized trait object that corresponds to the nodes of parse tree generated for SmaliParser
pub trait SmaliParserContext<'input>:
	for<'x> Listenable<dyn SmaliParserListener<'input> + 'x > + 
	ParserRuleContext<'input, TF=LocalTokenFactory<'input>, Ctx=SmaliParserContextType>
{}

antlr_rust::coerce_from!{ 'input : SmaliParserContext<'input> }

impl<'input> SmaliParserContext<'input> for TerminalNode<'input,SmaliParserContextType> {}
impl<'input> SmaliParserContext<'input> for ErrorNode<'input,SmaliParserContextType> {}

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn SmaliParserContext<'input> + 'input }

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn SmaliParserListener<'input> + 'input }

pub struct SmaliParserContextType;
antlr_rust::tid!{SmaliParserContextType}

impl<'input> ParserNodeType<'input> for SmaliParserContextType{
	type TF = LocalTokenFactory<'input>;
	type Type = dyn SmaliParserContext<'input> + 'input;
}

impl<'input, I, H> Deref for SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
    type Target = BaseParserType<'input,I>;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl<'input, I, H> DerefMut for SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.base
    }
}

pub struct SmaliParserExt<'input>{
	_pd: PhantomData<&'input str>,
}

impl<'input> SmaliParserExt<'input>{
}
antlr_rust::tid! { SmaliParserExt<'a> }

impl<'input> TokenAware<'input> for SmaliParserExt<'input>{
	type TF = LocalTokenFactory<'input>;
}

impl<'input,I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>> ParserRecog<'input, BaseParserType<'input,I>> for SmaliParserExt<'input>{}

impl<'input,I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>> Actions<'input, BaseParserType<'input,I>> for SmaliParserExt<'input>{
	fn get_grammar_file_name(&self) -> & str{ "SmaliParser.g4"}

   	fn get_rule_names(&self) -> &[& str] {&ruleNames}

   	fn get_vocabulary(&self) -> &dyn Vocabulary { &**VOCABULARY }
}
//------------------- registerIdentifier ----------------
pub type RegisterIdentifierContextAll<'input> = RegisterIdentifierContext<'input>;


pub type RegisterIdentifierContext<'input> = BaseParserRuleContext<'input,RegisterIdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct RegisterIdentifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for RegisterIdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for RegisterIdentifierContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_registerIdentifier(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_registerIdentifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RegisterIdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_registerIdentifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_registerIdentifier }
}
antlr_rust::tid!{RegisterIdentifierContextExt<'a>}

impl<'input> RegisterIdentifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RegisterIdentifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RegisterIdentifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RegisterIdentifierContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<RegisterIdentifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IDENTIFIER
/// Returns `None` if there is no child corresponding to token IDENTIFIER
fn IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(IDENTIFIER, 0)
}

}

impl<'input> RegisterIdentifierContextAttrs<'input> for RegisterIdentifierContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn registerIdentifier(&mut self,)
	-> Result<Rc<RegisterIdentifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RegisterIdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 0, RULE_registerIdentifier);
        let mut _localctx: Rc<RegisterIdentifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(692);
			recog.base.match_token(IDENTIFIER,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- stringLiteral ----------------
pub type StringLiteralContextAll<'input> = StringLiteralContext<'input>;


pub type StringLiteralContext<'input> = BaseParserRuleContext<'input,StringLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct StringLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for StringLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for StringLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_stringLiteral(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_stringLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for StringLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_stringLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_stringLiteral }
}
antlr_rust::tid!{StringLiteralContextExt<'a>}

impl<'input> StringLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StringLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StringLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StringLiteralContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<StringLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token STRING_LITERAL
/// Returns `None` if there is no child corresponding to token STRING_LITERAL
fn STRING_LITERAL(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(STRING_LITERAL, 0)
}

}

impl<'input> StringLiteralContextAttrs<'input> for StringLiteralContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn stringLiteral(&mut self,)
	-> Result<Rc<StringLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StringLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 2, RULE_stringLiteral);
        let mut _localctx: Rc<StringLiteralContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(694);
			recog.base.match_token(STRING_LITERAL,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- negativeNumericLiteral ----------------
pub type NegativeNumericLiteralContextAll<'input> = NegativeNumericLiteralContext<'input>;


pub type NegativeNumericLiteralContext<'input> = BaseParserRuleContext<'input,NegativeNumericLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct NegativeNumericLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for NegativeNumericLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for NegativeNumericLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_negativeNumericLiteral(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_negativeNumericLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NegativeNumericLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_negativeNumericLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_negativeNumericLiteral }
}
antlr_rust::tid!{NegativeNumericLiteralContextExt<'a>}

impl<'input> NegativeNumericLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NegativeNumericLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NegativeNumericLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NegativeNumericLiteralContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<NegativeNumericLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SUB
/// Returns `None` if there is no child corresponding to token SUB
fn SUB(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(SUB, 0)
}
fn positiveNumericLiteral(&self) -> Option<Rc<PositiveNumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NegativeNumericLiteralContextAttrs<'input> for NegativeNumericLiteralContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn negativeNumericLiteral(&mut self,)
	-> Result<Rc<NegativeNumericLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NegativeNumericLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 4, RULE_negativeNumericLiteral);
        let mut _localctx: Rc<NegativeNumericLiteralContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(696);
			recog.base.match_token(SUB,&mut recog.err_handler)?;

			/*InvokeRule positiveNumericLiteral*/
			recog.base.set_state(697);
			recog.positiveNumericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- decimalNumericLiteral ----------------
pub type DecimalNumericLiteralContextAll<'input> = DecimalNumericLiteralContext<'input>;


pub type DecimalNumericLiteralContext<'input> = BaseParserRuleContext<'input,DecimalNumericLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct DecimalNumericLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for DecimalNumericLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for DecimalNumericLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_decimalNumericLiteral(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_decimalNumericLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DecimalNumericLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_decimalNumericLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_decimalNumericLiteral }
}
antlr_rust::tid!{DecimalNumericLiteralContextExt<'a>}

impl<'input> DecimalNumericLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DecimalNumericLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DecimalNumericLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DecimalNumericLiteralContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<DecimalNumericLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DECIMAL_LITERAL
/// Returns `None` if there is no child corresponding to token DECIMAL_LITERAL
fn DECIMAL_LITERAL(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(DECIMAL_LITERAL, 0)
}

}

impl<'input> DecimalNumericLiteralContextAttrs<'input> for DecimalNumericLiteralContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn decimalNumericLiteral(&mut self,)
	-> Result<Rc<DecimalNumericLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DecimalNumericLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 6, RULE_decimalNumericLiteral);
        let mut _localctx: Rc<DecimalNumericLiteralContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(699);
			recog.base.match_token(DECIMAL_LITERAL,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- hexNumericLiteral ----------------
pub type HexNumericLiteralContextAll<'input> = HexNumericLiteralContext<'input>;


pub type HexNumericLiteralContext<'input> = BaseParserRuleContext<'input,HexNumericLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct HexNumericLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for HexNumericLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for HexNumericLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_hexNumericLiteral(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_hexNumericLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for HexNumericLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_hexNumericLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_hexNumericLiteral }
}
antlr_rust::tid!{HexNumericLiteralContextExt<'a>}

impl<'input> HexNumericLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<HexNumericLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,HexNumericLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait HexNumericLiteralContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<HexNumericLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token HEX_LITERAL
/// Returns `None` if there is no child corresponding to token HEX_LITERAL
fn HEX_LITERAL(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(HEX_LITERAL, 0)
}

}

impl<'input> HexNumericLiteralContextAttrs<'input> for HexNumericLiteralContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn hexNumericLiteral(&mut self,)
	-> Result<Rc<HexNumericLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = HexNumericLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 8, RULE_hexNumericLiteral);
        let mut _localctx: Rc<HexNumericLiteralContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(701);
			recog.base.match_token(HEX_LITERAL,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- octNumericLiteral ----------------
pub type OctNumericLiteralContextAll<'input> = OctNumericLiteralContext<'input>;


pub type OctNumericLiteralContext<'input> = BaseParserRuleContext<'input,OctNumericLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct OctNumericLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for OctNumericLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for OctNumericLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_octNumericLiteral(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_octNumericLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for OctNumericLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_octNumericLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_octNumericLiteral }
}
antlr_rust::tid!{OctNumericLiteralContextExt<'a>}

impl<'input> OctNumericLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OctNumericLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OctNumericLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OctNumericLiteralContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<OctNumericLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OCT_LITERAL
/// Returns `None` if there is no child corresponding to token OCT_LITERAL
fn OCT_LITERAL(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OCT_LITERAL, 0)
}

}

impl<'input> OctNumericLiteralContextAttrs<'input> for OctNumericLiteralContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn octNumericLiteral(&mut self,)
	-> Result<Rc<OctNumericLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OctNumericLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 10, RULE_octNumericLiteral);
        let mut _localctx: Rc<OctNumericLiteralContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(703);
			recog.base.match_token(OCT_LITERAL,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- binaryNumericLiteral ----------------
pub type BinaryNumericLiteralContextAll<'input> = BinaryNumericLiteralContext<'input>;


pub type BinaryNumericLiteralContext<'input> = BaseParserRuleContext<'input,BinaryNumericLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct BinaryNumericLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for BinaryNumericLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for BinaryNumericLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_binaryNumericLiteral(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_binaryNumericLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for BinaryNumericLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_binaryNumericLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_binaryNumericLiteral }
}
antlr_rust::tid!{BinaryNumericLiteralContextExt<'a>}

impl<'input> BinaryNumericLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BinaryNumericLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BinaryNumericLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BinaryNumericLiteralContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<BinaryNumericLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token BINARY_LITERAL
/// Returns `None` if there is no child corresponding to token BINARY_LITERAL
fn BINARY_LITERAL(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(BINARY_LITERAL, 0)
}

}

impl<'input> BinaryNumericLiteralContextAttrs<'input> for BinaryNumericLiteralContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn binaryNumericLiteral(&mut self,)
	-> Result<Rc<BinaryNumericLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BinaryNumericLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 12, RULE_binaryNumericLiteral);
        let mut _localctx: Rc<BinaryNumericLiteralContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(705);
			recog.base.match_token(BINARY_LITERAL,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- floatNumericLiteral ----------------
pub type FloatNumericLiteralContextAll<'input> = FloatNumericLiteralContext<'input>;


pub type FloatNumericLiteralContext<'input> = BaseParserRuleContext<'input,FloatNumericLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct FloatNumericLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for FloatNumericLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for FloatNumericLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_floatNumericLiteral(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_floatNumericLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FloatNumericLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_floatNumericLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_floatNumericLiteral }
}
antlr_rust::tid!{FloatNumericLiteralContextExt<'a>}

impl<'input> FloatNumericLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FloatNumericLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FloatNumericLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FloatNumericLiteralContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<FloatNumericLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FLOAT_LITERAL
/// Returns `None` if there is no child corresponding to token FLOAT_LITERAL
fn FLOAT_LITERAL(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(FLOAT_LITERAL, 0)
}

}

impl<'input> FloatNumericLiteralContextAttrs<'input> for FloatNumericLiteralContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn floatNumericLiteral(&mut self,)
	-> Result<Rc<FloatNumericLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FloatNumericLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 14, RULE_floatNumericLiteral);
        let mut _localctx: Rc<FloatNumericLiteralContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(707);
			recog.base.match_token(FLOAT_LITERAL,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- hexFloatLiteral ----------------
pub type HexFloatLiteralContextAll<'input> = HexFloatLiteralContext<'input>;


pub type HexFloatLiteralContext<'input> = BaseParserRuleContext<'input,HexFloatLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct HexFloatLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for HexFloatLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for HexFloatLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_hexFloatLiteral(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_hexFloatLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for HexFloatLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_hexFloatLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_hexFloatLiteral }
}
antlr_rust::tid!{HexFloatLiteralContextExt<'a>}

impl<'input> HexFloatLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<HexFloatLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,HexFloatLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait HexFloatLiteralContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<HexFloatLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token HEX_FLOAT_LITERAL
/// Returns `None` if there is no child corresponding to token HEX_FLOAT_LITERAL
fn HEX_FLOAT_LITERAL(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(HEX_FLOAT_LITERAL, 0)
}

}

impl<'input> HexFloatLiteralContextAttrs<'input> for HexFloatLiteralContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn hexFloatLiteral(&mut self,)
	-> Result<Rc<HexFloatLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = HexFloatLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 16, RULE_hexFloatLiteral);
        let mut _localctx: Rc<HexFloatLiteralContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(709);
			recog.base.match_token(HEX_FLOAT_LITERAL,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- positiveNumericLiteral ----------------
pub type PositiveNumericLiteralContextAll<'input> = PositiveNumericLiteralContext<'input>;


pub type PositiveNumericLiteralContext<'input> = BaseParserRuleContext<'input,PositiveNumericLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct PositiveNumericLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for PositiveNumericLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for PositiveNumericLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_positiveNumericLiteral(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_positiveNumericLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PositiveNumericLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_positiveNumericLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_positiveNumericLiteral }
}
antlr_rust::tid!{PositiveNumericLiteralContextExt<'a>}

impl<'input> PositiveNumericLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PositiveNumericLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PositiveNumericLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PositiveNumericLiteralContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<PositiveNumericLiteralContextExt<'input>>{

fn decimalNumericLiteral(&self) -> Option<Rc<DecimalNumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn hexNumericLiteral(&self) -> Option<Rc<HexNumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn octNumericLiteral(&self) -> Option<Rc<OctNumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn binaryNumericLiteral(&self) -> Option<Rc<BinaryNumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn floatNumericLiteral(&self) -> Option<Rc<FloatNumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn hexFloatLiteral(&self) -> Option<Rc<HexFloatLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PositiveNumericLiteralContextAttrs<'input> for PositiveNumericLiteralContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn positiveNumericLiteral(&mut self,)
	-> Result<Rc<PositiveNumericLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PositiveNumericLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 18, RULE_positiveNumericLiteral);
        let mut _localctx: Rc<PositiveNumericLiteralContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(717);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 DECIMAL_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule decimalNumericLiteral*/
					recog.base.set_state(711);
					recog.decimalNumericLiteral()?;

					}
				}

			 HEX_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule hexNumericLiteral*/
					recog.base.set_state(712);
					recog.hexNumericLiteral()?;

					}
				}

			 OCT_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule octNumericLiteral*/
					recog.base.set_state(713);
					recog.octNumericLiteral()?;

					}
				}

			 BINARY_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule binaryNumericLiteral*/
					recog.base.set_state(714);
					recog.binaryNumericLiteral()?;

					}
				}

			 FLOAT_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule floatNumericLiteral*/
					recog.base.set_state(715);
					recog.floatNumericLiteral()?;

					}
				}

			 HEX_FLOAT_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule hexFloatLiteral*/
					recog.base.set_state(716);
					recog.hexFloatLiteral()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- numericLiteral ----------------
pub type NumericLiteralContextAll<'input> = NumericLiteralContext<'input>;


pub type NumericLiteralContext<'input> = BaseParserRuleContext<'input,NumericLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct NumericLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for NumericLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for NumericLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_numericLiteral(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_numericLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NumericLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_numericLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_numericLiteral }
}
antlr_rust::tid!{NumericLiteralContextExt<'a>}

impl<'input> NumericLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NumericLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NumericLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NumericLiteralContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<NumericLiteralContextExt<'input>>{

fn negativeNumericLiteral(&self) -> Option<Rc<NegativeNumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn positiveNumericLiteral(&self) -> Option<Rc<PositiveNumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NumericLiteralContextAttrs<'input> for NumericLiteralContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn numericLiteral(&mut self,)
	-> Result<Rc<NumericLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NumericLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 20, RULE_numericLiteral);
        let mut _localctx: Rc<NumericLiteralContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(721);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 SUB 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule negativeNumericLiteral*/
					recog.base.set_state(719);
					recog.negativeNumericLiteral()?;

					}
				}

			 DECIMAL_LITERAL | HEX_LITERAL | OCT_LITERAL | BINARY_LITERAL | FLOAT_LITERAL |
			 HEX_FLOAT_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule positiveNumericLiteral*/
					recog.base.set_state(720);
					recog.positiveNumericLiteral()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- identifier ----------------
pub type IdentifierContextAll<'input> = IdentifierContext<'input>;


pub type IdentifierContext<'input> = BaseParserRuleContext<'input,IdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct IdentifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IdentifierContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_identifier(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_identifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_identifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_identifier }
}
antlr_rust::tid!{IdentifierContextExt<'a>}

impl<'input> IdentifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IdentifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IdentifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IdentifierContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IdentifierContextExt<'input>>{

/// Retrieves all `TerminalNode`s corresponding to token IDENTIFIER in current rule
fn IDENTIFIER_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token IDENTIFIER, starting from 0.
/// Returns `None` if number of children corresponding to token IDENTIFIER is less or equal than `i`.
fn IDENTIFIER(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(IDENTIFIER, i)
}
/// Retrieves all `TerminalNode`s corresponding to token VOID_TYPE in current rule
fn VOID_TYPE_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token VOID_TYPE, starting from 0.
/// Returns `None` if number of children corresponding to token VOID_TYPE is less or equal than `i`.
fn VOID_TYPE(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(VOID_TYPE, i)
}
/// Retrieves all `TerminalNode`s corresponding to token BOOLEAN_TYPE in current rule
fn BOOLEAN_TYPE_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token BOOLEAN_TYPE, starting from 0.
/// Returns `None` if number of children corresponding to token BOOLEAN_TYPE is less or equal than `i`.
fn BOOLEAN_TYPE(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(BOOLEAN_TYPE, i)
}
/// Retrieves all `TerminalNode`s corresponding to token BYTE_TYPE in current rule
fn BYTE_TYPE_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token BYTE_TYPE, starting from 0.
/// Returns `None` if number of children corresponding to token BYTE_TYPE is less or equal than `i`.
fn BYTE_TYPE(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(BYTE_TYPE, i)
}
/// Retrieves all `TerminalNode`s corresponding to token SHORT_TYPE in current rule
fn SHORT_TYPE_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token SHORT_TYPE, starting from 0.
/// Returns `None` if number of children corresponding to token SHORT_TYPE is less or equal than `i`.
fn SHORT_TYPE(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(SHORT_TYPE, i)
}
/// Retrieves all `TerminalNode`s corresponding to token CHAR_TYPE in current rule
fn CHAR_TYPE_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token CHAR_TYPE, starting from 0.
/// Returns `None` if number of children corresponding to token CHAR_TYPE is less or equal than `i`.
fn CHAR_TYPE(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(CHAR_TYPE, i)
}
/// Retrieves all `TerminalNode`s corresponding to token INT_TYPE in current rule
fn INT_TYPE_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token INT_TYPE, starting from 0.
/// Returns `None` if number of children corresponding to token INT_TYPE is less or equal than `i`.
fn INT_TYPE(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(INT_TYPE, i)
}
/// Retrieves all `TerminalNode`s corresponding to token LONG_TYPE in current rule
fn LONG_TYPE_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LONG_TYPE, starting from 0.
/// Returns `None` if number of children corresponding to token LONG_TYPE is less or equal than `i`.
fn LONG_TYPE(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(LONG_TYPE, i)
}
/// Retrieves all `TerminalNode`s corresponding to token FLOAT_TYPE in current rule
fn FLOAT_TYPE_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token FLOAT_TYPE, starting from 0.
/// Returns `None` if number of children corresponding to token FLOAT_TYPE is less or equal than `i`.
fn FLOAT_TYPE(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(FLOAT_TYPE, i)
}
/// Retrieves all `TerminalNode`s corresponding to token DOUBLE_TYPE in current rule
fn DOUBLE_TYPE_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOUBLE_TYPE, starting from 0.
/// Returns `None` if number of children corresponding to token DOUBLE_TYPE is less or equal than `i`.
fn DOUBLE_TYPE(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(DOUBLE_TYPE, i)
}
/// Retrieves all `TerminalNode`s corresponding to token CONSTRUCTOR in current rule
fn CONSTRUCTOR_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token CONSTRUCTOR, starting from 0.
/// Returns `None` if number of children corresponding to token CONSTRUCTOR is less or equal than `i`.
fn CONSTRUCTOR(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(CONSTRUCTOR, i)
}
/// Retrieves all `TerminalNode`s corresponding to token ANNOTATION in current rule
fn ANNOTATION_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token ANNOTATION, starting from 0.
/// Returns `None` if number of children corresponding to token ANNOTATION is less or equal than `i`.
fn ANNOTATION(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(ANNOTATION, i)
}
/// Retrieves all `TerminalNode`s corresponding to token BRIDGE in current rule
fn BRIDGE_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token BRIDGE, starting from 0.
/// Returns `None` if number of children corresponding to token BRIDGE is less or equal than `i`.
fn BRIDGE(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(BRIDGE, i)
}
/// Retrieves all `TerminalNode`s corresponding to token NATIVE in current rule
fn NATIVE_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NATIVE, starting from 0.
/// Returns `None` if number of children corresponding to token NATIVE is less or equal than `i`.
fn NATIVE(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(NATIVE, i)
}
/// Retrieves all `TerminalNode`s corresponding to token VARARGS in current rule
fn VARARGS_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token VARARGS, starting from 0.
/// Returns `None` if number of children corresponding to token VARARGS is less or equal than `i`.
fn VARARGS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(VARARGS, i)
}
/// Retrieves all `TerminalNode`s corresponding to token SYNTHETIC in current rule
fn SYNTHETIC_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token SYNTHETIC, starting from 0.
/// Returns `None` if number of children corresponding to token SYNTHETIC is less or equal than `i`.
fn SYNTHETIC(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(SYNTHETIC, i)
}

}

impl<'input> IdentifierContextAttrs<'input> for IdentifierContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn identifier(&mut self,)
	-> Result<Rc<IdentifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 22, RULE_identifier);
        let mut _localctx: Rc<IdentifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(724); 
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			loop {
				{
				{
				recog.base.set_state(723);
				_la = recog.base.input.la(1);
				if { !((((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << VOID_TYPE) | (1usize << BOOLEAN_TYPE) | (1usize << BYTE_TYPE) | (1usize << SHORT_TYPE) | (1usize << CHAR_TYPE) | (1usize << INT_TYPE) | (1usize << LONG_TYPE) | (1usize << FLOAT_TYPE) | (1usize << DOUBLE_TYPE))) != 0) || ((((_la - 56)) & !0x3f) == 0 && ((1usize << (_la - 56)) & ((1usize << (ANNOTATION - 56)) | (1usize << (SYNTHETIC - 56)) | (1usize << (CONSTRUCTOR - 56)) | (1usize << (BRIDGE - 56)) | (1usize << (VARARGS - 56)) | (1usize << (NATIVE - 56)))) != 0) || _la==IDENTIFIER) } {
					recog.err_handler.recover_inline(&mut recog.base)?;

				}
				else {
					if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
					recog.err_handler.report_match(&mut recog.base);
					recog.base.consume(&mut recog.err_handler);
				}
				}
				}
				recog.base.set_state(726); 
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if !((((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << VOID_TYPE) | (1usize << BOOLEAN_TYPE) | (1usize << BYTE_TYPE) | (1usize << SHORT_TYPE) | (1usize << CHAR_TYPE) | (1usize << INT_TYPE) | (1usize << LONG_TYPE) | (1usize << FLOAT_TYPE) | (1usize << DOUBLE_TYPE))) != 0) || ((((_la - 56)) & !0x3f) == 0 && ((1usize << (_la - 56)) & ((1usize << (ANNOTATION - 56)) | (1usize << (SYNTHETIC - 56)) | (1usize << (CONSTRUCTOR - 56)) | (1usize << (BRIDGE - 56)) | (1usize << (VARARGS - 56)) | (1usize << (NATIVE - 56)))) != 0) || _la==IDENTIFIER) {break}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- referenceType ----------------
pub type ReferenceTypeContextAll<'input> = ReferenceTypeContext<'input>;


pub type ReferenceTypeContext<'input> = BaseParserRuleContext<'input,ReferenceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ReferenceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ReferenceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ReferenceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_referenceType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_referenceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ReferenceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_referenceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_referenceType }
}
antlr_rust::tid!{ReferenceTypeContextExt<'a>}

impl<'input> ReferenceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReferenceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReferenceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReferenceTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ReferenceTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token QUALIFIED_TYPE_NAME
/// Returns `None` if there is no child corresponding to token QUALIFIED_TYPE_NAME
fn QUALIFIED_TYPE_NAME(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(QUALIFIED_TYPE_NAME, 0)
}

}

impl<'input> ReferenceTypeContextAttrs<'input> for ReferenceTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn referenceType(&mut self,)
	-> Result<Rc<ReferenceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReferenceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 24, RULE_referenceType);
        let mut _localctx: Rc<ReferenceTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(728);
			recog.base.match_token(QUALIFIED_TYPE_NAME,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- voidType ----------------
pub type VoidTypeContextAll<'input> = VoidTypeContext<'input>;


pub type VoidTypeContext<'input> = BaseParserRuleContext<'input,VoidTypeContextExt<'input>>;

#[derive(Clone)]
pub struct VoidTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for VoidTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for VoidTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_voidType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_voidType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for VoidTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_voidType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_voidType }
}
antlr_rust::tid!{VoidTypeContextExt<'a>}

impl<'input> VoidTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VoidTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VoidTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VoidTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<VoidTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token VOID_TYPE
/// Returns `None` if there is no child corresponding to token VOID_TYPE
fn VOID_TYPE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(VOID_TYPE, 0)
}

}

impl<'input> VoidTypeContextAttrs<'input> for VoidTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn voidType(&mut self,)
	-> Result<Rc<VoidTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VoidTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 26, RULE_voidType);
        let mut _localctx: Rc<VoidTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(730);
			recog.base.match_token(VOID_TYPE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- booleanType ----------------
pub type BooleanTypeContextAll<'input> = BooleanTypeContext<'input>;


pub type BooleanTypeContext<'input> = BaseParserRuleContext<'input,BooleanTypeContextExt<'input>>;

#[derive(Clone)]
pub struct BooleanTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for BooleanTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for BooleanTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_booleanType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_booleanType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for BooleanTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_booleanType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_booleanType }
}
antlr_rust::tid!{BooleanTypeContextExt<'a>}

impl<'input> BooleanTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BooleanTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BooleanTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BooleanTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<BooleanTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token BOOLEAN_TYPE
/// Returns `None` if there is no child corresponding to token BOOLEAN_TYPE
fn BOOLEAN_TYPE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(BOOLEAN_TYPE, 0)
}

}

impl<'input> BooleanTypeContextAttrs<'input> for BooleanTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn booleanType(&mut self,)
	-> Result<Rc<BooleanTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BooleanTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 28, RULE_booleanType);
        let mut _localctx: Rc<BooleanTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(732);
			recog.base.match_token(BOOLEAN_TYPE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- byteType ----------------
pub type ByteTypeContextAll<'input> = ByteTypeContext<'input>;


pub type ByteTypeContext<'input> = BaseParserRuleContext<'input,ByteTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ByteTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ByteTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ByteTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_byteType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_byteType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ByteTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_byteType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_byteType }
}
antlr_rust::tid!{ByteTypeContextExt<'a>}

impl<'input> ByteTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ByteTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ByteTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ByteTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ByteTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token BYTE_TYPE
/// Returns `None` if there is no child corresponding to token BYTE_TYPE
fn BYTE_TYPE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(BYTE_TYPE, 0)
}

}

impl<'input> ByteTypeContextAttrs<'input> for ByteTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn byteType(&mut self,)
	-> Result<Rc<ByteTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ByteTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 30, RULE_byteType);
        let mut _localctx: Rc<ByteTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(734);
			recog.base.match_token(BYTE_TYPE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- shortType ----------------
pub type ShortTypeContextAll<'input> = ShortTypeContext<'input>;


pub type ShortTypeContext<'input> = BaseParserRuleContext<'input,ShortTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ShortTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ShortTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ShortTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_shortType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_shortType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ShortTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_shortType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_shortType }
}
antlr_rust::tid!{ShortTypeContextExt<'a>}

impl<'input> ShortTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ShortTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ShortTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ShortTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ShortTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SHORT_TYPE
/// Returns `None` if there is no child corresponding to token SHORT_TYPE
fn SHORT_TYPE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(SHORT_TYPE, 0)
}

}

impl<'input> ShortTypeContextAttrs<'input> for ShortTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn shortType(&mut self,)
	-> Result<Rc<ShortTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ShortTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 32, RULE_shortType);
        let mut _localctx: Rc<ShortTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(736);
			recog.base.match_token(SHORT_TYPE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- charType ----------------
pub type CharTypeContextAll<'input> = CharTypeContext<'input>;


pub type CharTypeContext<'input> = BaseParserRuleContext<'input,CharTypeContextExt<'input>>;

#[derive(Clone)]
pub struct CharTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for CharTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for CharTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_charType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_charType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CharTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_charType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_charType }
}
antlr_rust::tid!{CharTypeContextExt<'a>}

impl<'input> CharTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CharTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CharTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CharTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<CharTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CHAR_TYPE
/// Returns `None` if there is no child corresponding to token CHAR_TYPE
fn CHAR_TYPE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(CHAR_TYPE, 0)
}

}

impl<'input> CharTypeContextAttrs<'input> for CharTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn charType(&mut self,)
	-> Result<Rc<CharTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CharTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 34, RULE_charType);
        let mut _localctx: Rc<CharTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(738);
			recog.base.match_token(CHAR_TYPE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- intType ----------------
pub type IntTypeContextAll<'input> = IntTypeContext<'input>;


pub type IntTypeContext<'input> = BaseParserRuleContext<'input,IntTypeContextExt<'input>>;

#[derive(Clone)]
pub struct IntTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IntTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IntTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_intType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_intType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IntTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_intType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_intType }
}
antlr_rust::tid!{IntTypeContextExt<'a>}

impl<'input> IntTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IntTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IntTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IntTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IntTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INT_TYPE
/// Returns `None` if there is no child corresponding to token INT_TYPE
fn INT_TYPE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(INT_TYPE, 0)
}

}

impl<'input> IntTypeContextAttrs<'input> for IntTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn intType(&mut self,)
	-> Result<Rc<IntTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IntTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 36, RULE_intType);
        let mut _localctx: Rc<IntTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(740);
			recog.base.match_token(INT_TYPE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- longType ----------------
pub type LongTypeContextAll<'input> = LongTypeContext<'input>;


pub type LongTypeContext<'input> = BaseParserRuleContext<'input,LongTypeContextExt<'input>>;

#[derive(Clone)]
pub struct LongTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for LongTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for LongTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_longType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_longType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LongTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_longType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_longType }
}
antlr_rust::tid!{LongTypeContextExt<'a>}

impl<'input> LongTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LongTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LongTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LongTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<LongTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LONG_TYPE
/// Returns `None` if there is no child corresponding to token LONG_TYPE
fn LONG_TYPE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(LONG_TYPE, 0)
}

}

impl<'input> LongTypeContextAttrs<'input> for LongTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn longType(&mut self,)
	-> Result<Rc<LongTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LongTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 38, RULE_longType);
        let mut _localctx: Rc<LongTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(742);
			recog.base.match_token(LONG_TYPE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- floatType ----------------
pub type FloatTypeContextAll<'input> = FloatTypeContext<'input>;


pub type FloatTypeContext<'input> = BaseParserRuleContext<'input,FloatTypeContextExt<'input>>;

#[derive(Clone)]
pub struct FloatTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for FloatTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for FloatTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_floatType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_floatType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FloatTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_floatType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_floatType }
}
antlr_rust::tid!{FloatTypeContextExt<'a>}

impl<'input> FloatTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FloatTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FloatTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FloatTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<FloatTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FLOAT_TYPE
/// Returns `None` if there is no child corresponding to token FLOAT_TYPE
fn FLOAT_TYPE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(FLOAT_TYPE, 0)
}

}

impl<'input> FloatTypeContextAttrs<'input> for FloatTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn floatType(&mut self,)
	-> Result<Rc<FloatTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FloatTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 40, RULE_floatType);
        let mut _localctx: Rc<FloatTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(744);
			recog.base.match_token(FLOAT_TYPE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- doubleType ----------------
pub type DoubleTypeContextAll<'input> = DoubleTypeContext<'input>;


pub type DoubleTypeContext<'input> = BaseParserRuleContext<'input,DoubleTypeContextExt<'input>>;

#[derive(Clone)]
pub struct DoubleTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for DoubleTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for DoubleTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_doubleType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_doubleType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DoubleTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_doubleType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_doubleType }
}
antlr_rust::tid!{DoubleTypeContextExt<'a>}

impl<'input> DoubleTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DoubleTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DoubleTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DoubleTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<DoubleTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DOUBLE_TYPE
/// Returns `None` if there is no child corresponding to token DOUBLE_TYPE
fn DOUBLE_TYPE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(DOUBLE_TYPE, 0)
}

}

impl<'input> DoubleTypeContextAttrs<'input> for DoubleTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn doubleType(&mut self,)
	-> Result<Rc<DoubleTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DoubleTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 42, RULE_doubleType);
        let mut _localctx: Rc<DoubleTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(746);
			recog.base.match_token(DOUBLE_TYPE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- primitiveType ----------------
pub type PrimitiveTypeContextAll<'input> = PrimitiveTypeContext<'input>;


pub type PrimitiveTypeContext<'input> = BaseParserRuleContext<'input,PrimitiveTypeContextExt<'input>>;

#[derive(Clone)]
pub struct PrimitiveTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for PrimitiveTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for PrimitiveTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_primitiveType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_primitiveType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PrimitiveTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primitiveType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primitiveType }
}
antlr_rust::tid!{PrimitiveTypeContextExt<'a>}

impl<'input> PrimitiveTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimitiveTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimitiveTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrimitiveTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<PrimitiveTypeContextExt<'input>>{

fn booleanType(&self) -> Option<Rc<BooleanTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn byteType(&self) -> Option<Rc<ByteTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn shortType(&self) -> Option<Rc<ShortTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn charType(&self) -> Option<Rc<CharTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn intType(&self) -> Option<Rc<IntTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn longType(&self) -> Option<Rc<LongTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn floatType(&self) -> Option<Rc<FloatTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn doubleType(&self) -> Option<Rc<DoubleTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PrimitiveTypeContextAttrs<'input> for PrimitiveTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn primitiveType(&mut self,)
	-> Result<Rc<PrimitiveTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrimitiveTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 44, RULE_primitiveType);
        let mut _localctx: Rc<PrimitiveTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(756);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 BOOLEAN_TYPE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule booleanType*/
					recog.base.set_state(748);
					recog.booleanType()?;

					}
				}

			 BYTE_TYPE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule byteType*/
					recog.base.set_state(749);
					recog.byteType()?;

					}
				}

			 SHORT_TYPE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule shortType*/
					recog.base.set_state(750);
					recog.shortType()?;

					}
				}

			 CHAR_TYPE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule charType*/
					recog.base.set_state(751);
					recog.charType()?;

					}
				}

			 INT_TYPE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule intType*/
					recog.base.set_state(752);
					recog.intType()?;

					}
				}

			 LONG_TYPE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule longType*/
					recog.base.set_state(753);
					recog.longType()?;

					}
				}

			 FLOAT_TYPE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule floatType*/
					recog.base.set_state(754);
					recog.floatType()?;

					}
				}

			 DOUBLE_TYPE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule doubleType*/
					recog.base.set_state(755);
					recog.doubleType()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- nonArrayType ----------------
pub type NonArrayTypeContextAll<'input> = NonArrayTypeContext<'input>;


pub type NonArrayTypeContext<'input> = BaseParserRuleContext<'input,NonArrayTypeContextExt<'input>>;

#[derive(Clone)]
pub struct NonArrayTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for NonArrayTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for NonArrayTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_nonArrayType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_nonArrayType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NonArrayTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nonArrayType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nonArrayType }
}
antlr_rust::tid!{NonArrayTypeContextExt<'a>}

impl<'input> NonArrayTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NonArrayTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NonArrayTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NonArrayTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<NonArrayTypeContextExt<'input>>{

fn primitiveType(&self) -> Option<Rc<PrimitiveTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NonArrayTypeContextAttrs<'input> for NonArrayTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn nonArrayType(&mut self,)
	-> Result<Rc<NonArrayTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NonArrayTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 46, RULE_nonArrayType);
        let mut _localctx: Rc<NonArrayTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(760);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 BOOLEAN_TYPE | BYTE_TYPE | SHORT_TYPE | CHAR_TYPE | INT_TYPE | LONG_TYPE |
			 FLOAT_TYPE | DOUBLE_TYPE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule primitiveType*/
					recog.base.set_state(758);
					recog.primitiveType()?;

					}
				}

			 QUALIFIED_TYPE_NAME 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule referenceType*/
					recog.base.set_state(759);
					recog.referenceType()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodParameterLiteral ----------------
pub type MethodParameterLiteralContextAll<'input> = MethodParameterLiteralContext<'input>;


pub type MethodParameterLiteralContext<'input> = BaseParserRuleContext<'input,MethodParameterLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct MethodParameterLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MethodParameterLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MethodParameterLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodParameterLiteral(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_methodParameterLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodParameterLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodParameterLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodParameterLiteral }
}
antlr_rust::tid!{MethodParameterLiteralContextExt<'a>}

impl<'input> MethodParameterLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodParameterLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodParameterLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodParameterLiteralContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MethodParameterLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token COMPOUND_METHOD_ARG_LITERAL
/// Returns `None` if there is no child corresponding to token COMPOUND_METHOD_ARG_LITERAL
fn COMPOUND_METHOD_ARG_LITERAL(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMPOUND_METHOD_ARG_LITERAL, 0)
}
/// Retrieves first TerminalNode corresponding to token IDENTIFIER
/// Returns `None` if there is no child corresponding to token IDENTIFIER
fn IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(IDENTIFIER, 0)
}

}

impl<'input> MethodParameterLiteralContextAttrs<'input> for MethodParameterLiteralContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodParameterLiteral(&mut self,)
	-> Result<Rc<MethodParameterLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodParameterLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 48, RULE_methodParameterLiteral);
        let mut _localctx: Rc<MethodParameterLiteralContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(762);
			_la = recog.base.input.la(1);
			if { !(_la==COMPOUND_METHOD_ARG_LITERAL || _la==IDENTIFIER) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayType ----------------
pub type ArrayTypeContextAll<'input> = ArrayTypeContext<'input>;


pub type ArrayTypeContext<'input> = BaseParserRuleContext<'input,ArrayTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ArrayTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ArrayTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_arrayType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ArrayTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayType }
}
antlr_rust::tid!{ArrayTypeContextExt<'a>}

impl<'input> ArrayTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ArrayTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACK
/// Returns `None` if there is no child corresponding to token LBRACK
fn LBRACK(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(LBRACK, 0)
}
fn nonArrayType(&self) -> Option<Rc<NonArrayTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayType(&self) -> Option<Rc<ArrayTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodParameterLiteral(&self) -> Option<Rc<MethodParameterLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ArrayTypeContextAttrs<'input> for ArrayTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayType(&mut self,)
	-> Result<Rc<ArrayTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 50, RULE_arrayType);
        let mut _localctx: Rc<ArrayTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(764);
			recog.base.match_token(LBRACK,&mut recog.err_handler)?;

			recog.base.set_state(768);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 QUALIFIED_TYPE_NAME | BOOLEAN_TYPE | BYTE_TYPE | SHORT_TYPE | CHAR_TYPE |
			 INT_TYPE | LONG_TYPE | FLOAT_TYPE | DOUBLE_TYPE 
				=> {
					{
					/*InvokeRule nonArrayType*/
					recog.base.set_state(765);
					recog.nonArrayType()?;

					}
				}

			 LBRACK 
				=> {
					{
					/*InvokeRule arrayType*/
					recog.base.set_state(766);
					recog.arrayType()?;

					}
				}

			 COMPOUND_METHOD_ARG_LITERAL | IDENTIFIER 
				=> {
					{
					/*InvokeRule methodParameterLiteral*/
					recog.base.set_state(767);
					recog.methodParameterLiteral()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- referenceOrArrayType ----------------
pub type ReferenceOrArrayTypeContextAll<'input> = ReferenceOrArrayTypeContext<'input>;


pub type ReferenceOrArrayTypeContext<'input> = BaseParserRuleContext<'input,ReferenceOrArrayTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ReferenceOrArrayTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ReferenceOrArrayTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ReferenceOrArrayTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_referenceOrArrayType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_referenceOrArrayType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ReferenceOrArrayTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_referenceOrArrayType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_referenceOrArrayType }
}
antlr_rust::tid!{ReferenceOrArrayTypeContextExt<'a>}

impl<'input> ReferenceOrArrayTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReferenceOrArrayTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReferenceOrArrayTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReferenceOrArrayTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ReferenceOrArrayTypeContextExt<'input>>{

fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayType(&self) -> Option<Rc<ArrayTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ReferenceOrArrayTypeContextAttrs<'input> for ReferenceOrArrayTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn referenceOrArrayType(&mut self,)
	-> Result<Rc<ReferenceOrArrayTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReferenceOrArrayTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 52, RULE_referenceOrArrayType);
        let mut _localctx: Rc<ReferenceOrArrayTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(772);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 QUALIFIED_TYPE_NAME 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule referenceType*/
					recog.base.set_state(770);
					recog.referenceType()?;

					}
				}

			 LBRACK 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule arrayType*/
					recog.base.set_state(771);
					recog.arrayType()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- nonVoidType ----------------
pub type NonVoidTypeContextAll<'input> = NonVoidTypeContext<'input>;


pub type NonVoidTypeContext<'input> = BaseParserRuleContext<'input,NonVoidTypeContextExt<'input>>;

#[derive(Clone)]
pub struct NonVoidTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for NonVoidTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for NonVoidTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_nonVoidType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_nonVoidType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NonVoidTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nonVoidType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nonVoidType }
}
antlr_rust::tid!{NonVoidTypeContextExt<'a>}

impl<'input> NonVoidTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NonVoidTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NonVoidTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NonVoidTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<NonVoidTypeContextExt<'input>>{

fn nonArrayType(&self) -> Option<Rc<NonArrayTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayType(&self) -> Option<Rc<ArrayTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NonVoidTypeContextAttrs<'input> for NonVoidTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn nonVoidType(&mut self,)
	-> Result<Rc<NonVoidTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NonVoidTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 54, RULE_nonVoidType);
        let mut _localctx: Rc<NonVoidTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(776);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 QUALIFIED_TYPE_NAME | BOOLEAN_TYPE | BYTE_TYPE | SHORT_TYPE | CHAR_TYPE |
			 INT_TYPE | LONG_TYPE | FLOAT_TYPE | DOUBLE_TYPE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule nonArrayType*/
					recog.base.set_state(774);
					recog.nonArrayType()?;

					}
				}

			 LBRACK 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule arrayType*/
					recog.base.set_state(775);
					recog.arrayType()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- anyType ----------------
pub type AnyTypeContextAll<'input> = AnyTypeContext<'input>;


pub type AnyTypeContext<'input> = BaseParserRuleContext<'input,AnyTypeContextExt<'input>>;

#[derive(Clone)]
pub struct AnyTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AnyTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AnyTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_anyType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_anyType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AnyTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_anyType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_anyType }
}
antlr_rust::tid!{AnyTypeContextExt<'a>}

impl<'input> AnyTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnyTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnyTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnyTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AnyTypeContextExt<'input>>{

fn nonVoidType(&self) -> Option<Rc<NonVoidTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn voidType(&self) -> Option<Rc<VoidTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayType(&self) -> Option<Rc<ArrayTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AnyTypeContextAttrs<'input> for AnyTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn anyType(&mut self,)
	-> Result<Rc<AnyTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnyTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 56, RULE_anyType);
        let mut _localctx: Rc<AnyTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(781);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(8,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule nonVoidType*/
					recog.base.set_state(778);
					recog.nonVoidType()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule voidType*/
					recog.base.set_state(779);
					recog.voidType()?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule arrayType*/
					recog.base.set_state(780);
					recog.arrayType()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- nullLiteral ----------------
pub type NullLiteralContextAll<'input> = NullLiteralContext<'input>;


pub type NullLiteralContext<'input> = BaseParserRuleContext<'input,NullLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct NullLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for NullLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for NullLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_nullLiteral(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_nullLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NullLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nullLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nullLiteral }
}
antlr_rust::tid!{NullLiteralContextExt<'a>}

impl<'input> NullLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NullLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NullLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NullLiteralContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<NullLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token NULL_LITERAL
/// Returns `None` if there is no child corresponding to token NULL_LITERAL
fn NULL_LITERAL(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(NULL_LITERAL, 0)
}

}

impl<'input> NullLiteralContextAttrs<'input> for NullLiteralContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn nullLiteral(&mut self,)
	-> Result<Rc<NullLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NullLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 58, RULE_nullLiteral);
        let mut _localctx: Rc<NullLiteralContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(783);
			recog.base.match_token(NULL_LITERAL,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- booleanLiteral ----------------
pub type BooleanLiteralContextAll<'input> = BooleanLiteralContext<'input>;


pub type BooleanLiteralContext<'input> = BaseParserRuleContext<'input,BooleanLiteralContextExt<'input>>;

#[derive(Clone)]
pub struct BooleanLiteralContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for BooleanLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for BooleanLiteralContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_booleanLiteral(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_booleanLiteral(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for BooleanLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_booleanLiteral }
	//fn type_rule_index() -> usize where Self: Sized { RULE_booleanLiteral }
}
antlr_rust::tid!{BooleanLiteralContextExt<'a>}

impl<'input> BooleanLiteralContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BooleanLiteralContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BooleanLiteralContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BooleanLiteralContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<BooleanLiteralContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token BOOL_LITERAL
/// Returns `None` if there is no child corresponding to token BOOL_LITERAL
fn BOOL_LITERAL(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(BOOL_LITERAL, 0)
}

}

impl<'input> BooleanLiteralContextAttrs<'input> for BooleanLiteralContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn booleanLiteral(&mut self,)
	-> Result<Rc<BooleanLiteralContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BooleanLiteralContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 60, RULE_booleanLiteral);
        let mut _localctx: Rc<BooleanLiteralContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(785);
			recog.base.match_token(BOOL_LITERAL,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- assignableValue ----------------
pub type AssignableValueContextAll<'input> = AssignableValueContext<'input>;


pub type AssignableValueContext<'input> = BaseParserRuleContext<'input,AssignableValueContextExt<'input>>;

#[derive(Clone)]
pub struct AssignableValueContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AssignableValueContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AssignableValueContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_assignableValue(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_assignableValue(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AssignableValueContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_assignableValue }
	//fn type_rule_index() -> usize where Self: Sized { RULE_assignableValue }
}
antlr_rust::tid!{AssignableValueContextExt<'a>}

impl<'input> AssignableValueContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AssignableValueContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AssignableValueContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AssignableValueContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AssignableValueContextExt<'input>>{

fn anyType(&self) -> Option<Rc<AnyTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn nullLiteral(&self) -> Option<Rc<NullLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn booleanLiteral(&self) -> Option<Rc<BooleanLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AssignableValueContextAttrs<'input> for AssignableValueContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn assignableValue(&mut self,)
	-> Result<Rc<AssignableValueContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AssignableValueContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 62, RULE_assignableValue);
        let mut _localctx: Rc<AssignableValueContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(792);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 QUALIFIED_TYPE_NAME | VOID_TYPE | BOOLEAN_TYPE | BYTE_TYPE | SHORT_TYPE |
			 CHAR_TYPE | INT_TYPE | LONG_TYPE | FLOAT_TYPE | DOUBLE_TYPE | LBRACK 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule anyType*/
					recog.base.set_state(787);
					recog.anyType()?;

					}
				}

			 STRING_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule stringLiteral*/
					recog.base.set_state(788);
					recog.stringLiteral()?;

					}
				}

			 SUB | DECIMAL_LITERAL | HEX_LITERAL | OCT_LITERAL | BINARY_LITERAL |
			 FLOAT_LITERAL | HEX_FLOAT_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule numericLiteral*/
					recog.base.set_state(789);
					recog.numericLiteral()?;

					}
				}

			 NULL_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule nullLiteral*/
					recog.base.set_state(790);
					recog.nullLiteral()?;

					}
				}

			 BOOL_LITERAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule booleanLiteral*/
					recog.base.set_state(791);
					recog.booleanLiteral()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classModifier ----------------
pub type ClassModifierContextAll<'input> = ClassModifierContext<'input>;


pub type ClassModifierContext<'input> = BaseParserRuleContext<'input,ClassModifierContextExt<'input>>;

#[derive(Clone)]
pub struct ClassModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ClassModifierContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ClassModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classModifier(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_classModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classModifier }
}
antlr_rust::tid!{ClassModifierContextExt<'a>}

impl<'input> ClassModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassModifierContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ClassModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVATE
/// Returns `None` if there is no child corresponding to token PRIVATE
fn PRIVATE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(PRIVATE, 0)
}
/// Retrieves first TerminalNode corresponding to token PROTECTED
/// Returns `None` if there is no child corresponding to token PROTECTED
fn PROTECTED(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(PROTECTED, 0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}
/// Retrieves first TerminalNode corresponding to token ANNOTATION
/// Returns `None` if there is no child corresponding to token ANNOTATION
fn ANNOTATION(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(ANNOTATION, 0)
}
/// Retrieves first TerminalNode corresponding to token SYNTHETIC
/// Returns `None` if there is no child corresponding to token SYNTHETIC
fn SYNTHETIC(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(SYNTHETIC, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
/// Retrieves first TerminalNode corresponding to token ABSTRACT
/// Returns `None` if there is no child corresponding to token ABSTRACT
fn ABSTRACT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(ABSTRACT, 0)
}
/// Retrieves first TerminalNode corresponding to token ENUM
/// Returns `None` if there is no child corresponding to token ENUM
fn ENUM(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(ENUM, 0)
}
/// Retrieves first TerminalNode corresponding to token INTERFACE
/// Returns `None` if there is no child corresponding to token INTERFACE
fn INTERFACE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(INTERFACE, 0)
}

}

impl<'input> ClassModifierContextAttrs<'input> for ClassModifierContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classModifier(&mut self,)
	-> Result<Rc<ClassModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 64, RULE_classModifier);
        let mut _localctx: Rc<ClassModifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(794);
			_la = recog.base.input.la(1);
			if { !(((((_la - 52)) & !0x3f) == 0 && ((1usize << (_la - 52)) & ((1usize << (PUBLIC - 52)) | (1usize << (PRIVATE - 52)) | (1usize << (PROTECTED - 52)) | (1usize << (FINAL - 52)) | (1usize << (ANNOTATION - 52)) | (1usize << (STATIC - 52)) | (1usize << (SYNTHETIC - 52)) | (1usize << (ABSTRACT - 52)) | (1usize << (ENUM - 52)) | (1usize << (INTERFACE - 52)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodModifier ----------------
pub type MethodModifierContextAll<'input> = MethodModifierContext<'input>;


pub type MethodModifierContext<'input> = BaseParserRuleContext<'input,MethodModifierContextExt<'input>>;

#[derive(Clone)]
pub struct MethodModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MethodModifierContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MethodModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodModifier(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_methodModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodModifier }
}
antlr_rust::tid!{MethodModifierContextExt<'a>}

impl<'input> MethodModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodModifierContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MethodModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVATE
/// Returns `None` if there is no child corresponding to token PRIVATE
fn PRIVATE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(PRIVATE, 0)
}
/// Retrieves first TerminalNode corresponding to token PROTECTED
/// Returns `None` if there is no child corresponding to token PROTECTED
fn PROTECTED(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(PROTECTED, 0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}
/// Retrieves first TerminalNode corresponding to token SYNTHETIC
/// Returns `None` if there is no child corresponding to token SYNTHETIC
fn SYNTHETIC(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(SYNTHETIC, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
/// Retrieves first TerminalNode corresponding to token ABSTRACT
/// Returns `None` if there is no child corresponding to token ABSTRACT
fn ABSTRACT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(ABSTRACT, 0)
}
/// Retrieves first TerminalNode corresponding to token CONSTRUCTOR
/// Returns `None` if there is no child corresponding to token CONSTRUCTOR
fn CONSTRUCTOR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(CONSTRUCTOR, 0)
}
/// Retrieves first TerminalNode corresponding to token BRIDGE
/// Returns `None` if there is no child corresponding to token BRIDGE
fn BRIDGE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(BRIDGE, 0)
}
/// Retrieves first TerminalNode corresponding to token DECLARED_SYNCHRONIZED
/// Returns `None` if there is no child corresponding to token DECLARED_SYNCHRONIZED
fn DECLARED_SYNCHRONIZED(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(DECLARED_SYNCHRONIZED, 0)
}
/// Retrieves first TerminalNode corresponding to token STRICTFP
/// Returns `None` if there is no child corresponding to token STRICTFP
fn STRICTFP(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(STRICTFP, 0)
}
/// Retrieves first TerminalNode corresponding to token VARARGS
/// Returns `None` if there is no child corresponding to token VARARGS
fn VARARGS(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(VARARGS, 0)
}
/// Retrieves first TerminalNode corresponding to token NATIVE
/// Returns `None` if there is no child corresponding to token NATIVE
fn NATIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(NATIVE, 0)
}

}

impl<'input> MethodModifierContextAttrs<'input> for MethodModifierContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodModifier(&mut self,)
	-> Result<Rc<MethodModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 66, RULE_methodModifier);
        let mut _localctx: Rc<MethodModifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(796);
			_la = recog.base.input.la(1);
			if { !(((((_la - 52)) & !0x3f) == 0 && ((1usize << (_la - 52)) & ((1usize << (PUBLIC - 52)) | (1usize << (PRIVATE - 52)) | (1usize << (PROTECTED - 52)) | (1usize << (FINAL - 52)) | (1usize << (STATIC - 52)) | (1usize << (SYNTHETIC - 52)) | (1usize << (CONSTRUCTOR - 52)) | (1usize << (ABSTRACT - 52)) | (1usize << (BRIDGE - 52)) | (1usize << (DECLARED_SYNCHRONIZED - 52)) | (1usize << (STRICTFP - 52)) | (1usize << (VARARGS - 52)) | (1usize << (NATIVE - 52)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fieldModifier ----------------
pub type FieldModifierContextAll<'input> = FieldModifierContext<'input>;


pub type FieldModifierContext<'input> = BaseParserRuleContext<'input,FieldModifierContextExt<'input>>;

#[derive(Clone)]
pub struct FieldModifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for FieldModifierContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for FieldModifierContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_fieldModifier(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_fieldModifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FieldModifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fieldModifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fieldModifier }
}
antlr_rust::tid!{FieldModifierContextExt<'a>}

impl<'input> FieldModifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FieldModifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FieldModifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FieldModifierContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<FieldModifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token PUBLIC
/// Returns `None` if there is no child corresponding to token PUBLIC
fn PUBLIC(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(PUBLIC, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVATE
/// Returns `None` if there is no child corresponding to token PRIVATE
fn PRIVATE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(PRIVATE, 0)
}
/// Retrieves first TerminalNode corresponding to token PROTECTED
/// Returns `None` if there is no child corresponding to token PROTECTED
fn PROTECTED(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(PROTECTED, 0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}
/// Retrieves first TerminalNode corresponding to token SYNTHETIC
/// Returns `None` if there is no child corresponding to token SYNTHETIC
fn SYNTHETIC(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(SYNTHETIC, 0)
}
/// Retrieves first TerminalNode corresponding to token STATIC
/// Returns `None` if there is no child corresponding to token STATIC
fn STATIC(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(STATIC, 0)
}
/// Retrieves first TerminalNode corresponding to token TRANSIENT
/// Returns `None` if there is no child corresponding to token TRANSIENT
fn TRANSIENT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(TRANSIENT, 0)
}
/// Retrieves first TerminalNode corresponding to token VOLATILE
/// Returns `None` if there is no child corresponding to token VOLATILE
fn VOLATILE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(VOLATILE, 0)
}
/// Retrieves first TerminalNode corresponding to token ENUM
/// Returns `None` if there is no child corresponding to token ENUM
fn ENUM(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(ENUM, 0)
}

}

impl<'input> FieldModifierContextAttrs<'input> for FieldModifierContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fieldModifier(&mut self,)
	-> Result<Rc<FieldModifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FieldModifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 68, RULE_fieldModifier);
        let mut _localctx: Rc<FieldModifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(798);
			_la = recog.base.input.la(1);
			if { !(((((_la - 52)) & !0x3f) == 0 && ((1usize << (_la - 52)) & ((1usize << (PUBLIC - 52)) | (1usize << (PRIVATE - 52)) | (1usize << (PROTECTED - 52)) | (1usize << (FINAL - 52)) | (1usize << (STATIC - 52)) | (1usize << (SYNTHETIC - 52)) | (1usize << (ENUM - 52)) | (1usize << (TRANSIENT - 52)) | (1usize << (VOLATILE - 52)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- labelName ----------------
pub type LabelNameContextAll<'input> = LabelNameContext<'input>;


pub type LabelNameContext<'input> = BaseParserRuleContext<'input,LabelNameContextExt<'input>>;

#[derive(Clone)]
pub struct LabelNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for LabelNameContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for LabelNameContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_labelName(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_labelName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LabelNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_labelName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_labelName }
}
antlr_rust::tid!{LabelNameContextExt<'a>}

impl<'input> LabelNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LabelNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LabelNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LabelNameContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<LabelNameContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LabelNameContextAttrs<'input> for LabelNameContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn labelName(&mut self,)
	-> Result<Rc<LabelNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LabelNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 70, RULE_labelName);
        let mut _localctx: Rc<LabelNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(800);
			recog.identifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- label ----------------
pub type LabelContextAll<'input> = LabelContext<'input>;


pub type LabelContext<'input> = BaseParserRuleContext<'input,LabelContextExt<'input>>;

#[derive(Clone)]
pub struct LabelContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for LabelContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for LabelContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_label(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_label(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LabelContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_label }
	//fn type_rule_index() -> usize where Self: Sized { RULE_label }
}
antlr_rust::tid!{LabelContextExt<'a>}

impl<'input> LabelContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LabelContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LabelContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LabelContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<LabelContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn labelName(&self) -> Option<Rc<LabelNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LabelContextAttrs<'input> for LabelContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn label(&mut self,)
	-> Result<Rc<LabelContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LabelContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 72, RULE_label);
        let mut _localctx: Rc<LabelContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(802);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			/*InvokeRule labelName*/
			recog.base.set_state(803);
			recog.labelName()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- leftRegister ----------------
pub type LeftRegisterContextAll<'input> = LeftRegisterContext<'input>;


pub type LeftRegisterContext<'input> = BaseParserRuleContext<'input,LeftRegisterContextExt<'input>>;

#[derive(Clone)]
pub struct LeftRegisterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for LeftRegisterContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for LeftRegisterContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_leftRegister(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_leftRegister(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LeftRegisterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_leftRegister }
	//fn type_rule_index() -> usize where Self: Sized { RULE_leftRegister }
}
antlr_rust::tid!{LeftRegisterContextExt<'a>}

impl<'input> LeftRegisterContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LeftRegisterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LeftRegisterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LeftRegisterContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<LeftRegisterContextExt<'input>>{

fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LeftRegisterContextAttrs<'input> for LeftRegisterContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn leftRegister(&mut self,)
	-> Result<Rc<LeftRegisterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LeftRegisterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 74, RULE_leftRegister);
        let mut _localctx: Rc<LeftRegisterContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule registerIdentifier*/
			recog.base.set_state(805);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- rightRegister ----------------
pub type RightRegisterContextAll<'input> = RightRegisterContext<'input>;


pub type RightRegisterContext<'input> = BaseParserRuleContext<'input,RightRegisterContextExt<'input>>;

#[derive(Clone)]
pub struct RightRegisterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for RightRegisterContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for RightRegisterContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_rightRegister(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_rightRegister(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RightRegisterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_rightRegister }
	//fn type_rule_index() -> usize where Self: Sized { RULE_rightRegister }
}
antlr_rust::tid!{RightRegisterContextExt<'a>}

impl<'input> RightRegisterContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RightRegisterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RightRegisterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RightRegisterContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<RightRegisterContextExt<'input>>{

fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RightRegisterContextAttrs<'input> for RightRegisterContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn rightRegister(&mut self,)
	-> Result<Rc<RightRegisterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RightRegisterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 76, RULE_rightRegister);
        let mut _localctx: Rc<RightRegisterContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule registerIdentifier*/
			recog.base.set_state(807);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- registerListRegisters ----------------
pub type RegisterListRegistersContextAll<'input> = RegisterListRegistersContext<'input>;


pub type RegisterListRegistersContext<'input> = BaseParserRuleContext<'input,RegisterListRegistersContextExt<'input>>;

#[derive(Clone)]
pub struct RegisterListRegistersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for RegisterListRegistersContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for RegisterListRegistersContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_registerListRegisters(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_registerListRegisters(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RegisterListRegistersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_registerListRegisters }
	//fn type_rule_index() -> usize where Self: Sized { RULE_registerListRegisters }
}
antlr_rust::tid!{RegisterListRegistersContextExt<'a>}

impl<'input> RegisterListRegistersContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RegisterListRegistersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RegisterListRegistersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RegisterListRegistersContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<RegisterListRegistersContextExt<'input>>{

fn registerIdentifier_all(&self) ->  Vec<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn registerIdentifier(&self, i: usize) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> RegisterListRegistersContextAttrs<'input> for RegisterListRegistersContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn registerListRegisters(&mut self,)
	-> Result<Rc<RegisterListRegistersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RegisterListRegistersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 78, RULE_registerListRegisters);
        let mut _localctx: Rc<RegisterListRegistersContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule registerIdentifier*/
			recog.base.set_state(809);
			recog.registerIdentifier()?;

			recog.base.set_state(814);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(810);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule registerIdentifier*/
				recog.base.set_state(811);
				recog.registerIdentifier()?;

				}
				}
				recog.base.set_state(816);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- registerRange ----------------
pub type RegisterRangeContextAll<'input> = RegisterRangeContext<'input>;


pub type RegisterRangeContext<'input> = BaseParserRuleContext<'input,RegisterRangeContextExt<'input>>;

#[derive(Clone)]
pub struct RegisterRangeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for RegisterRangeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for RegisterRangeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_registerRange(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_registerRange(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RegisterRangeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_registerRange }
	//fn type_rule_index() -> usize where Self: Sized { RULE_registerRange }
}
antlr_rust::tid!{RegisterRangeContextExt<'a>}

impl<'input> RegisterRangeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RegisterRangeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RegisterRangeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RegisterRangeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<RegisterRangeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}

}

impl<'input> RegisterRangeContextAttrs<'input> for RegisterRangeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn registerRange(&mut self,)
	-> Result<Rc<RegisterRangeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RegisterRangeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 80, RULE_registerRange);
        let mut _localctx: Rc<RegisterRangeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(817);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(818);
			recog.leftRegister()?;

			recog.base.set_state(819);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			recog.base.set_state(820);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(821);
			recog.rightRegister()?;

			recog.base.set_state(822);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- registerList ----------------
pub type RegisterListContextAll<'input> = RegisterListContext<'input>;


pub type RegisterListContext<'input> = BaseParserRuleContext<'input,RegisterListContextExt<'input>>;

#[derive(Clone)]
pub struct RegisterListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for RegisterListContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for RegisterListContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_registerList(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_registerList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RegisterListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_registerList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_registerList }
}
antlr_rust::tid!{RegisterListContextExt<'a>}

impl<'input> RegisterListContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RegisterListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RegisterListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RegisterListContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<RegisterListContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn registerListRegisters(&self) -> Option<Rc<RegisterListRegistersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RegisterListContextAttrs<'input> for RegisterListContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn registerList(&mut self,)
	-> Result<Rc<RegisterListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RegisterListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 82, RULE_registerList);
        let mut _localctx: Rc<RegisterListContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(830);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(11,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(824);
					recog.base.match_token(LBRACE,&mut recog.err_handler)?;

					recog.base.set_state(825);
					recog.base.match_token(RBRACE,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(826);
					recog.base.match_token(LBRACE,&mut recog.err_handler)?;

					/*InvokeRule registerListRegisters*/
					recog.base.set_state(827);
					recog.registerListRegisters()?;

					recog.base.set_state(828);
					recog.base.match_token(RBRACE,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- gotoInstruction ----------------
pub type GotoInstructionContextAll<'input> = GotoInstructionContext<'input>;


pub type GotoInstructionContext<'input> = BaseParserRuleContext<'input,GotoInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct GotoInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for GotoInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for GotoInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_gotoInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_gotoInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for GotoInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_gotoInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_gotoInstruction }
}
antlr_rust::tid!{GotoInstructionContextExt<'a>}

impl<'input> GotoInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<GotoInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,GotoInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait GotoInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<GotoInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_GOTO
/// Returns `None` if there is no child corresponding to token OP_GOTO
fn OP_GOTO(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_GOTO, 0)
}
fn label(&self) -> Option<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> GotoInstructionContextAttrs<'input> for GotoInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn gotoInstruction(&mut self,)
	-> Result<Rc<GotoInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = GotoInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 84, RULE_gotoInstruction);
        let mut _localctx: Rc<GotoInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(832);
			recog.base.match_token(OP_GOTO,&mut recog.err_handler)?;

			/*InvokeRule label*/
			recog.base.set_state(833);
			recog.label()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- goto16Instruction ----------------
pub type Goto16InstructionContextAll<'input> = Goto16InstructionContext<'input>;


pub type Goto16InstructionContext<'input> = BaseParserRuleContext<'input,Goto16InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct Goto16InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for Goto16InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for Goto16InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_goto16Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_goto16Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for Goto16InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_goto16Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_goto16Instruction }
}
antlr_rust::tid!{Goto16InstructionContextExt<'a>}

impl<'input> Goto16InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Goto16InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Goto16InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Goto16InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<Goto16InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_GOTO_16
/// Returns `None` if there is no child corresponding to token OP_GOTO_16
fn OP_GOTO_16(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_GOTO_16, 0)
}
fn label(&self) -> Option<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Goto16InstructionContextAttrs<'input> for Goto16InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn goto16Instruction(&mut self,)
	-> Result<Rc<Goto16InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Goto16InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 86, RULE_goto16Instruction);
        let mut _localctx: Rc<Goto16InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(835);
			recog.base.match_token(OP_GOTO_16,&mut recog.err_handler)?;

			/*InvokeRule label*/
			recog.base.set_state(836);
			recog.label()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- goto32Instruction ----------------
pub type Goto32InstructionContextAll<'input> = Goto32InstructionContext<'input>;


pub type Goto32InstructionContext<'input> = BaseParserRuleContext<'input,Goto32InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct Goto32InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for Goto32InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for Goto32InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_goto32Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_goto32Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for Goto32InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_goto32Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_goto32Instruction }
}
antlr_rust::tid!{Goto32InstructionContextExt<'a>}

impl<'input> Goto32InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Goto32InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Goto32InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Goto32InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<Goto32InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_GOTO_32
/// Returns `None` if there is no child corresponding to token OP_GOTO_32
fn OP_GOTO_32(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_GOTO_32, 0)
}
fn label(&self) -> Option<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Goto32InstructionContextAttrs<'input> for Goto32InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn goto32Instruction(&mut self,)
	-> Result<Rc<Goto32InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Goto32InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 88, RULE_goto32Instruction);
        let mut _localctx: Rc<Goto32InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(838);
			recog.base.match_token(OP_GOTO_32,&mut recog.err_handler)?;

			/*InvokeRule label*/
			recog.base.set_state(839);
			recog.label()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moveResultInstruction ----------------
pub type MoveResultInstructionContextAll<'input> = MoveResultInstructionContext<'input>;


pub type MoveResultInstructionContext<'input> = BaseParserRuleContext<'input,MoveResultInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MoveResultInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MoveResultInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MoveResultInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_moveResultInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_moveResultInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MoveResultInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moveResultInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moveResultInstruction }
}
antlr_rust::tid!{MoveResultInstructionContextExt<'a>}

impl<'input> MoveResultInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MoveResultInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MoveResultInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MoveResultInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MoveResultInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MOVE_RESULT
/// Returns `None` if there is no child corresponding to token OP_MOVE_RESULT
fn OP_MOVE_RESULT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MOVE_RESULT, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MoveResultInstructionContextAttrs<'input> for MoveResultInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moveResultInstruction(&mut self,)
	-> Result<Rc<MoveResultInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MoveResultInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 90, RULE_moveResultInstruction);
        let mut _localctx: Rc<MoveResultInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(841);
			recog.base.match_token(OP_MOVE_RESULT,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(842);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moveResultWideInstruction ----------------
pub type MoveResultWideInstructionContextAll<'input> = MoveResultWideInstructionContext<'input>;


pub type MoveResultWideInstructionContext<'input> = BaseParserRuleContext<'input,MoveResultWideInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MoveResultWideInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MoveResultWideInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MoveResultWideInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_moveResultWideInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_moveResultWideInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MoveResultWideInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moveResultWideInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moveResultWideInstruction }
}
antlr_rust::tid!{MoveResultWideInstructionContextExt<'a>}

impl<'input> MoveResultWideInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MoveResultWideInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MoveResultWideInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MoveResultWideInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MoveResultWideInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MOVE_RESULT_WIDE
/// Returns `None` if there is no child corresponding to token OP_MOVE_RESULT_WIDE
fn OP_MOVE_RESULT_WIDE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MOVE_RESULT_WIDE, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MoveResultWideInstructionContextAttrs<'input> for MoveResultWideInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moveResultWideInstruction(&mut self,)
	-> Result<Rc<MoveResultWideInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MoveResultWideInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 92, RULE_moveResultWideInstruction);
        let mut _localctx: Rc<MoveResultWideInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(844);
			recog.base.match_token(OP_MOVE_RESULT_WIDE,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(845);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moveResultObjectInstruction ----------------
pub type MoveResultObjectInstructionContextAll<'input> = MoveResultObjectInstructionContext<'input>;


pub type MoveResultObjectInstructionContext<'input> = BaseParserRuleContext<'input,MoveResultObjectInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MoveResultObjectInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MoveResultObjectInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MoveResultObjectInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_moveResultObjectInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_moveResultObjectInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MoveResultObjectInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moveResultObjectInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moveResultObjectInstruction }
}
antlr_rust::tid!{MoveResultObjectInstructionContextExt<'a>}

impl<'input> MoveResultObjectInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MoveResultObjectInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MoveResultObjectInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MoveResultObjectInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MoveResultObjectInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MOVE_RESULT_OBJECT
/// Returns `None` if there is no child corresponding to token OP_MOVE_RESULT_OBJECT
fn OP_MOVE_RESULT_OBJECT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MOVE_RESULT_OBJECT, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MoveResultObjectInstructionContextAttrs<'input> for MoveResultObjectInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moveResultObjectInstruction(&mut self,)
	-> Result<Rc<MoveResultObjectInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MoveResultObjectInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 94, RULE_moveResultObjectInstruction);
        let mut _localctx: Rc<MoveResultObjectInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(847);
			recog.base.match_token(OP_MOVE_RESULT_OBJECT,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(848);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moveExceptionInstruction ----------------
pub type MoveExceptionInstructionContextAll<'input> = MoveExceptionInstructionContext<'input>;


pub type MoveExceptionInstructionContext<'input> = BaseParserRuleContext<'input,MoveExceptionInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MoveExceptionInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MoveExceptionInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MoveExceptionInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_moveExceptionInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_moveExceptionInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MoveExceptionInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moveExceptionInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moveExceptionInstruction }
}
antlr_rust::tid!{MoveExceptionInstructionContextExt<'a>}

impl<'input> MoveExceptionInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MoveExceptionInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MoveExceptionInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MoveExceptionInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MoveExceptionInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MOVE_EXCEPTION
/// Returns `None` if there is no child corresponding to token OP_MOVE_EXCEPTION
fn OP_MOVE_EXCEPTION(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MOVE_EXCEPTION, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MoveExceptionInstructionContextAttrs<'input> for MoveExceptionInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moveExceptionInstruction(&mut self,)
	-> Result<Rc<MoveExceptionInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MoveExceptionInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 96, RULE_moveExceptionInstruction);
        let mut _localctx: Rc<MoveExceptionInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(850);
			recog.base.match_token(OP_MOVE_EXCEPTION,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(851);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- returnInstruction ----------------
pub type ReturnInstructionContextAll<'input> = ReturnInstructionContext<'input>;


pub type ReturnInstructionContext<'input> = BaseParserRuleContext<'input,ReturnInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ReturnInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ReturnInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ReturnInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_returnInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_returnInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ReturnInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_returnInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_returnInstruction }
}
antlr_rust::tid!{ReturnInstructionContextExt<'a>}

impl<'input> ReturnInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReturnInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReturnInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReturnInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ReturnInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_RETURN
/// Returns `None` if there is no child corresponding to token OP_RETURN
fn OP_RETURN(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_RETURN, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ReturnInstructionContextAttrs<'input> for ReturnInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn returnInstruction(&mut self,)
	-> Result<Rc<ReturnInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReturnInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 98, RULE_returnInstruction);
        let mut _localctx: Rc<ReturnInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(853);
			recog.base.match_token(OP_RETURN,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(854);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- returnWideInstruction ----------------
pub type ReturnWideInstructionContextAll<'input> = ReturnWideInstructionContext<'input>;


pub type ReturnWideInstructionContext<'input> = BaseParserRuleContext<'input,ReturnWideInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ReturnWideInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ReturnWideInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ReturnWideInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_returnWideInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_returnWideInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ReturnWideInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_returnWideInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_returnWideInstruction }
}
antlr_rust::tid!{ReturnWideInstructionContextExt<'a>}

impl<'input> ReturnWideInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReturnWideInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReturnWideInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReturnWideInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ReturnWideInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_RETURN_WIDE
/// Returns `None` if there is no child corresponding to token OP_RETURN_WIDE
fn OP_RETURN_WIDE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_RETURN_WIDE, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ReturnWideInstructionContextAttrs<'input> for ReturnWideInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn returnWideInstruction(&mut self,)
	-> Result<Rc<ReturnWideInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReturnWideInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 100, RULE_returnWideInstruction);
        let mut _localctx: Rc<ReturnWideInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(856);
			recog.base.match_token(OP_RETURN_WIDE,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(857);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- returnObjectInstruction ----------------
pub type ReturnObjectInstructionContextAll<'input> = ReturnObjectInstructionContext<'input>;


pub type ReturnObjectInstructionContext<'input> = BaseParserRuleContext<'input,ReturnObjectInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ReturnObjectInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ReturnObjectInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ReturnObjectInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_returnObjectInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_returnObjectInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ReturnObjectInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_returnObjectInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_returnObjectInstruction }
}
antlr_rust::tid!{ReturnObjectInstructionContextExt<'a>}

impl<'input> ReturnObjectInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReturnObjectInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReturnObjectInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReturnObjectInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ReturnObjectInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_RETURN_OBJECT
/// Returns `None` if there is no child corresponding to token OP_RETURN_OBJECT
fn OP_RETURN_OBJECT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_RETURN_OBJECT, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ReturnObjectInstructionContextAttrs<'input> for ReturnObjectInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn returnObjectInstruction(&mut self,)
	-> Result<Rc<ReturnObjectInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReturnObjectInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 102, RULE_returnObjectInstruction);
        let mut _localctx: Rc<ReturnObjectInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(859);
			recog.base.match_token(OP_RETURN_OBJECT,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(860);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- monitorEnterInstruction ----------------
pub type MonitorEnterInstructionContextAll<'input> = MonitorEnterInstructionContext<'input>;


pub type MonitorEnterInstructionContext<'input> = BaseParserRuleContext<'input,MonitorEnterInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MonitorEnterInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MonitorEnterInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MonitorEnterInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_monitorEnterInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_monitorEnterInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MonitorEnterInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_monitorEnterInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_monitorEnterInstruction }
}
antlr_rust::tid!{MonitorEnterInstructionContextExt<'a>}

impl<'input> MonitorEnterInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MonitorEnterInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MonitorEnterInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MonitorEnterInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MonitorEnterInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MONITOR_ENTER
/// Returns `None` if there is no child corresponding to token OP_MONITOR_ENTER
fn OP_MONITOR_ENTER(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MONITOR_ENTER, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MonitorEnterInstructionContextAttrs<'input> for MonitorEnterInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn monitorEnterInstruction(&mut self,)
	-> Result<Rc<MonitorEnterInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MonitorEnterInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 104, RULE_monitorEnterInstruction);
        let mut _localctx: Rc<MonitorEnterInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(862);
			recog.base.match_token(OP_MONITOR_ENTER,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(863);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- monitorExitInstruction ----------------
pub type MonitorExitInstructionContextAll<'input> = MonitorExitInstructionContext<'input>;


pub type MonitorExitInstructionContext<'input> = BaseParserRuleContext<'input,MonitorExitInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MonitorExitInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MonitorExitInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MonitorExitInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_monitorExitInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_monitorExitInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MonitorExitInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_monitorExitInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_monitorExitInstruction }
}
antlr_rust::tid!{MonitorExitInstructionContextExt<'a>}

impl<'input> MonitorExitInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MonitorExitInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MonitorExitInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MonitorExitInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MonitorExitInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MONITOR_EXIT
/// Returns `None` if there is no child corresponding to token OP_MONITOR_EXIT
fn OP_MONITOR_EXIT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MONITOR_EXIT, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MonitorExitInstructionContextAttrs<'input> for MonitorExitInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn monitorExitInstruction(&mut self,)
	-> Result<Rc<MonitorExitInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MonitorExitInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 106, RULE_monitorExitInstruction);
        let mut _localctx: Rc<MonitorExitInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(865);
			recog.base.match_token(OP_MONITOR_EXIT,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(866);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- throwInstruction ----------------
pub type ThrowInstructionContextAll<'input> = ThrowInstructionContext<'input>;


pub type ThrowInstructionContext<'input> = BaseParserRuleContext<'input,ThrowInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ThrowInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ThrowInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ThrowInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_throwInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_throwInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ThrowInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_throwInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_throwInstruction }
}
antlr_rust::tid!{ThrowInstructionContextExt<'a>}

impl<'input> ThrowInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ThrowInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ThrowInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ThrowInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ThrowInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_THROW
/// Returns `None` if there is no child corresponding to token OP_THROW
fn OP_THROW(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_THROW, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ThrowInstructionContextAttrs<'input> for ThrowInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn throwInstruction(&mut self,)
	-> Result<Rc<ThrowInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ThrowInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 108, RULE_throwInstruction);
        let mut _localctx: Rc<ThrowInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(868);
			recog.base.match_token(OP_THROW,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(869);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- returnVoidInstruction ----------------
pub type ReturnVoidInstructionContextAll<'input> = ReturnVoidInstructionContext<'input>;


pub type ReturnVoidInstructionContext<'input> = BaseParserRuleContext<'input,ReturnVoidInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ReturnVoidInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ReturnVoidInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ReturnVoidInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_returnVoidInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_returnVoidInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ReturnVoidInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_returnVoidInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_returnVoidInstruction }
}
antlr_rust::tid!{ReturnVoidInstructionContextExt<'a>}

impl<'input> ReturnVoidInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReturnVoidInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReturnVoidInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReturnVoidInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ReturnVoidInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_RETURN_VOID
/// Returns `None` if there is no child corresponding to token OP_RETURN_VOID
fn OP_RETURN_VOID(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_RETURN_VOID, 0)
}

}

impl<'input> ReturnVoidInstructionContextAttrs<'input> for ReturnVoidInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn returnVoidInstruction(&mut self,)
	-> Result<Rc<ReturnVoidInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReturnVoidInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 110, RULE_returnVoidInstruction);
        let mut _localctx: Rc<ReturnVoidInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(871);
			recog.base.match_token(OP_RETURN_VOID,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- nopInstruction ----------------
pub type NopInstructionContextAll<'input> = NopInstructionContext<'input>;


pub type NopInstructionContext<'input> = BaseParserRuleContext<'input,NopInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct NopInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for NopInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for NopInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_nopInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_nopInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NopInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nopInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nopInstruction }
}
antlr_rust::tid!{NopInstructionContextExt<'a>}

impl<'input> NopInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NopInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NopInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NopInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<NopInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_NOP
/// Returns `None` if there is no child corresponding to token OP_NOP
fn OP_NOP(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_NOP, 0)
}

}

impl<'input> NopInstructionContextAttrs<'input> for NopInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn nopInstruction(&mut self,)
	-> Result<Rc<NopInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NopInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 112, RULE_nopInstruction);
        let mut _localctx: Rc<NopInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(873);
			recog.base.match_token(OP_NOP,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moveInstruction ----------------
pub type MoveInstructionContextAll<'input> = MoveInstructionContext<'input>;


pub type MoveInstructionContext<'input> = BaseParserRuleContext<'input,MoveInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MoveInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MoveInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MoveInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_moveInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_moveInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MoveInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moveInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moveInstruction }
}
antlr_rust::tid!{MoveInstructionContextExt<'a>}

impl<'input> MoveInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MoveInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MoveInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MoveInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MoveInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MOVE
/// Returns `None` if there is no child corresponding to token OP_MOVE
fn OP_MOVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MOVE, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MoveInstructionContextAttrs<'input> for MoveInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moveInstruction(&mut self,)
	-> Result<Rc<MoveInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MoveInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 114, RULE_moveInstruction);
        let mut _localctx: Rc<MoveInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(875);
			recog.base.match_token(OP_MOVE,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(876);
			recog.leftRegister()?;

			recog.base.set_state(877);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(878);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moveFrom16Instruction ----------------
pub type MoveFrom16InstructionContextAll<'input> = MoveFrom16InstructionContext<'input>;


pub type MoveFrom16InstructionContext<'input> = BaseParserRuleContext<'input,MoveFrom16InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MoveFrom16InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MoveFrom16InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MoveFrom16InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_moveFrom16Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_moveFrom16Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MoveFrom16InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moveFrom16Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moveFrom16Instruction }
}
antlr_rust::tid!{MoveFrom16InstructionContextExt<'a>}

impl<'input> MoveFrom16InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MoveFrom16InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MoveFrom16InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MoveFrom16InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MoveFrom16InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MOVE_FROM16
/// Returns `None` if there is no child corresponding to token OP_MOVE_FROM16
fn OP_MOVE_FROM16(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MOVE_FROM16, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MoveFrom16InstructionContextAttrs<'input> for MoveFrom16InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moveFrom16Instruction(&mut self,)
	-> Result<Rc<MoveFrom16InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MoveFrom16InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 116, RULE_moveFrom16Instruction);
        let mut _localctx: Rc<MoveFrom16InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(880);
			recog.base.match_token(OP_MOVE_FROM16,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(881);
			recog.leftRegister()?;

			recog.base.set_state(882);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(883);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- move16Instruction ----------------
pub type Move16InstructionContextAll<'input> = Move16InstructionContext<'input>;


pub type Move16InstructionContext<'input> = BaseParserRuleContext<'input,Move16InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct Move16InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for Move16InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for Move16InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_move16Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_move16Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for Move16InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_move16Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_move16Instruction }
}
antlr_rust::tid!{Move16InstructionContextExt<'a>}

impl<'input> Move16InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Move16InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Move16InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Move16InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<Move16InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MOVE_16
/// Returns `None` if there is no child corresponding to token OP_MOVE_16
fn OP_MOVE_16(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MOVE_16, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Move16InstructionContextAttrs<'input> for Move16InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn move16Instruction(&mut self,)
	-> Result<Rc<Move16InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Move16InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 118, RULE_move16Instruction);
        let mut _localctx: Rc<Move16InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(885);
			recog.base.match_token(OP_MOVE_16,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(886);
			recog.leftRegister()?;

			recog.base.set_state(887);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(888);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moveWideInstruction ----------------
pub type MoveWideInstructionContextAll<'input> = MoveWideInstructionContext<'input>;


pub type MoveWideInstructionContext<'input> = BaseParserRuleContext<'input,MoveWideInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MoveWideInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MoveWideInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MoveWideInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_moveWideInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_moveWideInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MoveWideInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moveWideInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moveWideInstruction }
}
antlr_rust::tid!{MoveWideInstructionContextExt<'a>}

impl<'input> MoveWideInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MoveWideInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MoveWideInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MoveWideInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MoveWideInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MOVE_WIDE
/// Returns `None` if there is no child corresponding to token OP_MOVE_WIDE
fn OP_MOVE_WIDE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MOVE_WIDE, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MoveWideInstructionContextAttrs<'input> for MoveWideInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moveWideInstruction(&mut self,)
	-> Result<Rc<MoveWideInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MoveWideInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 120, RULE_moveWideInstruction);
        let mut _localctx: Rc<MoveWideInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(890);
			recog.base.match_token(OP_MOVE_WIDE,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(891);
			recog.leftRegister()?;

			recog.base.set_state(892);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(893);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moveWideFrom16Instruction ----------------
pub type MoveWideFrom16InstructionContextAll<'input> = MoveWideFrom16InstructionContext<'input>;


pub type MoveWideFrom16InstructionContext<'input> = BaseParserRuleContext<'input,MoveWideFrom16InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MoveWideFrom16InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MoveWideFrom16InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MoveWideFrom16InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_moveWideFrom16Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_moveWideFrom16Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MoveWideFrom16InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moveWideFrom16Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moveWideFrom16Instruction }
}
antlr_rust::tid!{MoveWideFrom16InstructionContextExt<'a>}

impl<'input> MoveWideFrom16InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MoveWideFrom16InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MoveWideFrom16InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MoveWideFrom16InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MoveWideFrom16InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MOVE_WIDE_FROM16
/// Returns `None` if there is no child corresponding to token OP_MOVE_WIDE_FROM16
fn OP_MOVE_WIDE_FROM16(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MOVE_WIDE_FROM16, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MoveWideFrom16InstructionContextAttrs<'input> for MoveWideFrom16InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moveWideFrom16Instruction(&mut self,)
	-> Result<Rc<MoveWideFrom16InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MoveWideFrom16InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 122, RULE_moveWideFrom16Instruction);
        let mut _localctx: Rc<MoveWideFrom16InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(895);
			recog.base.match_token(OP_MOVE_WIDE_FROM16,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(896);
			recog.leftRegister()?;

			recog.base.set_state(897);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(898);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moveWide16Instruction ----------------
pub type MoveWide16InstructionContextAll<'input> = MoveWide16InstructionContext<'input>;


pub type MoveWide16InstructionContext<'input> = BaseParserRuleContext<'input,MoveWide16InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MoveWide16InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MoveWide16InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MoveWide16InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_moveWide16Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_moveWide16Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MoveWide16InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moveWide16Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moveWide16Instruction }
}
antlr_rust::tid!{MoveWide16InstructionContextExt<'a>}

impl<'input> MoveWide16InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MoveWide16InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MoveWide16InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MoveWide16InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MoveWide16InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MOVE_WIDE_16
/// Returns `None` if there is no child corresponding to token OP_MOVE_WIDE_16
fn OP_MOVE_WIDE_16(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MOVE_WIDE_16, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MoveWide16InstructionContextAttrs<'input> for MoveWide16InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moveWide16Instruction(&mut self,)
	-> Result<Rc<MoveWide16InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MoveWide16InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 124, RULE_moveWide16Instruction);
        let mut _localctx: Rc<MoveWide16InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(900);
			recog.base.match_token(OP_MOVE_WIDE_16,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(901);
			recog.leftRegister()?;

			recog.base.set_state(902);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(903);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moveObjectInstruction ----------------
pub type MoveObjectInstructionContextAll<'input> = MoveObjectInstructionContext<'input>;


pub type MoveObjectInstructionContext<'input> = BaseParserRuleContext<'input,MoveObjectInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MoveObjectInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MoveObjectInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MoveObjectInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_moveObjectInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_moveObjectInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MoveObjectInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moveObjectInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moveObjectInstruction }
}
antlr_rust::tid!{MoveObjectInstructionContextExt<'a>}

impl<'input> MoveObjectInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MoveObjectInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MoveObjectInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MoveObjectInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MoveObjectInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MOVE_OBJECT
/// Returns `None` if there is no child corresponding to token OP_MOVE_OBJECT
fn OP_MOVE_OBJECT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MOVE_OBJECT, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MoveObjectInstructionContextAttrs<'input> for MoveObjectInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moveObjectInstruction(&mut self,)
	-> Result<Rc<MoveObjectInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MoveObjectInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 126, RULE_moveObjectInstruction);
        let mut _localctx: Rc<MoveObjectInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(905);
			recog.base.match_token(OP_MOVE_OBJECT,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(906);
			recog.leftRegister()?;

			recog.base.set_state(907);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(908);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moveObjectFrom16Instruction ----------------
pub type MoveObjectFrom16InstructionContextAll<'input> = MoveObjectFrom16InstructionContext<'input>;


pub type MoveObjectFrom16InstructionContext<'input> = BaseParserRuleContext<'input,MoveObjectFrom16InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MoveObjectFrom16InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MoveObjectFrom16InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MoveObjectFrom16InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_moveObjectFrom16Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_moveObjectFrom16Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MoveObjectFrom16InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moveObjectFrom16Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moveObjectFrom16Instruction }
}
antlr_rust::tid!{MoveObjectFrom16InstructionContextExt<'a>}

impl<'input> MoveObjectFrom16InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MoveObjectFrom16InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MoveObjectFrom16InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MoveObjectFrom16InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MoveObjectFrom16InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MOVE_OBJECT_FROM16
/// Returns `None` if there is no child corresponding to token OP_MOVE_OBJECT_FROM16
fn OP_MOVE_OBJECT_FROM16(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MOVE_OBJECT_FROM16, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MoveObjectFrom16InstructionContextAttrs<'input> for MoveObjectFrom16InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moveObjectFrom16Instruction(&mut self,)
	-> Result<Rc<MoveObjectFrom16InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MoveObjectFrom16InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 128, RULE_moveObjectFrom16Instruction);
        let mut _localctx: Rc<MoveObjectFrom16InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(910);
			recog.base.match_token(OP_MOVE_OBJECT_FROM16,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(911);
			recog.leftRegister()?;

			recog.base.set_state(912);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(913);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- moveObject16Instruction ----------------
pub type MoveObject16InstructionContextAll<'input> = MoveObject16InstructionContext<'input>;


pub type MoveObject16InstructionContext<'input> = BaseParserRuleContext<'input,MoveObject16InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MoveObject16InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MoveObject16InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MoveObject16InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_moveObject16Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_moveObject16Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MoveObject16InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_moveObject16Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_moveObject16Instruction }
}
antlr_rust::tid!{MoveObject16InstructionContextExt<'a>}

impl<'input> MoveObject16InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MoveObject16InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MoveObject16InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MoveObject16InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MoveObject16InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MOVE_OBJECT_16
/// Returns `None` if there is no child corresponding to token OP_MOVE_OBJECT_16
fn OP_MOVE_OBJECT_16(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MOVE_OBJECT_16, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MoveObject16InstructionContextAttrs<'input> for MoveObject16InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn moveObject16Instruction(&mut self,)
	-> Result<Rc<MoveObject16InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MoveObject16InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 130, RULE_moveObject16Instruction);
        let mut _localctx: Rc<MoveObject16InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(915);
			recog.base.match_token(OP_MOVE_OBJECT_16,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(916);
			recog.leftRegister()?;

			recog.base.set_state(917);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(918);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constInstruction ----------------
pub type ConstInstructionContextAll<'input> = ConstInstructionContext<'input>;


pub type ConstInstructionContext<'input> = BaseParserRuleContext<'input,ConstInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ConstInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ConstInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ConstInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_constInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConstInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constInstruction }
}
antlr_rust::tid!{ConstInstructionContextExt<'a>}

impl<'input> ConstInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ConstInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_CONST
/// Returns `None` if there is no child corresponding to token OP_CONST
fn OP_CONST(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_CONST, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstInstructionContextAttrs<'input> for ConstInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constInstruction(&mut self,)
	-> Result<Rc<ConstInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 132, RULE_constInstruction);
        let mut _localctx: Rc<ConstInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(920);
			recog.base.match_token(OP_CONST,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(921);
			recog.registerIdentifier()?;

			recog.base.set_state(922);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(923);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- const4Instruction ----------------
pub type Const4InstructionContextAll<'input> = Const4InstructionContext<'input>;


pub type Const4InstructionContext<'input> = BaseParserRuleContext<'input,Const4InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct Const4InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for Const4InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for Const4InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_const4Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_const4Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for Const4InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_const4Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_const4Instruction }
}
antlr_rust::tid!{Const4InstructionContextExt<'a>}

impl<'input> Const4InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Const4InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Const4InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Const4InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<Const4InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_CONST_4
/// Returns `None` if there is no child corresponding to token OP_CONST_4
fn OP_CONST_4(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_CONST_4, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Const4InstructionContextAttrs<'input> for Const4InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn const4Instruction(&mut self,)
	-> Result<Rc<Const4InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Const4InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 134, RULE_const4Instruction);
        let mut _localctx: Rc<Const4InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(925);
			recog.base.match_token(OP_CONST_4,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(926);
			recog.registerIdentifier()?;

			recog.base.set_state(927);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(928);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- const16Instruction ----------------
pub type Const16InstructionContextAll<'input> = Const16InstructionContext<'input>;


pub type Const16InstructionContext<'input> = BaseParserRuleContext<'input,Const16InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct Const16InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for Const16InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for Const16InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_const16Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_const16Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for Const16InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_const16Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_const16Instruction }
}
antlr_rust::tid!{Const16InstructionContextExt<'a>}

impl<'input> Const16InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Const16InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Const16InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait Const16InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<Const16InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_CONST_16
/// Returns `None` if there is no child corresponding to token OP_CONST_16
fn OP_CONST_16(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_CONST_16, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> Const16InstructionContextAttrs<'input> for Const16InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn const16Instruction(&mut self,)
	-> Result<Rc<Const16InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Const16InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 136, RULE_const16Instruction);
        let mut _localctx: Rc<Const16InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(930);
			recog.base.match_token(OP_CONST_16,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(931);
			recog.registerIdentifier()?;

			recog.base.set_state(932);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(933);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constHigh16Instruction ----------------
pub type ConstHigh16InstructionContextAll<'input> = ConstHigh16InstructionContext<'input>;


pub type ConstHigh16InstructionContext<'input> = BaseParserRuleContext<'input,ConstHigh16InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ConstHigh16InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ConstHigh16InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ConstHigh16InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constHigh16Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_constHigh16Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConstHigh16InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constHigh16Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constHigh16Instruction }
}
antlr_rust::tid!{ConstHigh16InstructionContextExt<'a>}

impl<'input> ConstHigh16InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstHigh16InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstHigh16InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstHigh16InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ConstHigh16InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_CONST_HIGH16
/// Returns `None` if there is no child corresponding to token OP_CONST_HIGH16
fn OP_CONST_HIGH16(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_CONST_HIGH16, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstHigh16InstructionContextAttrs<'input> for ConstHigh16InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constHigh16Instruction(&mut self,)
	-> Result<Rc<ConstHigh16InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstHigh16InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 138, RULE_constHigh16Instruction);
        let mut _localctx: Rc<ConstHigh16InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(935);
			recog.base.match_token(OP_CONST_HIGH16,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(936);
			recog.registerIdentifier()?;

			recog.base.set_state(937);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(938);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constWide16Instruction ----------------
pub type ConstWide16InstructionContextAll<'input> = ConstWide16InstructionContext<'input>;


pub type ConstWide16InstructionContext<'input> = BaseParserRuleContext<'input,ConstWide16InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ConstWide16InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ConstWide16InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ConstWide16InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constWide16Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_constWide16Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConstWide16InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constWide16Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constWide16Instruction }
}
antlr_rust::tid!{ConstWide16InstructionContextExt<'a>}

impl<'input> ConstWide16InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstWide16InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstWide16InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstWide16InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ConstWide16InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_CONST_WIDE_16
/// Returns `None` if there is no child corresponding to token OP_CONST_WIDE_16
fn OP_CONST_WIDE_16(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_CONST_WIDE_16, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstWide16InstructionContextAttrs<'input> for ConstWide16InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constWide16Instruction(&mut self,)
	-> Result<Rc<ConstWide16InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstWide16InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 140, RULE_constWide16Instruction);
        let mut _localctx: Rc<ConstWide16InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(940);
			recog.base.match_token(OP_CONST_WIDE_16,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(941);
			recog.registerIdentifier()?;

			recog.base.set_state(942);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(943);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constWide32Instruction ----------------
pub type ConstWide32InstructionContextAll<'input> = ConstWide32InstructionContext<'input>;


pub type ConstWide32InstructionContext<'input> = BaseParserRuleContext<'input,ConstWide32InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ConstWide32InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ConstWide32InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ConstWide32InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constWide32Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_constWide32Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConstWide32InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constWide32Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constWide32Instruction }
}
antlr_rust::tid!{ConstWide32InstructionContextExt<'a>}

impl<'input> ConstWide32InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstWide32InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstWide32InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstWide32InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ConstWide32InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_CONST_WIDE_32
/// Returns `None` if there is no child corresponding to token OP_CONST_WIDE_32
fn OP_CONST_WIDE_32(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_CONST_WIDE_32, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstWide32InstructionContextAttrs<'input> for ConstWide32InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constWide32Instruction(&mut self,)
	-> Result<Rc<ConstWide32InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstWide32InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 142, RULE_constWide32Instruction);
        let mut _localctx: Rc<ConstWide32InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(945);
			recog.base.match_token(OP_CONST_WIDE_32,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(946);
			recog.registerIdentifier()?;

			recog.base.set_state(947);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(948);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constWideInstruction ----------------
pub type ConstWideInstructionContextAll<'input> = ConstWideInstructionContext<'input>;


pub type ConstWideInstructionContext<'input> = BaseParserRuleContext<'input,ConstWideInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ConstWideInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ConstWideInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ConstWideInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constWideInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_constWideInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConstWideInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constWideInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constWideInstruction }
}
antlr_rust::tid!{ConstWideInstructionContextExt<'a>}

impl<'input> ConstWideInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstWideInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstWideInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstWideInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ConstWideInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_CONST_WIDE
/// Returns `None` if there is no child corresponding to token OP_CONST_WIDE
fn OP_CONST_WIDE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_CONST_WIDE, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstWideInstructionContextAttrs<'input> for ConstWideInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constWideInstruction(&mut self,)
	-> Result<Rc<ConstWideInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstWideInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 144, RULE_constWideInstruction);
        let mut _localctx: Rc<ConstWideInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(950);
			recog.base.match_token(OP_CONST_WIDE,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(951);
			recog.registerIdentifier()?;

			recog.base.set_state(952);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(953);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constWideHigh16Instruction ----------------
pub type ConstWideHigh16InstructionContextAll<'input> = ConstWideHigh16InstructionContext<'input>;


pub type ConstWideHigh16InstructionContext<'input> = BaseParserRuleContext<'input,ConstWideHigh16InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ConstWideHigh16InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ConstWideHigh16InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ConstWideHigh16InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constWideHigh16Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_constWideHigh16Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConstWideHigh16InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constWideHigh16Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constWideHigh16Instruction }
}
antlr_rust::tid!{ConstWideHigh16InstructionContextExt<'a>}

impl<'input> ConstWideHigh16InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstWideHigh16InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstWideHigh16InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstWideHigh16InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ConstWideHigh16InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_CONST_WIDE_HIGH16
/// Returns `None` if there is no child corresponding to token OP_CONST_WIDE_HIGH16
fn OP_CONST_WIDE_HIGH16(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_CONST_WIDE_HIGH16, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstWideHigh16InstructionContextAttrs<'input> for ConstWideHigh16InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constWideHigh16Instruction(&mut self,)
	-> Result<Rc<ConstWideHigh16InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstWideHigh16InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 146, RULE_constWideHigh16Instruction);
        let mut _localctx: Rc<ConstWideHigh16InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(955);
			recog.base.match_token(OP_CONST_WIDE_HIGH16,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(956);
			recog.registerIdentifier()?;

			recog.base.set_state(957);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(958);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constString ----------------
pub type ConstStringContextAll<'input> = ConstStringContext<'input>;


pub type ConstStringContext<'input> = BaseParserRuleContext<'input,ConstStringContextExt<'input>>;

#[derive(Clone)]
pub struct ConstStringContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ConstStringContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ConstStringContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constString(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_constString(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConstStringContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constString }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constString }
}
antlr_rust::tid!{ConstStringContextExt<'a>}

impl<'input> ConstStringContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstStringContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstStringContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstStringContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ConstStringContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_CONST_STRING
/// Returns `None` if there is no child corresponding to token OP_CONST_STRING
fn OP_CONST_STRING(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_CONST_STRING, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstStringContextAttrs<'input> for ConstStringContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constString(&mut self,)
	-> Result<Rc<ConstStringContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstStringContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 148, RULE_constString);
        let mut _localctx: Rc<ConstStringContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(960);
			recog.base.match_token(OP_CONST_STRING,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(961);
			recog.registerIdentifier()?;

			recog.base.set_state(962);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule stringLiteral*/
			recog.base.set_state(963);
			recog.stringLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constStringJumbo ----------------
pub type ConstStringJumboContextAll<'input> = ConstStringJumboContext<'input>;


pub type ConstStringJumboContext<'input> = BaseParserRuleContext<'input,ConstStringJumboContextExt<'input>>;

#[derive(Clone)]
pub struct ConstStringJumboContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ConstStringJumboContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ConstStringJumboContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constStringJumbo(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_constStringJumbo(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConstStringJumboContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constStringJumbo }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constStringJumbo }
}
antlr_rust::tid!{ConstStringJumboContextExt<'a>}

impl<'input> ConstStringJumboContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstStringJumboContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstStringJumboContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstStringJumboContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ConstStringJumboContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_CONST_STRING_JUMBO
/// Returns `None` if there is no child corresponding to token OP_CONST_STRING_JUMBO
fn OP_CONST_STRING_JUMBO(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_CONST_STRING_JUMBO, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstStringJumboContextAttrs<'input> for ConstStringJumboContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constStringJumbo(&mut self,)
	-> Result<Rc<ConstStringJumboContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstStringJumboContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 150, RULE_constStringJumbo);
        let mut _localctx: Rc<ConstStringJumboContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(965);
			recog.base.match_token(OP_CONST_STRING_JUMBO,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(966);
			recog.registerIdentifier()?;

			recog.base.set_state(967);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule stringLiteral*/
			recog.base.set_state(968);
			recog.stringLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constClass ----------------
pub type ConstClassContextAll<'input> = ConstClassContext<'input>;


pub type ConstClassContext<'input> = BaseParserRuleContext<'input,ConstClassContextExt<'input>>;

#[derive(Clone)]
pub struct ConstClassContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ConstClassContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ConstClassContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constClass(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_constClass(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ConstClassContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constClass }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constClass }
}
antlr_rust::tid!{ConstClassContextExt<'a>}

impl<'input> ConstClassContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstClassContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstClassContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstClassContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ConstClassContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_CONST_CLASS
/// Returns `None` if there is no child corresponding to token OP_CONST_CLASS
fn OP_CONST_CLASS(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_CONST_CLASS, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn referenceOrArrayType(&self) -> Option<Rc<ReferenceOrArrayTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConstClassContextAttrs<'input> for ConstClassContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constClass(&mut self,)
	-> Result<Rc<ConstClassContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstClassContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 152, RULE_constClass);
        let mut _localctx: Rc<ConstClassContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(970);
			recog.base.match_token(OP_CONST_CLASS,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(971);
			recog.registerIdentifier()?;

			recog.base.set_state(972);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule referenceOrArrayType*/
			recog.base.set_state(973);
			recog.referenceOrArrayType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sGetInstruction ----------------
pub type SGetInstructionContextAll<'input> = SGetInstructionContext<'input>;


pub type SGetInstructionContext<'input> = BaseParserRuleContext<'input,SGetInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SGetInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SGetInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SGetInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sGetInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sGetInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SGetInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sGetInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sGetInstruction }
}
antlr_rust::tid!{SGetInstructionContextExt<'a>}

impl<'input> SGetInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SGetInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SGetInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SGetInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SGetInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SGET
/// Returns `None` if there is no child corresponding to token OP_SGET
fn OP_SGET(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SGET, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn fieldInvocationTarget(&self) -> Option<Rc<FieldInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SGetInstructionContextAttrs<'input> for SGetInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sGetInstruction(&mut self,)
	-> Result<Rc<SGetInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SGetInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 154, RULE_sGetInstruction);
        let mut _localctx: Rc<SGetInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(975);
			recog.base.match_token(OP_SGET,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(976);
			recog.registerIdentifier()?;

			recog.base.set_state(977);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule fieldInvocationTarget*/
			recog.base.set_state(978);
			recog.fieldInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sGetWideInstruction ----------------
pub type SGetWideInstructionContextAll<'input> = SGetWideInstructionContext<'input>;


pub type SGetWideInstructionContext<'input> = BaseParserRuleContext<'input,SGetWideInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SGetWideInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SGetWideInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SGetWideInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sGetWideInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sGetWideInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SGetWideInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sGetWideInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sGetWideInstruction }
}
antlr_rust::tid!{SGetWideInstructionContextExt<'a>}

impl<'input> SGetWideInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SGetWideInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SGetWideInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SGetWideInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SGetWideInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SGET_WIDE
/// Returns `None` if there is no child corresponding to token OP_SGET_WIDE
fn OP_SGET_WIDE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SGET_WIDE, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn fieldInvocationTarget(&self) -> Option<Rc<FieldInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SGetWideInstructionContextAttrs<'input> for SGetWideInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sGetWideInstruction(&mut self,)
	-> Result<Rc<SGetWideInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SGetWideInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 156, RULE_sGetWideInstruction);
        let mut _localctx: Rc<SGetWideInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(980);
			recog.base.match_token(OP_SGET_WIDE,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(981);
			recog.registerIdentifier()?;

			recog.base.set_state(982);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule fieldInvocationTarget*/
			recog.base.set_state(983);
			recog.fieldInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sGetObjectInstruction ----------------
pub type SGetObjectInstructionContextAll<'input> = SGetObjectInstructionContext<'input>;


pub type SGetObjectInstructionContext<'input> = BaseParserRuleContext<'input,SGetObjectInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SGetObjectInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SGetObjectInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SGetObjectInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sGetObjectInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sGetObjectInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SGetObjectInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sGetObjectInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sGetObjectInstruction }
}
antlr_rust::tid!{SGetObjectInstructionContextExt<'a>}

impl<'input> SGetObjectInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SGetObjectInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SGetObjectInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SGetObjectInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SGetObjectInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SGET_OBJECT
/// Returns `None` if there is no child corresponding to token OP_SGET_OBJECT
fn OP_SGET_OBJECT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SGET_OBJECT, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn fieldInvocationTarget(&self) -> Option<Rc<FieldInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SGetObjectInstructionContextAttrs<'input> for SGetObjectInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sGetObjectInstruction(&mut self,)
	-> Result<Rc<SGetObjectInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SGetObjectInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 158, RULE_sGetObjectInstruction);
        let mut _localctx: Rc<SGetObjectInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(985);
			recog.base.match_token(OP_SGET_OBJECT,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(986);
			recog.registerIdentifier()?;

			recog.base.set_state(987);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule fieldInvocationTarget*/
			recog.base.set_state(988);
			recog.fieldInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sGetBooleanInstruction ----------------
pub type SGetBooleanInstructionContextAll<'input> = SGetBooleanInstructionContext<'input>;


pub type SGetBooleanInstructionContext<'input> = BaseParserRuleContext<'input,SGetBooleanInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SGetBooleanInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SGetBooleanInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SGetBooleanInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sGetBooleanInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sGetBooleanInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SGetBooleanInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sGetBooleanInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sGetBooleanInstruction }
}
antlr_rust::tid!{SGetBooleanInstructionContextExt<'a>}

impl<'input> SGetBooleanInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SGetBooleanInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SGetBooleanInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SGetBooleanInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SGetBooleanInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SGET_BOOLEAN
/// Returns `None` if there is no child corresponding to token OP_SGET_BOOLEAN
fn OP_SGET_BOOLEAN(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SGET_BOOLEAN, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn fieldInvocationTarget(&self) -> Option<Rc<FieldInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SGetBooleanInstructionContextAttrs<'input> for SGetBooleanInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sGetBooleanInstruction(&mut self,)
	-> Result<Rc<SGetBooleanInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SGetBooleanInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 160, RULE_sGetBooleanInstruction);
        let mut _localctx: Rc<SGetBooleanInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(990);
			recog.base.match_token(OP_SGET_BOOLEAN,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(991);
			recog.registerIdentifier()?;

			recog.base.set_state(992);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule fieldInvocationTarget*/
			recog.base.set_state(993);
			recog.fieldInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sGetByteInstruction ----------------
pub type SGetByteInstructionContextAll<'input> = SGetByteInstructionContext<'input>;


pub type SGetByteInstructionContext<'input> = BaseParserRuleContext<'input,SGetByteInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SGetByteInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SGetByteInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SGetByteInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sGetByteInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sGetByteInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SGetByteInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sGetByteInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sGetByteInstruction }
}
antlr_rust::tid!{SGetByteInstructionContextExt<'a>}

impl<'input> SGetByteInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SGetByteInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SGetByteInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SGetByteInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SGetByteInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SGET_BYTE
/// Returns `None` if there is no child corresponding to token OP_SGET_BYTE
fn OP_SGET_BYTE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SGET_BYTE, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn fieldInvocationTarget(&self) -> Option<Rc<FieldInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SGetByteInstructionContextAttrs<'input> for SGetByteInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sGetByteInstruction(&mut self,)
	-> Result<Rc<SGetByteInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SGetByteInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 162, RULE_sGetByteInstruction);
        let mut _localctx: Rc<SGetByteInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(995);
			recog.base.match_token(OP_SGET_BYTE,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(996);
			recog.registerIdentifier()?;

			recog.base.set_state(997);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule fieldInvocationTarget*/
			recog.base.set_state(998);
			recog.fieldInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sGetCharInstruction ----------------
pub type SGetCharInstructionContextAll<'input> = SGetCharInstructionContext<'input>;


pub type SGetCharInstructionContext<'input> = BaseParserRuleContext<'input,SGetCharInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SGetCharInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SGetCharInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SGetCharInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sGetCharInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sGetCharInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SGetCharInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sGetCharInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sGetCharInstruction }
}
antlr_rust::tid!{SGetCharInstructionContextExt<'a>}

impl<'input> SGetCharInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SGetCharInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SGetCharInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SGetCharInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SGetCharInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SGET_CHAR
/// Returns `None` if there is no child corresponding to token OP_SGET_CHAR
fn OP_SGET_CHAR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SGET_CHAR, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn fieldInvocationTarget(&self) -> Option<Rc<FieldInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SGetCharInstructionContextAttrs<'input> for SGetCharInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sGetCharInstruction(&mut self,)
	-> Result<Rc<SGetCharInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SGetCharInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 164, RULE_sGetCharInstruction);
        let mut _localctx: Rc<SGetCharInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1000);
			recog.base.match_token(OP_SGET_CHAR,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1001);
			recog.registerIdentifier()?;

			recog.base.set_state(1002);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule fieldInvocationTarget*/
			recog.base.set_state(1003);
			recog.fieldInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sGetShortInstruction ----------------
pub type SGetShortInstructionContextAll<'input> = SGetShortInstructionContext<'input>;


pub type SGetShortInstructionContext<'input> = BaseParserRuleContext<'input,SGetShortInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SGetShortInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SGetShortInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SGetShortInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sGetShortInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sGetShortInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SGetShortInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sGetShortInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sGetShortInstruction }
}
antlr_rust::tid!{SGetShortInstructionContextExt<'a>}

impl<'input> SGetShortInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SGetShortInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SGetShortInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SGetShortInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SGetShortInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SGET_SHORT
/// Returns `None` if there is no child corresponding to token OP_SGET_SHORT
fn OP_SGET_SHORT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SGET_SHORT, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn fieldInvocationTarget(&self) -> Option<Rc<FieldInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SGetShortInstructionContextAttrs<'input> for SGetShortInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sGetShortInstruction(&mut self,)
	-> Result<Rc<SGetShortInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SGetShortInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 166, RULE_sGetShortInstruction);
        let mut _localctx: Rc<SGetShortInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1005);
			recog.base.match_token(OP_SGET_SHORT,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1006);
			recog.registerIdentifier()?;

			recog.base.set_state(1007);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule fieldInvocationTarget*/
			recog.base.set_state(1008);
			recog.fieldInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sPutInstruction ----------------
pub type SPutInstructionContextAll<'input> = SPutInstructionContext<'input>;


pub type SPutInstructionContext<'input> = BaseParserRuleContext<'input,SPutInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SPutInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SPutInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SPutInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sPutInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sPutInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SPutInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sPutInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sPutInstruction }
}
antlr_rust::tid!{SPutInstructionContextExt<'a>}

impl<'input> SPutInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SPutInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SPutInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SPutInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SPutInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SPUT
/// Returns `None` if there is no child corresponding to token OP_SPUT
fn OP_SPUT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SPUT, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn fieldInvocationTarget(&self) -> Option<Rc<FieldInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SPutInstructionContextAttrs<'input> for SPutInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sPutInstruction(&mut self,)
	-> Result<Rc<SPutInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SPutInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 168, RULE_sPutInstruction);
        let mut _localctx: Rc<SPutInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1010);
			recog.base.match_token(OP_SPUT,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1011);
			recog.registerIdentifier()?;

			recog.base.set_state(1012);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule fieldInvocationTarget*/
			recog.base.set_state(1013);
			recog.fieldInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sPutWideInstruction ----------------
pub type SPutWideInstructionContextAll<'input> = SPutWideInstructionContext<'input>;


pub type SPutWideInstructionContext<'input> = BaseParserRuleContext<'input,SPutWideInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SPutWideInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SPutWideInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SPutWideInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sPutWideInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sPutWideInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SPutWideInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sPutWideInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sPutWideInstruction }
}
antlr_rust::tid!{SPutWideInstructionContextExt<'a>}

impl<'input> SPutWideInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SPutWideInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SPutWideInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SPutWideInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SPutWideInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SPUT_WIDE
/// Returns `None` if there is no child corresponding to token OP_SPUT_WIDE
fn OP_SPUT_WIDE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SPUT_WIDE, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn fieldInvocationTarget(&self) -> Option<Rc<FieldInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SPutWideInstructionContextAttrs<'input> for SPutWideInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sPutWideInstruction(&mut self,)
	-> Result<Rc<SPutWideInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SPutWideInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 170, RULE_sPutWideInstruction);
        let mut _localctx: Rc<SPutWideInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1015);
			recog.base.match_token(OP_SPUT_WIDE,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1016);
			recog.registerIdentifier()?;

			recog.base.set_state(1017);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule fieldInvocationTarget*/
			recog.base.set_state(1018);
			recog.fieldInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sPutObjectInstruction ----------------
pub type SPutObjectInstructionContextAll<'input> = SPutObjectInstructionContext<'input>;


pub type SPutObjectInstructionContext<'input> = BaseParserRuleContext<'input,SPutObjectInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SPutObjectInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SPutObjectInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SPutObjectInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sPutObjectInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sPutObjectInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SPutObjectInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sPutObjectInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sPutObjectInstruction }
}
antlr_rust::tid!{SPutObjectInstructionContextExt<'a>}

impl<'input> SPutObjectInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SPutObjectInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SPutObjectInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SPutObjectInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SPutObjectInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SPUT_OBJECT
/// Returns `None` if there is no child corresponding to token OP_SPUT_OBJECT
fn OP_SPUT_OBJECT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SPUT_OBJECT, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn fieldInvocationTarget(&self) -> Option<Rc<FieldInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SPutObjectInstructionContextAttrs<'input> for SPutObjectInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sPutObjectInstruction(&mut self,)
	-> Result<Rc<SPutObjectInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SPutObjectInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 172, RULE_sPutObjectInstruction);
        let mut _localctx: Rc<SPutObjectInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1020);
			recog.base.match_token(OP_SPUT_OBJECT,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1021);
			recog.registerIdentifier()?;

			recog.base.set_state(1022);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule fieldInvocationTarget*/
			recog.base.set_state(1023);
			recog.fieldInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sPutBooleanInstruction ----------------
pub type SPutBooleanInstructionContextAll<'input> = SPutBooleanInstructionContext<'input>;


pub type SPutBooleanInstructionContext<'input> = BaseParserRuleContext<'input,SPutBooleanInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SPutBooleanInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SPutBooleanInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SPutBooleanInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sPutBooleanInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sPutBooleanInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SPutBooleanInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sPutBooleanInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sPutBooleanInstruction }
}
antlr_rust::tid!{SPutBooleanInstructionContextExt<'a>}

impl<'input> SPutBooleanInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SPutBooleanInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SPutBooleanInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SPutBooleanInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SPutBooleanInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SPUT_BOOLEAN
/// Returns `None` if there is no child corresponding to token OP_SPUT_BOOLEAN
fn OP_SPUT_BOOLEAN(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SPUT_BOOLEAN, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn fieldInvocationTarget(&self) -> Option<Rc<FieldInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SPutBooleanInstructionContextAttrs<'input> for SPutBooleanInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sPutBooleanInstruction(&mut self,)
	-> Result<Rc<SPutBooleanInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SPutBooleanInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 174, RULE_sPutBooleanInstruction);
        let mut _localctx: Rc<SPutBooleanInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1025);
			recog.base.match_token(OP_SPUT_BOOLEAN,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1026);
			recog.registerIdentifier()?;

			recog.base.set_state(1027);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule fieldInvocationTarget*/
			recog.base.set_state(1028);
			recog.fieldInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sPutByteInstruction ----------------
pub type SPutByteInstructionContextAll<'input> = SPutByteInstructionContext<'input>;


pub type SPutByteInstructionContext<'input> = BaseParserRuleContext<'input,SPutByteInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SPutByteInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SPutByteInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SPutByteInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sPutByteInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sPutByteInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SPutByteInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sPutByteInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sPutByteInstruction }
}
antlr_rust::tid!{SPutByteInstructionContextExt<'a>}

impl<'input> SPutByteInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SPutByteInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SPutByteInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SPutByteInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SPutByteInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SPUT_BYTE
/// Returns `None` if there is no child corresponding to token OP_SPUT_BYTE
fn OP_SPUT_BYTE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SPUT_BYTE, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn fieldInvocationTarget(&self) -> Option<Rc<FieldInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SPutByteInstructionContextAttrs<'input> for SPutByteInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sPutByteInstruction(&mut self,)
	-> Result<Rc<SPutByteInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SPutByteInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 176, RULE_sPutByteInstruction);
        let mut _localctx: Rc<SPutByteInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1030);
			recog.base.match_token(OP_SPUT_BYTE,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1031);
			recog.registerIdentifier()?;

			recog.base.set_state(1032);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule fieldInvocationTarget*/
			recog.base.set_state(1033);
			recog.fieldInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sPutCharInstruction ----------------
pub type SPutCharInstructionContextAll<'input> = SPutCharInstructionContext<'input>;


pub type SPutCharInstructionContext<'input> = BaseParserRuleContext<'input,SPutCharInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SPutCharInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SPutCharInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SPutCharInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sPutCharInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sPutCharInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SPutCharInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sPutCharInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sPutCharInstruction }
}
antlr_rust::tid!{SPutCharInstructionContextExt<'a>}

impl<'input> SPutCharInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SPutCharInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SPutCharInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SPutCharInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SPutCharInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SPUT_CHAR
/// Returns `None` if there is no child corresponding to token OP_SPUT_CHAR
fn OP_SPUT_CHAR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SPUT_CHAR, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn fieldInvocationTarget(&self) -> Option<Rc<FieldInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SPutCharInstructionContextAttrs<'input> for SPutCharInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sPutCharInstruction(&mut self,)
	-> Result<Rc<SPutCharInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SPutCharInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 178, RULE_sPutCharInstruction);
        let mut _localctx: Rc<SPutCharInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1035);
			recog.base.match_token(OP_SPUT_CHAR,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1036);
			recog.registerIdentifier()?;

			recog.base.set_state(1037);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule fieldInvocationTarget*/
			recog.base.set_state(1038);
			recog.fieldInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sPutShortInstruction ----------------
pub type SPutShortInstructionContextAll<'input> = SPutShortInstructionContext<'input>;


pub type SPutShortInstructionContext<'input> = BaseParserRuleContext<'input,SPutShortInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SPutShortInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SPutShortInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SPutShortInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sPutShortInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sPutShortInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SPutShortInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sPutShortInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sPutShortInstruction }
}
antlr_rust::tid!{SPutShortInstructionContextExt<'a>}

impl<'input> SPutShortInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SPutShortInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SPutShortInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SPutShortInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SPutShortInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SPUT_SHORT
/// Returns `None` if there is no child corresponding to token OP_SPUT_SHORT
fn OP_SPUT_SHORT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SPUT_SHORT, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn fieldInvocationTarget(&self) -> Option<Rc<FieldInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SPutShortInstructionContextAttrs<'input> for SPutShortInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sPutShortInstruction(&mut self,)
	-> Result<Rc<SPutShortInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SPutShortInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 180, RULE_sPutShortInstruction);
        let mut _localctx: Rc<SPutShortInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1040);
			recog.base.match_token(OP_SPUT_SHORT,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1041);
			recog.registerIdentifier()?;

			recog.base.set_state(1042);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule fieldInvocationTarget*/
			recog.base.set_state(1043);
			recog.fieldInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- invokeVirtualInstruction ----------------
pub type InvokeVirtualInstructionContextAll<'input> = InvokeVirtualInstructionContext<'input>;


pub type InvokeVirtualInstructionContext<'input> = BaseParserRuleContext<'input,InvokeVirtualInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct InvokeVirtualInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InvokeVirtualInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InvokeVirtualInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_invokeVirtualInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_invokeVirtualInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InvokeVirtualInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_invokeVirtualInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_invokeVirtualInstruction }
}
antlr_rust::tid!{InvokeVirtualInstructionContextExt<'a>}

impl<'input> InvokeVirtualInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InvokeVirtualInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InvokeVirtualInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InvokeVirtualInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InvokeVirtualInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INVOKE_VIRTUAL
/// Returns `None` if there is no child corresponding to token OP_INVOKE_VIRTUAL
fn OP_INVOKE_VIRTUAL(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INVOKE_VIRTUAL, 0)
}
fn registerList(&self) -> Option<Rc<RegisterListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn methodInvocationTarget(&self) -> Option<Rc<MethodInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InvokeVirtualInstructionContextAttrs<'input> for InvokeVirtualInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn invokeVirtualInstruction(&mut self,)
	-> Result<Rc<InvokeVirtualInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InvokeVirtualInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 182, RULE_invokeVirtualInstruction);
        let mut _localctx: Rc<InvokeVirtualInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1045);
			recog.base.match_token(OP_INVOKE_VIRTUAL,&mut recog.err_handler)?;

			/*InvokeRule registerList*/
			recog.base.set_state(1046);
			recog.registerList()?;

			recog.base.set_state(1047);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule methodInvocationTarget*/
			recog.base.set_state(1048);
			recog.methodInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- invokeSuperInstruction ----------------
pub type InvokeSuperInstructionContextAll<'input> = InvokeSuperInstructionContext<'input>;


pub type InvokeSuperInstructionContext<'input> = BaseParserRuleContext<'input,InvokeSuperInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct InvokeSuperInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InvokeSuperInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InvokeSuperInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_invokeSuperInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_invokeSuperInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InvokeSuperInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_invokeSuperInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_invokeSuperInstruction }
}
antlr_rust::tid!{InvokeSuperInstructionContextExt<'a>}

impl<'input> InvokeSuperInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InvokeSuperInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InvokeSuperInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InvokeSuperInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InvokeSuperInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INVOKE_SUPER
/// Returns `None` if there is no child corresponding to token OP_INVOKE_SUPER
fn OP_INVOKE_SUPER(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INVOKE_SUPER, 0)
}
fn registerList(&self) -> Option<Rc<RegisterListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn methodInvocationTarget(&self) -> Option<Rc<MethodInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InvokeSuperInstructionContextAttrs<'input> for InvokeSuperInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn invokeSuperInstruction(&mut self,)
	-> Result<Rc<InvokeSuperInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InvokeSuperInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 184, RULE_invokeSuperInstruction);
        let mut _localctx: Rc<InvokeSuperInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1050);
			recog.base.match_token(OP_INVOKE_SUPER,&mut recog.err_handler)?;

			/*InvokeRule registerList*/
			recog.base.set_state(1051);
			recog.registerList()?;

			recog.base.set_state(1052);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule methodInvocationTarget*/
			recog.base.set_state(1053);
			recog.methodInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- invokeDirectInstruction ----------------
pub type InvokeDirectInstructionContextAll<'input> = InvokeDirectInstructionContext<'input>;


pub type InvokeDirectInstructionContext<'input> = BaseParserRuleContext<'input,InvokeDirectInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct InvokeDirectInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InvokeDirectInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InvokeDirectInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_invokeDirectInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_invokeDirectInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InvokeDirectInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_invokeDirectInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_invokeDirectInstruction }
}
antlr_rust::tid!{InvokeDirectInstructionContextExt<'a>}

impl<'input> InvokeDirectInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InvokeDirectInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InvokeDirectInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InvokeDirectInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InvokeDirectInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INVOKE_DIRECT
/// Returns `None` if there is no child corresponding to token OP_INVOKE_DIRECT
fn OP_INVOKE_DIRECT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INVOKE_DIRECT, 0)
}
fn registerList(&self) -> Option<Rc<RegisterListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn methodInvocationTarget(&self) -> Option<Rc<MethodInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InvokeDirectInstructionContextAttrs<'input> for InvokeDirectInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn invokeDirectInstruction(&mut self,)
	-> Result<Rc<InvokeDirectInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InvokeDirectInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 186, RULE_invokeDirectInstruction);
        let mut _localctx: Rc<InvokeDirectInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1055);
			recog.base.match_token(OP_INVOKE_DIRECT,&mut recog.err_handler)?;

			/*InvokeRule registerList*/
			recog.base.set_state(1056);
			recog.registerList()?;

			recog.base.set_state(1057);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule methodInvocationTarget*/
			recog.base.set_state(1058);
			recog.methodInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- invokeStaticInstruction ----------------
pub type InvokeStaticInstructionContextAll<'input> = InvokeStaticInstructionContext<'input>;


pub type InvokeStaticInstructionContext<'input> = BaseParserRuleContext<'input,InvokeStaticInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct InvokeStaticInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InvokeStaticInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InvokeStaticInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_invokeStaticInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_invokeStaticInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InvokeStaticInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_invokeStaticInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_invokeStaticInstruction }
}
antlr_rust::tid!{InvokeStaticInstructionContextExt<'a>}

impl<'input> InvokeStaticInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InvokeStaticInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InvokeStaticInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InvokeStaticInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InvokeStaticInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INVOKE_STATIC
/// Returns `None` if there is no child corresponding to token OP_INVOKE_STATIC
fn OP_INVOKE_STATIC(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INVOKE_STATIC, 0)
}
fn registerList(&self) -> Option<Rc<RegisterListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn methodInvocationTarget(&self) -> Option<Rc<MethodInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InvokeStaticInstructionContextAttrs<'input> for InvokeStaticInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn invokeStaticInstruction(&mut self,)
	-> Result<Rc<InvokeStaticInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InvokeStaticInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 188, RULE_invokeStaticInstruction);
        let mut _localctx: Rc<InvokeStaticInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1060);
			recog.base.match_token(OP_INVOKE_STATIC,&mut recog.err_handler)?;

			/*InvokeRule registerList*/
			recog.base.set_state(1061);
			recog.registerList()?;

			recog.base.set_state(1062);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule methodInvocationTarget*/
			recog.base.set_state(1063);
			recog.methodInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- invokeInterfaceInstruction ----------------
pub type InvokeInterfaceInstructionContextAll<'input> = InvokeInterfaceInstructionContext<'input>;


pub type InvokeInterfaceInstructionContext<'input> = BaseParserRuleContext<'input,InvokeInterfaceInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct InvokeInterfaceInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InvokeInterfaceInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InvokeInterfaceInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_invokeInterfaceInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_invokeInterfaceInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InvokeInterfaceInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_invokeInterfaceInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_invokeInterfaceInstruction }
}
antlr_rust::tid!{InvokeInterfaceInstructionContextExt<'a>}

impl<'input> InvokeInterfaceInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InvokeInterfaceInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InvokeInterfaceInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InvokeInterfaceInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InvokeInterfaceInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INVOKE_INTERFACE
/// Returns `None` if there is no child corresponding to token OP_INVOKE_INTERFACE
fn OP_INVOKE_INTERFACE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INVOKE_INTERFACE, 0)
}
fn registerList(&self) -> Option<Rc<RegisterListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn methodInvocationTarget(&self) -> Option<Rc<MethodInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InvokeInterfaceInstructionContextAttrs<'input> for InvokeInterfaceInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn invokeInterfaceInstruction(&mut self,)
	-> Result<Rc<InvokeInterfaceInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InvokeInterfaceInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 190, RULE_invokeInterfaceInstruction);
        let mut _localctx: Rc<InvokeInterfaceInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1065);
			recog.base.match_token(OP_INVOKE_INTERFACE,&mut recog.err_handler)?;

			/*InvokeRule registerList*/
			recog.base.set_state(1066);
			recog.registerList()?;

			recog.base.set_state(1067);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule methodInvocationTarget*/
			recog.base.set_state(1068);
			recog.methodInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- invokeVirtualRangeInstruction ----------------
pub type InvokeVirtualRangeInstructionContextAll<'input> = InvokeVirtualRangeInstructionContext<'input>;


pub type InvokeVirtualRangeInstructionContext<'input> = BaseParserRuleContext<'input,InvokeVirtualRangeInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct InvokeVirtualRangeInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InvokeVirtualRangeInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InvokeVirtualRangeInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_invokeVirtualRangeInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_invokeVirtualRangeInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InvokeVirtualRangeInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_invokeVirtualRangeInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_invokeVirtualRangeInstruction }
}
antlr_rust::tid!{InvokeVirtualRangeInstructionContextExt<'a>}

impl<'input> InvokeVirtualRangeInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InvokeVirtualRangeInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InvokeVirtualRangeInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InvokeVirtualRangeInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InvokeVirtualRangeInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INVOKE_VIRTUAL_RANGE
/// Returns `None` if there is no child corresponding to token OP_INVOKE_VIRTUAL_RANGE
fn OP_INVOKE_VIRTUAL_RANGE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INVOKE_VIRTUAL_RANGE, 0)
}
fn registerRange(&self) -> Option<Rc<RegisterRangeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn methodInvocationTarget(&self) -> Option<Rc<MethodInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InvokeVirtualRangeInstructionContextAttrs<'input> for InvokeVirtualRangeInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn invokeVirtualRangeInstruction(&mut self,)
	-> Result<Rc<InvokeVirtualRangeInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InvokeVirtualRangeInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 192, RULE_invokeVirtualRangeInstruction);
        let mut _localctx: Rc<InvokeVirtualRangeInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1070);
			recog.base.match_token(OP_INVOKE_VIRTUAL_RANGE,&mut recog.err_handler)?;

			/*InvokeRule registerRange*/
			recog.base.set_state(1071);
			recog.registerRange()?;

			recog.base.set_state(1072);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule methodInvocationTarget*/
			recog.base.set_state(1073);
			recog.methodInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- invokeSuperRangeInstruction ----------------
pub type InvokeSuperRangeInstructionContextAll<'input> = InvokeSuperRangeInstructionContext<'input>;


pub type InvokeSuperRangeInstructionContext<'input> = BaseParserRuleContext<'input,InvokeSuperRangeInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct InvokeSuperRangeInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InvokeSuperRangeInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InvokeSuperRangeInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_invokeSuperRangeInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_invokeSuperRangeInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InvokeSuperRangeInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_invokeSuperRangeInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_invokeSuperRangeInstruction }
}
antlr_rust::tid!{InvokeSuperRangeInstructionContextExt<'a>}

impl<'input> InvokeSuperRangeInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InvokeSuperRangeInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InvokeSuperRangeInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InvokeSuperRangeInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InvokeSuperRangeInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INVOKE_SUPER_RANGE
/// Returns `None` if there is no child corresponding to token OP_INVOKE_SUPER_RANGE
fn OP_INVOKE_SUPER_RANGE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INVOKE_SUPER_RANGE, 0)
}
fn registerRange(&self) -> Option<Rc<RegisterRangeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn methodInvocationTarget(&self) -> Option<Rc<MethodInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InvokeSuperRangeInstructionContextAttrs<'input> for InvokeSuperRangeInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn invokeSuperRangeInstruction(&mut self,)
	-> Result<Rc<InvokeSuperRangeInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InvokeSuperRangeInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 194, RULE_invokeSuperRangeInstruction);
        let mut _localctx: Rc<InvokeSuperRangeInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1075);
			recog.base.match_token(OP_INVOKE_SUPER_RANGE,&mut recog.err_handler)?;

			/*InvokeRule registerRange*/
			recog.base.set_state(1076);
			recog.registerRange()?;

			recog.base.set_state(1077);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule methodInvocationTarget*/
			recog.base.set_state(1078);
			recog.methodInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- invokeDirectRangeInstruction ----------------
pub type InvokeDirectRangeInstructionContextAll<'input> = InvokeDirectRangeInstructionContext<'input>;


pub type InvokeDirectRangeInstructionContext<'input> = BaseParserRuleContext<'input,InvokeDirectRangeInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct InvokeDirectRangeInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InvokeDirectRangeInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InvokeDirectRangeInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_invokeDirectRangeInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_invokeDirectRangeInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InvokeDirectRangeInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_invokeDirectRangeInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_invokeDirectRangeInstruction }
}
antlr_rust::tid!{InvokeDirectRangeInstructionContextExt<'a>}

impl<'input> InvokeDirectRangeInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InvokeDirectRangeInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InvokeDirectRangeInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InvokeDirectRangeInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InvokeDirectRangeInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INVOKE_DIRECT_RANGE
/// Returns `None` if there is no child corresponding to token OP_INVOKE_DIRECT_RANGE
fn OP_INVOKE_DIRECT_RANGE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INVOKE_DIRECT_RANGE, 0)
}
fn registerRange(&self) -> Option<Rc<RegisterRangeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn methodInvocationTarget(&self) -> Option<Rc<MethodInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InvokeDirectRangeInstructionContextAttrs<'input> for InvokeDirectRangeInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn invokeDirectRangeInstruction(&mut self,)
	-> Result<Rc<InvokeDirectRangeInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InvokeDirectRangeInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 196, RULE_invokeDirectRangeInstruction);
        let mut _localctx: Rc<InvokeDirectRangeInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1080);
			recog.base.match_token(OP_INVOKE_DIRECT_RANGE,&mut recog.err_handler)?;

			/*InvokeRule registerRange*/
			recog.base.set_state(1081);
			recog.registerRange()?;

			recog.base.set_state(1082);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule methodInvocationTarget*/
			recog.base.set_state(1083);
			recog.methodInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- invokeStaticRangeInstruction ----------------
pub type InvokeStaticRangeInstructionContextAll<'input> = InvokeStaticRangeInstructionContext<'input>;


pub type InvokeStaticRangeInstructionContext<'input> = BaseParserRuleContext<'input,InvokeStaticRangeInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct InvokeStaticRangeInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InvokeStaticRangeInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InvokeStaticRangeInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_invokeStaticRangeInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_invokeStaticRangeInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InvokeStaticRangeInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_invokeStaticRangeInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_invokeStaticRangeInstruction }
}
antlr_rust::tid!{InvokeStaticRangeInstructionContextExt<'a>}

impl<'input> InvokeStaticRangeInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InvokeStaticRangeInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InvokeStaticRangeInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InvokeStaticRangeInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InvokeStaticRangeInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INVOKE_STATIC_RANGE
/// Returns `None` if there is no child corresponding to token OP_INVOKE_STATIC_RANGE
fn OP_INVOKE_STATIC_RANGE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INVOKE_STATIC_RANGE, 0)
}
fn registerRange(&self) -> Option<Rc<RegisterRangeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn methodInvocationTarget(&self) -> Option<Rc<MethodInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InvokeStaticRangeInstructionContextAttrs<'input> for InvokeStaticRangeInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn invokeStaticRangeInstruction(&mut self,)
	-> Result<Rc<InvokeStaticRangeInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InvokeStaticRangeInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 198, RULE_invokeStaticRangeInstruction);
        let mut _localctx: Rc<InvokeStaticRangeInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1085);
			recog.base.match_token(OP_INVOKE_STATIC_RANGE,&mut recog.err_handler)?;

			/*InvokeRule registerRange*/
			recog.base.set_state(1086);
			recog.registerRange()?;

			recog.base.set_state(1087);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule methodInvocationTarget*/
			recog.base.set_state(1088);
			recog.methodInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- invokeInterfaceRangeInstruction ----------------
pub type InvokeInterfaceRangeInstructionContextAll<'input> = InvokeInterfaceRangeInstructionContext<'input>;


pub type InvokeInterfaceRangeInstructionContext<'input> = BaseParserRuleContext<'input,InvokeInterfaceRangeInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct InvokeInterfaceRangeInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InvokeInterfaceRangeInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InvokeInterfaceRangeInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_invokeInterfaceRangeInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_invokeInterfaceRangeInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InvokeInterfaceRangeInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_invokeInterfaceRangeInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_invokeInterfaceRangeInstruction }
}
antlr_rust::tid!{InvokeInterfaceRangeInstructionContextExt<'a>}

impl<'input> InvokeInterfaceRangeInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InvokeInterfaceRangeInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InvokeInterfaceRangeInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InvokeInterfaceRangeInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InvokeInterfaceRangeInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INVOKE_INTERFACE_RANGE
/// Returns `None` if there is no child corresponding to token OP_INVOKE_INTERFACE_RANGE
fn OP_INVOKE_INTERFACE_RANGE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INVOKE_INTERFACE_RANGE, 0)
}
fn registerRange(&self) -> Option<Rc<RegisterRangeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn methodInvocationTarget(&self) -> Option<Rc<MethodInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InvokeInterfaceRangeInstructionContextAttrs<'input> for InvokeInterfaceRangeInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn invokeInterfaceRangeInstruction(&mut self,)
	-> Result<Rc<InvokeInterfaceRangeInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InvokeInterfaceRangeInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 200, RULE_invokeInterfaceRangeInstruction);
        let mut _localctx: Rc<InvokeInterfaceRangeInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1090);
			recog.base.match_token(OP_INVOKE_INTERFACE_RANGE,&mut recog.err_handler)?;

			/*InvokeRule registerRange*/
			recog.base.set_state(1091);
			recog.registerRange()?;

			recog.base.set_state(1092);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule methodInvocationTarget*/
			recog.base.set_state(1093);
			recog.methodInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- intToLongInstruction ----------------
pub type IntToLongInstructionContextAll<'input> = IntToLongInstructionContext<'input>;


pub type IntToLongInstructionContext<'input> = BaseParserRuleContext<'input,IntToLongInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IntToLongInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IntToLongInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IntToLongInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_intToLongInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_intToLongInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IntToLongInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_intToLongInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_intToLongInstruction }
}
antlr_rust::tid!{IntToLongInstructionContextExt<'a>}

impl<'input> IntToLongInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IntToLongInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IntToLongInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IntToLongInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IntToLongInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INT_TO_LONG
/// Returns `None` if there is no child corresponding to token OP_INT_TO_LONG
fn OP_INT_TO_LONG(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INT_TO_LONG, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IntToLongInstructionContextAttrs<'input> for IntToLongInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn intToLongInstruction(&mut self,)
	-> Result<Rc<IntToLongInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IntToLongInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 202, RULE_intToLongInstruction);
        let mut _localctx: Rc<IntToLongInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1095);
			recog.base.match_token(OP_INT_TO_LONG,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1096);
			recog.leftRegister()?;

			recog.base.set_state(1097);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1098);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- intToFloatInstruction ----------------
pub type IntToFloatInstructionContextAll<'input> = IntToFloatInstructionContext<'input>;


pub type IntToFloatInstructionContext<'input> = BaseParserRuleContext<'input,IntToFloatInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IntToFloatInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IntToFloatInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IntToFloatInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_intToFloatInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_intToFloatInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IntToFloatInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_intToFloatInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_intToFloatInstruction }
}
antlr_rust::tid!{IntToFloatInstructionContextExt<'a>}

impl<'input> IntToFloatInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IntToFloatInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IntToFloatInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IntToFloatInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IntToFloatInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INT_TO_FLOAT
/// Returns `None` if there is no child corresponding to token OP_INT_TO_FLOAT
fn OP_INT_TO_FLOAT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INT_TO_FLOAT, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IntToFloatInstructionContextAttrs<'input> for IntToFloatInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn intToFloatInstruction(&mut self,)
	-> Result<Rc<IntToFloatInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IntToFloatInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 204, RULE_intToFloatInstruction);
        let mut _localctx: Rc<IntToFloatInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1100);
			recog.base.match_token(OP_INT_TO_FLOAT,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1101);
			recog.leftRegister()?;

			recog.base.set_state(1102);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1103);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- intToDoubleInstruction ----------------
pub type IntToDoubleInstructionContextAll<'input> = IntToDoubleInstructionContext<'input>;


pub type IntToDoubleInstructionContext<'input> = BaseParserRuleContext<'input,IntToDoubleInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IntToDoubleInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IntToDoubleInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IntToDoubleInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_intToDoubleInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_intToDoubleInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IntToDoubleInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_intToDoubleInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_intToDoubleInstruction }
}
antlr_rust::tid!{IntToDoubleInstructionContextExt<'a>}

impl<'input> IntToDoubleInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IntToDoubleInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IntToDoubleInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IntToDoubleInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IntToDoubleInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INT_TO_DOUBLE
/// Returns `None` if there is no child corresponding to token OP_INT_TO_DOUBLE
fn OP_INT_TO_DOUBLE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INT_TO_DOUBLE, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IntToDoubleInstructionContextAttrs<'input> for IntToDoubleInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn intToDoubleInstruction(&mut self,)
	-> Result<Rc<IntToDoubleInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IntToDoubleInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 206, RULE_intToDoubleInstruction);
        let mut _localctx: Rc<IntToDoubleInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1105);
			recog.base.match_token(OP_INT_TO_DOUBLE,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1106);
			recog.leftRegister()?;

			recog.base.set_state(1107);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1108);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- longToIntInstruction ----------------
pub type LongToIntInstructionContextAll<'input> = LongToIntInstructionContext<'input>;


pub type LongToIntInstructionContext<'input> = BaseParserRuleContext<'input,LongToIntInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct LongToIntInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for LongToIntInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for LongToIntInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_longToIntInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_longToIntInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LongToIntInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_longToIntInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_longToIntInstruction }
}
antlr_rust::tid!{LongToIntInstructionContextExt<'a>}

impl<'input> LongToIntInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LongToIntInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LongToIntInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LongToIntInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<LongToIntInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_LONG_TO_INT
/// Returns `None` if there is no child corresponding to token OP_LONG_TO_INT
fn OP_LONG_TO_INT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_LONG_TO_INT, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LongToIntInstructionContextAttrs<'input> for LongToIntInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn longToIntInstruction(&mut self,)
	-> Result<Rc<LongToIntInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LongToIntInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 208, RULE_longToIntInstruction);
        let mut _localctx: Rc<LongToIntInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1110);
			recog.base.match_token(OP_LONG_TO_INT,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1111);
			recog.leftRegister()?;

			recog.base.set_state(1112);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1113);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- longToFloatInstruction ----------------
pub type LongToFloatInstructionContextAll<'input> = LongToFloatInstructionContext<'input>;


pub type LongToFloatInstructionContext<'input> = BaseParserRuleContext<'input,LongToFloatInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct LongToFloatInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for LongToFloatInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for LongToFloatInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_longToFloatInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_longToFloatInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LongToFloatInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_longToFloatInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_longToFloatInstruction }
}
antlr_rust::tid!{LongToFloatInstructionContextExt<'a>}

impl<'input> LongToFloatInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LongToFloatInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LongToFloatInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LongToFloatInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<LongToFloatInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_LONG_TO_FLOAT
/// Returns `None` if there is no child corresponding to token OP_LONG_TO_FLOAT
fn OP_LONG_TO_FLOAT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_LONG_TO_FLOAT, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LongToFloatInstructionContextAttrs<'input> for LongToFloatInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn longToFloatInstruction(&mut self,)
	-> Result<Rc<LongToFloatInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LongToFloatInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 210, RULE_longToFloatInstruction);
        let mut _localctx: Rc<LongToFloatInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1115);
			recog.base.match_token(OP_LONG_TO_FLOAT,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1116);
			recog.leftRegister()?;

			recog.base.set_state(1117);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1118);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- longToDoubleInstruction ----------------
pub type LongToDoubleInstructionContextAll<'input> = LongToDoubleInstructionContext<'input>;


pub type LongToDoubleInstructionContext<'input> = BaseParserRuleContext<'input,LongToDoubleInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct LongToDoubleInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for LongToDoubleInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for LongToDoubleInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_longToDoubleInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_longToDoubleInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LongToDoubleInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_longToDoubleInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_longToDoubleInstruction }
}
antlr_rust::tid!{LongToDoubleInstructionContextExt<'a>}

impl<'input> LongToDoubleInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LongToDoubleInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LongToDoubleInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LongToDoubleInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<LongToDoubleInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_LONG_TO_DOUBLE
/// Returns `None` if there is no child corresponding to token OP_LONG_TO_DOUBLE
fn OP_LONG_TO_DOUBLE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_LONG_TO_DOUBLE, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LongToDoubleInstructionContextAttrs<'input> for LongToDoubleInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn longToDoubleInstruction(&mut self,)
	-> Result<Rc<LongToDoubleInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LongToDoubleInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 212, RULE_longToDoubleInstruction);
        let mut _localctx: Rc<LongToDoubleInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1120);
			recog.base.match_token(OP_LONG_TO_DOUBLE,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1121);
			recog.leftRegister()?;

			recog.base.set_state(1122);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1123);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- floatToIntInstruction ----------------
pub type FloatToIntInstructionContextAll<'input> = FloatToIntInstructionContext<'input>;


pub type FloatToIntInstructionContext<'input> = BaseParserRuleContext<'input,FloatToIntInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct FloatToIntInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for FloatToIntInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for FloatToIntInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_floatToIntInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_floatToIntInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FloatToIntInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_floatToIntInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_floatToIntInstruction }
}
antlr_rust::tid!{FloatToIntInstructionContextExt<'a>}

impl<'input> FloatToIntInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FloatToIntInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FloatToIntInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FloatToIntInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<FloatToIntInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_FLOAT_TO_INT
/// Returns `None` if there is no child corresponding to token OP_FLOAT_TO_INT
fn OP_FLOAT_TO_INT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_FLOAT_TO_INT, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FloatToIntInstructionContextAttrs<'input> for FloatToIntInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn floatToIntInstruction(&mut self,)
	-> Result<Rc<FloatToIntInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FloatToIntInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 214, RULE_floatToIntInstruction);
        let mut _localctx: Rc<FloatToIntInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1125);
			recog.base.match_token(OP_FLOAT_TO_INT,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1126);
			recog.leftRegister()?;

			recog.base.set_state(1127);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1128);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- floatToLongInstruction ----------------
pub type FloatToLongInstructionContextAll<'input> = FloatToLongInstructionContext<'input>;


pub type FloatToLongInstructionContext<'input> = BaseParserRuleContext<'input,FloatToLongInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct FloatToLongInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for FloatToLongInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for FloatToLongInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_floatToLongInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_floatToLongInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FloatToLongInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_floatToLongInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_floatToLongInstruction }
}
antlr_rust::tid!{FloatToLongInstructionContextExt<'a>}

impl<'input> FloatToLongInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FloatToLongInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FloatToLongInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FloatToLongInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<FloatToLongInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_FLOAT_TO_LONG
/// Returns `None` if there is no child corresponding to token OP_FLOAT_TO_LONG
fn OP_FLOAT_TO_LONG(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_FLOAT_TO_LONG, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FloatToLongInstructionContextAttrs<'input> for FloatToLongInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn floatToLongInstruction(&mut self,)
	-> Result<Rc<FloatToLongInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FloatToLongInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 216, RULE_floatToLongInstruction);
        let mut _localctx: Rc<FloatToLongInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1130);
			recog.base.match_token(OP_FLOAT_TO_LONG,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1131);
			recog.leftRegister()?;

			recog.base.set_state(1132);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1133);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- floatToDoubleInstruction ----------------
pub type FloatToDoubleInstructionContextAll<'input> = FloatToDoubleInstructionContext<'input>;


pub type FloatToDoubleInstructionContext<'input> = BaseParserRuleContext<'input,FloatToDoubleInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct FloatToDoubleInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for FloatToDoubleInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for FloatToDoubleInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_floatToDoubleInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_floatToDoubleInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FloatToDoubleInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_floatToDoubleInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_floatToDoubleInstruction }
}
antlr_rust::tid!{FloatToDoubleInstructionContextExt<'a>}

impl<'input> FloatToDoubleInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FloatToDoubleInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FloatToDoubleInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FloatToDoubleInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<FloatToDoubleInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_FLOAT_TO_DOUBLE
/// Returns `None` if there is no child corresponding to token OP_FLOAT_TO_DOUBLE
fn OP_FLOAT_TO_DOUBLE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_FLOAT_TO_DOUBLE, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FloatToDoubleInstructionContextAttrs<'input> for FloatToDoubleInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn floatToDoubleInstruction(&mut self,)
	-> Result<Rc<FloatToDoubleInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FloatToDoubleInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 218, RULE_floatToDoubleInstruction);
        let mut _localctx: Rc<FloatToDoubleInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1135);
			recog.base.match_token(OP_FLOAT_TO_DOUBLE,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1136);
			recog.leftRegister()?;

			recog.base.set_state(1137);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1138);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- doubleToIntInstruction ----------------
pub type DoubleToIntInstructionContextAll<'input> = DoubleToIntInstructionContext<'input>;


pub type DoubleToIntInstructionContext<'input> = BaseParserRuleContext<'input,DoubleToIntInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct DoubleToIntInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for DoubleToIntInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for DoubleToIntInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_doubleToIntInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_doubleToIntInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DoubleToIntInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_doubleToIntInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_doubleToIntInstruction }
}
antlr_rust::tid!{DoubleToIntInstructionContextExt<'a>}

impl<'input> DoubleToIntInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DoubleToIntInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DoubleToIntInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DoubleToIntInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<DoubleToIntInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_DOUBLE_TO_INT
/// Returns `None` if there is no child corresponding to token OP_DOUBLE_TO_INT
fn OP_DOUBLE_TO_INT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_DOUBLE_TO_INT, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DoubleToIntInstructionContextAttrs<'input> for DoubleToIntInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn doubleToIntInstruction(&mut self,)
	-> Result<Rc<DoubleToIntInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DoubleToIntInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 220, RULE_doubleToIntInstruction);
        let mut _localctx: Rc<DoubleToIntInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1140);
			recog.base.match_token(OP_DOUBLE_TO_INT,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1141);
			recog.leftRegister()?;

			recog.base.set_state(1142);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1143);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- doubleToLongInstruction ----------------
pub type DoubleToLongInstructionContextAll<'input> = DoubleToLongInstructionContext<'input>;


pub type DoubleToLongInstructionContext<'input> = BaseParserRuleContext<'input,DoubleToLongInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct DoubleToLongInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for DoubleToLongInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for DoubleToLongInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_doubleToLongInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_doubleToLongInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DoubleToLongInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_doubleToLongInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_doubleToLongInstruction }
}
antlr_rust::tid!{DoubleToLongInstructionContextExt<'a>}

impl<'input> DoubleToLongInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DoubleToLongInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DoubleToLongInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DoubleToLongInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<DoubleToLongInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_DOUBLE_TO_LONG
/// Returns `None` if there is no child corresponding to token OP_DOUBLE_TO_LONG
fn OP_DOUBLE_TO_LONG(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_DOUBLE_TO_LONG, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DoubleToLongInstructionContextAttrs<'input> for DoubleToLongInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn doubleToLongInstruction(&mut self,)
	-> Result<Rc<DoubleToLongInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DoubleToLongInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 222, RULE_doubleToLongInstruction);
        let mut _localctx: Rc<DoubleToLongInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1145);
			recog.base.match_token(OP_DOUBLE_TO_LONG,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1146);
			recog.leftRegister()?;

			recog.base.set_state(1147);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1148);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- doubleToFloatInstruction ----------------
pub type DoubleToFloatInstructionContextAll<'input> = DoubleToFloatInstructionContext<'input>;


pub type DoubleToFloatInstructionContext<'input> = BaseParserRuleContext<'input,DoubleToFloatInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct DoubleToFloatInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for DoubleToFloatInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for DoubleToFloatInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_doubleToFloatInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_doubleToFloatInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DoubleToFloatInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_doubleToFloatInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_doubleToFloatInstruction }
}
antlr_rust::tid!{DoubleToFloatInstructionContextExt<'a>}

impl<'input> DoubleToFloatInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DoubleToFloatInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DoubleToFloatInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DoubleToFloatInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<DoubleToFloatInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_DOUBLE_TO_FLOAT
/// Returns `None` if there is no child corresponding to token OP_DOUBLE_TO_FLOAT
fn OP_DOUBLE_TO_FLOAT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_DOUBLE_TO_FLOAT, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DoubleToFloatInstructionContextAttrs<'input> for DoubleToFloatInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn doubleToFloatInstruction(&mut self,)
	-> Result<Rc<DoubleToFloatInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DoubleToFloatInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 224, RULE_doubleToFloatInstruction);
        let mut _localctx: Rc<DoubleToFloatInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1150);
			recog.base.match_token(OP_DOUBLE_TO_FLOAT,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1151);
			recog.leftRegister()?;

			recog.base.set_state(1152);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1153);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- intToByteInstruction ----------------
pub type IntToByteInstructionContextAll<'input> = IntToByteInstructionContext<'input>;


pub type IntToByteInstructionContext<'input> = BaseParserRuleContext<'input,IntToByteInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IntToByteInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IntToByteInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IntToByteInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_intToByteInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_intToByteInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IntToByteInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_intToByteInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_intToByteInstruction }
}
antlr_rust::tid!{IntToByteInstructionContextExt<'a>}

impl<'input> IntToByteInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IntToByteInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IntToByteInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IntToByteInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IntToByteInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INT_TO_BYTE
/// Returns `None` if there is no child corresponding to token OP_INT_TO_BYTE
fn OP_INT_TO_BYTE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INT_TO_BYTE, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IntToByteInstructionContextAttrs<'input> for IntToByteInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn intToByteInstruction(&mut self,)
	-> Result<Rc<IntToByteInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IntToByteInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 226, RULE_intToByteInstruction);
        let mut _localctx: Rc<IntToByteInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1155);
			recog.base.match_token(OP_INT_TO_BYTE,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1156);
			recog.leftRegister()?;

			recog.base.set_state(1157);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1158);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- intToCharInstruction ----------------
pub type IntToCharInstructionContextAll<'input> = IntToCharInstructionContext<'input>;


pub type IntToCharInstructionContext<'input> = BaseParserRuleContext<'input,IntToCharInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IntToCharInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IntToCharInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IntToCharInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_intToCharInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_intToCharInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IntToCharInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_intToCharInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_intToCharInstruction }
}
antlr_rust::tid!{IntToCharInstructionContextExt<'a>}

impl<'input> IntToCharInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IntToCharInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IntToCharInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IntToCharInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IntToCharInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INT_TO_CHAR
/// Returns `None` if there is no child corresponding to token OP_INT_TO_CHAR
fn OP_INT_TO_CHAR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INT_TO_CHAR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IntToCharInstructionContextAttrs<'input> for IntToCharInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn intToCharInstruction(&mut self,)
	-> Result<Rc<IntToCharInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IntToCharInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 228, RULE_intToCharInstruction);
        let mut _localctx: Rc<IntToCharInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1160);
			recog.base.match_token(OP_INT_TO_CHAR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1161);
			recog.leftRegister()?;

			recog.base.set_state(1162);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1163);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- intToShortInstruction ----------------
pub type IntToShortInstructionContextAll<'input> = IntToShortInstructionContext<'input>;


pub type IntToShortInstructionContext<'input> = BaseParserRuleContext<'input,IntToShortInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IntToShortInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IntToShortInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IntToShortInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_intToShortInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_intToShortInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IntToShortInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_intToShortInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_intToShortInstruction }
}
antlr_rust::tid!{IntToShortInstructionContextExt<'a>}

impl<'input> IntToShortInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IntToShortInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IntToShortInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IntToShortInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IntToShortInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INT_TO_SHORT
/// Returns `None` if there is no child corresponding to token OP_INT_TO_SHORT
fn OP_INT_TO_SHORT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INT_TO_SHORT, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IntToShortInstructionContextAttrs<'input> for IntToShortInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn intToShortInstruction(&mut self,)
	-> Result<Rc<IntToShortInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IntToShortInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 230, RULE_intToShortInstruction);
        let mut _localctx: Rc<IntToShortInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1165);
			recog.base.match_token(OP_INT_TO_SHORT,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1166);
			recog.leftRegister()?;

			recog.base.set_state(1167);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1168);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifLabel ----------------
pub type IfLabelContextAll<'input> = IfLabelContext<'input>;


pub type IfLabelContext<'input> = BaseParserRuleContext<'input,IfLabelContextExt<'input>>;

#[derive(Clone)]
pub struct IfLabelContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IfLabelContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IfLabelContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifLabel(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_ifLabel(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IfLabelContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifLabel }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifLabel }
}
antlr_rust::tid!{IfLabelContextExt<'a>}

impl<'input> IfLabelContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfLabelContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfLabelContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfLabelContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IfLabelContextExt<'input>>{

fn label(&self) -> Option<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfLabelContextAttrs<'input> for IfLabelContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifLabel(&mut self,)
	-> Result<Rc<IfLabelContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfLabelContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 232, RULE_ifLabel);
        let mut _localctx: Rc<IfLabelContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule label*/
			recog.base.set_state(1170);
			recog.label()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifEqzInstruction ----------------
pub type IfEqzInstructionContextAll<'input> = IfEqzInstructionContext<'input>;


pub type IfEqzInstructionContext<'input> = BaseParserRuleContext<'input,IfEqzInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IfEqzInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IfEqzInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IfEqzInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifEqzInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_ifEqzInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IfEqzInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifEqzInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifEqzInstruction }
}
antlr_rust::tid!{IfEqzInstructionContextExt<'a>}

impl<'input> IfEqzInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfEqzInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfEqzInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfEqzInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IfEqzInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IF_EQZ
/// Returns `None` if there is no child corresponding to token OP_IF_EQZ
fn OP_IF_EQZ(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IF_EQZ, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn ifLabel(&self) -> Option<Rc<IfLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfEqzInstructionContextAttrs<'input> for IfEqzInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifEqzInstruction(&mut self,)
	-> Result<Rc<IfEqzInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfEqzInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 234, RULE_ifEqzInstruction);
        let mut _localctx: Rc<IfEqzInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1172);
			recog.base.match_token(OP_IF_EQZ,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1173);
			recog.registerIdentifier()?;

			recog.base.set_state(1174);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule ifLabel*/
			recog.base.set_state(1175);
			recog.ifLabel()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifNezInstruction ----------------
pub type IfNezInstructionContextAll<'input> = IfNezInstructionContext<'input>;


pub type IfNezInstructionContext<'input> = BaseParserRuleContext<'input,IfNezInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IfNezInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IfNezInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IfNezInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifNezInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_ifNezInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IfNezInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifNezInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifNezInstruction }
}
antlr_rust::tid!{IfNezInstructionContextExt<'a>}

impl<'input> IfNezInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfNezInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfNezInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfNezInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IfNezInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IF_NEZ
/// Returns `None` if there is no child corresponding to token OP_IF_NEZ
fn OP_IF_NEZ(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IF_NEZ, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn ifLabel(&self) -> Option<Rc<IfLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfNezInstructionContextAttrs<'input> for IfNezInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifNezInstruction(&mut self,)
	-> Result<Rc<IfNezInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfNezInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 236, RULE_ifNezInstruction);
        let mut _localctx: Rc<IfNezInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1177);
			recog.base.match_token(OP_IF_NEZ,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1178);
			recog.registerIdentifier()?;

			recog.base.set_state(1179);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule ifLabel*/
			recog.base.set_state(1180);
			recog.ifLabel()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifLtzInstruction ----------------
pub type IfLtzInstructionContextAll<'input> = IfLtzInstructionContext<'input>;


pub type IfLtzInstructionContext<'input> = BaseParserRuleContext<'input,IfLtzInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IfLtzInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IfLtzInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IfLtzInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifLtzInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_ifLtzInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IfLtzInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifLtzInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifLtzInstruction }
}
antlr_rust::tid!{IfLtzInstructionContextExt<'a>}

impl<'input> IfLtzInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfLtzInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfLtzInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfLtzInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IfLtzInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IF_LTZ
/// Returns `None` if there is no child corresponding to token OP_IF_LTZ
fn OP_IF_LTZ(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IF_LTZ, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn ifLabel(&self) -> Option<Rc<IfLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfLtzInstructionContextAttrs<'input> for IfLtzInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifLtzInstruction(&mut self,)
	-> Result<Rc<IfLtzInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfLtzInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 238, RULE_ifLtzInstruction);
        let mut _localctx: Rc<IfLtzInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1182);
			recog.base.match_token(OP_IF_LTZ,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1183);
			recog.registerIdentifier()?;

			recog.base.set_state(1184);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule ifLabel*/
			recog.base.set_state(1185);
			recog.ifLabel()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifGezInstruction ----------------
pub type IfGezInstructionContextAll<'input> = IfGezInstructionContext<'input>;


pub type IfGezInstructionContext<'input> = BaseParserRuleContext<'input,IfGezInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IfGezInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IfGezInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IfGezInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifGezInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_ifGezInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IfGezInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifGezInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifGezInstruction }
}
antlr_rust::tid!{IfGezInstructionContextExt<'a>}

impl<'input> IfGezInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfGezInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfGezInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfGezInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IfGezInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IF_GEZ
/// Returns `None` if there is no child corresponding to token OP_IF_GEZ
fn OP_IF_GEZ(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IF_GEZ, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn ifLabel(&self) -> Option<Rc<IfLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfGezInstructionContextAttrs<'input> for IfGezInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifGezInstruction(&mut self,)
	-> Result<Rc<IfGezInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfGezInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 240, RULE_ifGezInstruction);
        let mut _localctx: Rc<IfGezInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1187);
			recog.base.match_token(OP_IF_GEZ,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1188);
			recog.registerIdentifier()?;

			recog.base.set_state(1189);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule ifLabel*/
			recog.base.set_state(1190);
			recog.ifLabel()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifGtzInstruction ----------------
pub type IfGtzInstructionContextAll<'input> = IfGtzInstructionContext<'input>;


pub type IfGtzInstructionContext<'input> = BaseParserRuleContext<'input,IfGtzInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IfGtzInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IfGtzInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IfGtzInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifGtzInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_ifGtzInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IfGtzInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifGtzInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifGtzInstruction }
}
antlr_rust::tid!{IfGtzInstructionContextExt<'a>}

impl<'input> IfGtzInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfGtzInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfGtzInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfGtzInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IfGtzInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IF_GTZ
/// Returns `None` if there is no child corresponding to token OP_IF_GTZ
fn OP_IF_GTZ(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IF_GTZ, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn ifLabel(&self) -> Option<Rc<IfLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfGtzInstructionContextAttrs<'input> for IfGtzInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifGtzInstruction(&mut self,)
	-> Result<Rc<IfGtzInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfGtzInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 242, RULE_ifGtzInstruction);
        let mut _localctx: Rc<IfGtzInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1192);
			recog.base.match_token(OP_IF_GTZ,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1193);
			recog.registerIdentifier()?;

			recog.base.set_state(1194);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule ifLabel*/
			recog.base.set_state(1195);
			recog.ifLabel()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifLezInstruction ----------------
pub type IfLezInstructionContextAll<'input> = IfLezInstructionContext<'input>;


pub type IfLezInstructionContext<'input> = BaseParserRuleContext<'input,IfLezInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IfLezInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IfLezInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IfLezInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifLezInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_ifLezInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IfLezInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifLezInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifLezInstruction }
}
antlr_rust::tid!{IfLezInstructionContextExt<'a>}

impl<'input> IfLezInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfLezInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfLezInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfLezInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IfLezInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IF_LEZ
/// Returns `None` if there is no child corresponding to token OP_IF_LEZ
fn OP_IF_LEZ(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IF_LEZ, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn ifLabel(&self) -> Option<Rc<IfLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfLezInstructionContextAttrs<'input> for IfLezInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifLezInstruction(&mut self,)
	-> Result<Rc<IfLezInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfLezInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 244, RULE_ifLezInstruction);
        let mut _localctx: Rc<IfLezInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1197);
			recog.base.match_token(OP_IF_LEZ,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1198);
			recog.registerIdentifier()?;

			recog.base.set_state(1199);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule ifLabel*/
			recog.base.set_state(1200);
			recog.ifLabel()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- negIntInstruction ----------------
pub type NegIntInstructionContextAll<'input> = NegIntInstructionContext<'input>;


pub type NegIntInstructionContext<'input> = BaseParserRuleContext<'input,NegIntInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct NegIntInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for NegIntInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for NegIntInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_negIntInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_negIntInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NegIntInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_negIntInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_negIntInstruction }
}
antlr_rust::tid!{NegIntInstructionContextExt<'a>}

impl<'input> NegIntInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NegIntInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NegIntInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NegIntInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<NegIntInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_NEG_INT
/// Returns `None` if there is no child corresponding to token OP_NEG_INT
fn OP_NEG_INT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_NEG_INT, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NegIntInstructionContextAttrs<'input> for NegIntInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn negIntInstruction(&mut self,)
	-> Result<Rc<NegIntInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NegIntInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 246, RULE_negIntInstruction);
        let mut _localctx: Rc<NegIntInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1202);
			recog.base.match_token(OP_NEG_INT,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1203);
			recog.leftRegister()?;

			recog.base.set_state(1204);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1205);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- notIntInstruction ----------------
pub type NotIntInstructionContextAll<'input> = NotIntInstructionContext<'input>;


pub type NotIntInstructionContext<'input> = BaseParserRuleContext<'input,NotIntInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct NotIntInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for NotIntInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for NotIntInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_notIntInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_notIntInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NotIntInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_notIntInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_notIntInstruction }
}
antlr_rust::tid!{NotIntInstructionContextExt<'a>}

impl<'input> NotIntInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NotIntInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NotIntInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NotIntInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<NotIntInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_NOT_INT
/// Returns `None` if there is no child corresponding to token OP_NOT_INT
fn OP_NOT_INT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_NOT_INT, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NotIntInstructionContextAttrs<'input> for NotIntInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn notIntInstruction(&mut self,)
	-> Result<Rc<NotIntInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NotIntInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 248, RULE_notIntInstruction);
        let mut _localctx: Rc<NotIntInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1207);
			recog.base.match_token(OP_NOT_INT,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1208);
			recog.leftRegister()?;

			recog.base.set_state(1209);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1210);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- negLongInstruction ----------------
pub type NegLongInstructionContextAll<'input> = NegLongInstructionContext<'input>;


pub type NegLongInstructionContext<'input> = BaseParserRuleContext<'input,NegLongInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct NegLongInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for NegLongInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for NegLongInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_negLongInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_negLongInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NegLongInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_negLongInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_negLongInstruction }
}
antlr_rust::tid!{NegLongInstructionContextExt<'a>}

impl<'input> NegLongInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NegLongInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NegLongInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NegLongInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<NegLongInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_NEG_LONG
/// Returns `None` if there is no child corresponding to token OP_NEG_LONG
fn OP_NEG_LONG(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_NEG_LONG, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NegLongInstructionContextAttrs<'input> for NegLongInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn negLongInstruction(&mut self,)
	-> Result<Rc<NegLongInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NegLongInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 250, RULE_negLongInstruction);
        let mut _localctx: Rc<NegLongInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1212);
			recog.base.match_token(OP_NEG_LONG,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1213);
			recog.leftRegister()?;

			recog.base.set_state(1214);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1215);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- notLongInstruction ----------------
pub type NotLongInstructionContextAll<'input> = NotLongInstructionContext<'input>;


pub type NotLongInstructionContext<'input> = BaseParserRuleContext<'input,NotLongInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct NotLongInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for NotLongInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for NotLongInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_notLongInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_notLongInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NotLongInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_notLongInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_notLongInstruction }
}
antlr_rust::tid!{NotLongInstructionContextExt<'a>}

impl<'input> NotLongInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NotLongInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NotLongInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NotLongInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<NotLongInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_NOT_LONG
/// Returns `None` if there is no child corresponding to token OP_NOT_LONG
fn OP_NOT_LONG(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_NOT_LONG, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NotLongInstructionContextAttrs<'input> for NotLongInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn notLongInstruction(&mut self,)
	-> Result<Rc<NotLongInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NotLongInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 252, RULE_notLongInstruction);
        let mut _localctx: Rc<NotLongInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1217);
			recog.base.match_token(OP_NOT_LONG,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1218);
			recog.leftRegister()?;

			recog.base.set_state(1219);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1220);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- negFloatInstruction ----------------
pub type NegFloatInstructionContextAll<'input> = NegFloatInstructionContext<'input>;


pub type NegFloatInstructionContext<'input> = BaseParserRuleContext<'input,NegFloatInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct NegFloatInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for NegFloatInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for NegFloatInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_negFloatInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_negFloatInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NegFloatInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_negFloatInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_negFloatInstruction }
}
antlr_rust::tid!{NegFloatInstructionContextExt<'a>}

impl<'input> NegFloatInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NegFloatInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NegFloatInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NegFloatInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<NegFloatInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_NEG_FLOAT
/// Returns `None` if there is no child corresponding to token OP_NEG_FLOAT
fn OP_NEG_FLOAT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_NEG_FLOAT, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NegFloatInstructionContextAttrs<'input> for NegFloatInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn negFloatInstruction(&mut self,)
	-> Result<Rc<NegFloatInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NegFloatInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 254, RULE_negFloatInstruction);
        let mut _localctx: Rc<NegFloatInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1222);
			recog.base.match_token(OP_NEG_FLOAT,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1223);
			recog.leftRegister()?;

			recog.base.set_state(1224);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1225);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- negDoubleInstruction ----------------
pub type NegDoubleInstructionContextAll<'input> = NegDoubleInstructionContext<'input>;


pub type NegDoubleInstructionContext<'input> = BaseParserRuleContext<'input,NegDoubleInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct NegDoubleInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for NegDoubleInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for NegDoubleInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_negDoubleInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_negDoubleInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NegDoubleInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_negDoubleInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_negDoubleInstruction }
}
antlr_rust::tid!{NegDoubleInstructionContextExt<'a>}

impl<'input> NegDoubleInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NegDoubleInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NegDoubleInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NegDoubleInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<NegDoubleInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_NEG_DOUBLE
/// Returns `None` if there is no child corresponding to token OP_NEG_DOUBLE
fn OP_NEG_DOUBLE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_NEG_DOUBLE, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NegDoubleInstructionContextAttrs<'input> for NegDoubleInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn negDoubleInstruction(&mut self,)
	-> Result<Rc<NegDoubleInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NegDoubleInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 256, RULE_negDoubleInstruction);
        let mut _localctx: Rc<NegDoubleInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1227);
			recog.base.match_token(OP_NEG_DOUBLE,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1228);
			recog.leftRegister()?;

			recog.base.set_state(1229);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1230);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifEqInstruction ----------------
pub type IfEqInstructionContextAll<'input> = IfEqInstructionContext<'input>;


pub type IfEqInstructionContext<'input> = BaseParserRuleContext<'input,IfEqInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IfEqInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IfEqInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IfEqInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifEqInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_ifEqInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IfEqInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifEqInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifEqInstruction }
}
antlr_rust::tid!{IfEqInstructionContextExt<'a>}

impl<'input> IfEqInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfEqInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfEqInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfEqInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IfEqInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IF_EQ
/// Returns `None` if there is no child corresponding to token OP_IF_EQ
fn OP_IF_EQ(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IF_EQ, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifLabel(&self) -> Option<Rc<IfLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfEqInstructionContextAttrs<'input> for IfEqInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifEqInstruction(&mut self,)
	-> Result<Rc<IfEqInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfEqInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 258, RULE_ifEqInstruction);
        let mut _localctx: Rc<IfEqInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1232);
			recog.base.match_token(OP_IF_EQ,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1233);
			recog.leftRegister()?;

			recog.base.set_state(1234);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1235);
			recog.rightRegister()?;

			recog.base.set_state(1236);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule ifLabel*/
			recog.base.set_state(1237);
			recog.ifLabel()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifNeInstruction ----------------
pub type IfNeInstructionContextAll<'input> = IfNeInstructionContext<'input>;


pub type IfNeInstructionContext<'input> = BaseParserRuleContext<'input,IfNeInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IfNeInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IfNeInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IfNeInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifNeInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_ifNeInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IfNeInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifNeInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifNeInstruction }
}
antlr_rust::tid!{IfNeInstructionContextExt<'a>}

impl<'input> IfNeInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfNeInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfNeInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfNeInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IfNeInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IF_NE
/// Returns `None` if there is no child corresponding to token OP_IF_NE
fn OP_IF_NE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IF_NE, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifLabel(&self) -> Option<Rc<IfLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfNeInstructionContextAttrs<'input> for IfNeInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifNeInstruction(&mut self,)
	-> Result<Rc<IfNeInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfNeInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 260, RULE_ifNeInstruction);
        let mut _localctx: Rc<IfNeInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1239);
			recog.base.match_token(OP_IF_NE,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1240);
			recog.leftRegister()?;

			recog.base.set_state(1241);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1242);
			recog.rightRegister()?;

			recog.base.set_state(1243);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule ifLabel*/
			recog.base.set_state(1244);
			recog.ifLabel()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifLtInstruction ----------------
pub type IfLtInstructionContextAll<'input> = IfLtInstructionContext<'input>;


pub type IfLtInstructionContext<'input> = BaseParserRuleContext<'input,IfLtInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IfLtInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IfLtInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IfLtInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifLtInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_ifLtInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IfLtInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifLtInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifLtInstruction }
}
antlr_rust::tid!{IfLtInstructionContextExt<'a>}

impl<'input> IfLtInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfLtInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfLtInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfLtInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IfLtInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IF_LT
/// Returns `None` if there is no child corresponding to token OP_IF_LT
fn OP_IF_LT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IF_LT, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifLabel(&self) -> Option<Rc<IfLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfLtInstructionContextAttrs<'input> for IfLtInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifLtInstruction(&mut self,)
	-> Result<Rc<IfLtInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfLtInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 262, RULE_ifLtInstruction);
        let mut _localctx: Rc<IfLtInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1246);
			recog.base.match_token(OP_IF_LT,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1247);
			recog.leftRegister()?;

			recog.base.set_state(1248);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1249);
			recog.rightRegister()?;

			recog.base.set_state(1250);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule ifLabel*/
			recog.base.set_state(1251);
			recog.ifLabel()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifGeInstruction ----------------
pub type IfGeInstructionContextAll<'input> = IfGeInstructionContext<'input>;


pub type IfGeInstructionContext<'input> = BaseParserRuleContext<'input,IfGeInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IfGeInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IfGeInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IfGeInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifGeInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_ifGeInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IfGeInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifGeInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifGeInstruction }
}
antlr_rust::tid!{IfGeInstructionContextExt<'a>}

impl<'input> IfGeInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfGeInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfGeInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfGeInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IfGeInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IF_GE
/// Returns `None` if there is no child corresponding to token OP_IF_GE
fn OP_IF_GE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IF_GE, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifLabel(&self) -> Option<Rc<IfLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfGeInstructionContextAttrs<'input> for IfGeInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifGeInstruction(&mut self,)
	-> Result<Rc<IfGeInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfGeInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 264, RULE_ifGeInstruction);
        let mut _localctx: Rc<IfGeInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1253);
			recog.base.match_token(OP_IF_GE,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1254);
			recog.leftRegister()?;

			recog.base.set_state(1255);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1256);
			recog.rightRegister()?;

			recog.base.set_state(1257);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule ifLabel*/
			recog.base.set_state(1258);
			recog.ifLabel()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifGtInstruction ----------------
pub type IfGtInstructionContextAll<'input> = IfGtInstructionContext<'input>;


pub type IfGtInstructionContext<'input> = BaseParserRuleContext<'input,IfGtInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IfGtInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IfGtInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IfGtInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifGtInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_ifGtInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IfGtInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifGtInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifGtInstruction }
}
antlr_rust::tid!{IfGtInstructionContextExt<'a>}

impl<'input> IfGtInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfGtInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfGtInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfGtInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IfGtInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IF_GT
/// Returns `None` if there is no child corresponding to token OP_IF_GT
fn OP_IF_GT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IF_GT, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifLabel(&self) -> Option<Rc<IfLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfGtInstructionContextAttrs<'input> for IfGtInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifGtInstruction(&mut self,)
	-> Result<Rc<IfGtInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfGtInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 266, RULE_ifGtInstruction);
        let mut _localctx: Rc<IfGtInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1260);
			recog.base.match_token(OP_IF_GT,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1261);
			recog.leftRegister()?;

			recog.base.set_state(1262);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1263);
			recog.rightRegister()?;

			recog.base.set_state(1264);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule ifLabel*/
			recog.base.set_state(1265);
			recog.ifLabel()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ifLeInstruction ----------------
pub type IfLeInstructionContextAll<'input> = IfLeInstructionContext<'input>;


pub type IfLeInstructionContext<'input> = BaseParserRuleContext<'input,IfLeInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IfLeInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IfLeInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IfLeInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ifLeInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_ifLeInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IfLeInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ifLeInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ifLeInstruction }
}
antlr_rust::tid!{IfLeInstructionContextExt<'a>}

impl<'input> IfLeInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IfLeInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IfLeInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IfLeInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IfLeInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IF_LE
/// Returns `None` if there is no child corresponding to token OP_IF_LE
fn OP_IF_LE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IF_LE, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifLabel(&self) -> Option<Rc<IfLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IfLeInstructionContextAttrs<'input> for IfLeInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ifLeInstruction(&mut self,)
	-> Result<Rc<IfLeInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IfLeInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 268, RULE_ifLeInstruction);
        let mut _localctx: Rc<IfLeInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1267);
			recog.base.match_token(OP_IF_LE,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1268);
			recog.leftRegister()?;

			recog.base.set_state(1269);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1270);
			recog.rightRegister()?;

			recog.base.set_state(1271);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule ifLabel*/
			recog.base.set_state(1272);
			recog.ifLabel()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- addInt2addrInstruction ----------------
pub type AddInt2addrInstructionContextAll<'input> = AddInt2addrInstructionContext<'input>;


pub type AddInt2addrInstructionContext<'input> = BaseParserRuleContext<'input,AddInt2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AddInt2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AddInt2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AddInt2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_addInt2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_addInt2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AddInt2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_addInt2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_addInt2addrInstruction }
}
antlr_rust::tid!{AddInt2addrInstructionContextExt<'a>}

impl<'input> AddInt2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AddInt2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AddInt2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AddInt2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AddInt2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_ADD_INT_2ADDR
/// Returns `None` if there is no child corresponding to token OP_ADD_INT_2ADDR
fn OP_ADD_INT_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_ADD_INT_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AddInt2addrInstructionContextAttrs<'input> for AddInt2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn addInt2addrInstruction(&mut self,)
	-> Result<Rc<AddInt2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AddInt2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 270, RULE_addInt2addrInstruction);
        let mut _localctx: Rc<AddInt2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1274);
			recog.base.match_token(OP_ADD_INT_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1275);
			recog.leftRegister()?;

			recog.base.set_state(1276);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1277);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- subInt2addrInstruction ----------------
pub type SubInt2addrInstructionContextAll<'input> = SubInt2addrInstructionContext<'input>;


pub type SubInt2addrInstructionContext<'input> = BaseParserRuleContext<'input,SubInt2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SubInt2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SubInt2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SubInt2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_subInt2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_subInt2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SubInt2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_subInt2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_subInt2addrInstruction }
}
antlr_rust::tid!{SubInt2addrInstructionContextExt<'a>}

impl<'input> SubInt2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SubInt2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SubInt2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SubInt2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SubInt2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SUB_INT_2ADDR
/// Returns `None` if there is no child corresponding to token OP_SUB_INT_2ADDR
fn OP_SUB_INT_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SUB_INT_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SubInt2addrInstructionContextAttrs<'input> for SubInt2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn subInt2addrInstruction(&mut self,)
	-> Result<Rc<SubInt2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SubInt2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 272, RULE_subInt2addrInstruction);
        let mut _localctx: Rc<SubInt2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1279);
			recog.base.match_token(OP_SUB_INT_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1280);
			recog.leftRegister()?;

			recog.base.set_state(1281);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1282);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- mulInt2addrInstruction ----------------
pub type MulInt2addrInstructionContextAll<'input> = MulInt2addrInstructionContext<'input>;


pub type MulInt2addrInstructionContext<'input> = BaseParserRuleContext<'input,MulInt2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MulInt2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MulInt2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MulInt2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_mulInt2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_mulInt2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MulInt2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_mulInt2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_mulInt2addrInstruction }
}
antlr_rust::tid!{MulInt2addrInstructionContextExt<'a>}

impl<'input> MulInt2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MulInt2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MulInt2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MulInt2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MulInt2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MUL_INT_2ADDR
/// Returns `None` if there is no child corresponding to token OP_MUL_INT_2ADDR
fn OP_MUL_INT_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MUL_INT_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MulInt2addrInstructionContextAttrs<'input> for MulInt2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn mulInt2addrInstruction(&mut self,)
	-> Result<Rc<MulInt2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MulInt2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 274, RULE_mulInt2addrInstruction);
        let mut _localctx: Rc<MulInt2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1284);
			recog.base.match_token(OP_MUL_INT_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1285);
			recog.leftRegister()?;

			recog.base.set_state(1286);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1287);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- divInt2addrInstruction ----------------
pub type DivInt2addrInstructionContextAll<'input> = DivInt2addrInstructionContext<'input>;


pub type DivInt2addrInstructionContext<'input> = BaseParserRuleContext<'input,DivInt2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct DivInt2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for DivInt2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for DivInt2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_divInt2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_divInt2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DivInt2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_divInt2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_divInt2addrInstruction }
}
antlr_rust::tid!{DivInt2addrInstructionContextExt<'a>}

impl<'input> DivInt2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DivInt2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DivInt2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DivInt2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<DivInt2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_DIV_INT_2ADDR
/// Returns `None` if there is no child corresponding to token OP_DIV_INT_2ADDR
fn OP_DIV_INT_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_DIV_INT_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DivInt2addrInstructionContextAttrs<'input> for DivInt2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn divInt2addrInstruction(&mut self,)
	-> Result<Rc<DivInt2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DivInt2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 276, RULE_divInt2addrInstruction);
        let mut _localctx: Rc<DivInt2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1289);
			recog.base.match_token(OP_DIV_INT_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1290);
			recog.leftRegister()?;

			recog.base.set_state(1291);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1292);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- remInt2addrInstruction ----------------
pub type RemInt2addrInstructionContextAll<'input> = RemInt2addrInstructionContext<'input>;


pub type RemInt2addrInstructionContext<'input> = BaseParserRuleContext<'input,RemInt2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct RemInt2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for RemInt2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for RemInt2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_remInt2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_remInt2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RemInt2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_remInt2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_remInt2addrInstruction }
}
antlr_rust::tid!{RemInt2addrInstructionContextExt<'a>}

impl<'input> RemInt2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RemInt2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RemInt2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RemInt2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<RemInt2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_REM_INT_2ADDR
/// Returns `None` if there is no child corresponding to token OP_REM_INT_2ADDR
fn OP_REM_INT_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_REM_INT_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RemInt2addrInstructionContextAttrs<'input> for RemInt2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn remInt2addrInstruction(&mut self,)
	-> Result<Rc<RemInt2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RemInt2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 278, RULE_remInt2addrInstruction);
        let mut _localctx: Rc<RemInt2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1294);
			recog.base.match_token(OP_REM_INT_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1295);
			recog.leftRegister()?;

			recog.base.set_state(1296);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1297);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- andInt2addrInstruction ----------------
pub type AndInt2addrInstructionContextAll<'input> = AndInt2addrInstructionContext<'input>;


pub type AndInt2addrInstructionContext<'input> = BaseParserRuleContext<'input,AndInt2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AndInt2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AndInt2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AndInt2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_andInt2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_andInt2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AndInt2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_andInt2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_andInt2addrInstruction }
}
antlr_rust::tid!{AndInt2addrInstructionContextExt<'a>}

impl<'input> AndInt2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AndInt2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AndInt2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AndInt2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AndInt2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_AND_INT_2ADDR
/// Returns `None` if there is no child corresponding to token OP_AND_INT_2ADDR
fn OP_AND_INT_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_AND_INT_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AndInt2addrInstructionContextAttrs<'input> for AndInt2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn andInt2addrInstruction(&mut self,)
	-> Result<Rc<AndInt2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AndInt2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 280, RULE_andInt2addrInstruction);
        let mut _localctx: Rc<AndInt2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1299);
			recog.base.match_token(OP_AND_INT_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1300);
			recog.leftRegister()?;

			recog.base.set_state(1301);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1302);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- orInt2addrInstruction ----------------
pub type OrInt2addrInstructionContextAll<'input> = OrInt2addrInstructionContext<'input>;


pub type OrInt2addrInstructionContext<'input> = BaseParserRuleContext<'input,OrInt2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct OrInt2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for OrInt2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for OrInt2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_orInt2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_orInt2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for OrInt2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_orInt2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_orInt2addrInstruction }
}
antlr_rust::tid!{OrInt2addrInstructionContextExt<'a>}

impl<'input> OrInt2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OrInt2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OrInt2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OrInt2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<OrInt2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_OR_INT_2ADDR
/// Returns `None` if there is no child corresponding to token OP_OR_INT_2ADDR
fn OP_OR_INT_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_OR_INT_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> OrInt2addrInstructionContextAttrs<'input> for OrInt2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn orInt2addrInstruction(&mut self,)
	-> Result<Rc<OrInt2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OrInt2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 282, RULE_orInt2addrInstruction);
        let mut _localctx: Rc<OrInt2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1304);
			recog.base.match_token(OP_OR_INT_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1305);
			recog.leftRegister()?;

			recog.base.set_state(1306);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1307);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- xorInt2addrInstruction ----------------
pub type XorInt2addrInstructionContextAll<'input> = XorInt2addrInstructionContext<'input>;


pub type XorInt2addrInstructionContext<'input> = BaseParserRuleContext<'input,XorInt2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct XorInt2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for XorInt2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for XorInt2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_xorInt2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_xorInt2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for XorInt2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_xorInt2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_xorInt2addrInstruction }
}
antlr_rust::tid!{XorInt2addrInstructionContextExt<'a>}

impl<'input> XorInt2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<XorInt2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,XorInt2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait XorInt2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<XorInt2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_XOR_INT_2ADDR
/// Returns `None` if there is no child corresponding to token OP_XOR_INT_2ADDR
fn OP_XOR_INT_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_XOR_INT_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> XorInt2addrInstructionContextAttrs<'input> for XorInt2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn xorInt2addrInstruction(&mut self,)
	-> Result<Rc<XorInt2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = XorInt2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 284, RULE_xorInt2addrInstruction);
        let mut _localctx: Rc<XorInt2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1309);
			recog.base.match_token(OP_XOR_INT_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1310);
			recog.leftRegister()?;

			recog.base.set_state(1311);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1312);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- shlInt2addrInstruction ----------------
pub type ShlInt2addrInstructionContextAll<'input> = ShlInt2addrInstructionContext<'input>;


pub type ShlInt2addrInstructionContext<'input> = BaseParserRuleContext<'input,ShlInt2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ShlInt2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ShlInt2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ShlInt2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_shlInt2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_shlInt2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ShlInt2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_shlInt2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_shlInt2addrInstruction }
}
antlr_rust::tid!{ShlInt2addrInstructionContextExt<'a>}

impl<'input> ShlInt2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ShlInt2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ShlInt2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ShlInt2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ShlInt2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SHL_INT_2ADDR
/// Returns `None` if there is no child corresponding to token OP_SHL_INT_2ADDR
fn OP_SHL_INT_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SHL_INT_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ShlInt2addrInstructionContextAttrs<'input> for ShlInt2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn shlInt2addrInstruction(&mut self,)
	-> Result<Rc<ShlInt2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ShlInt2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 286, RULE_shlInt2addrInstruction);
        let mut _localctx: Rc<ShlInt2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1314);
			recog.base.match_token(OP_SHL_INT_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1315);
			recog.leftRegister()?;

			recog.base.set_state(1316);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1317);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- shrInt2addrInstruction ----------------
pub type ShrInt2addrInstructionContextAll<'input> = ShrInt2addrInstructionContext<'input>;


pub type ShrInt2addrInstructionContext<'input> = BaseParserRuleContext<'input,ShrInt2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ShrInt2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ShrInt2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ShrInt2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_shrInt2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_shrInt2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ShrInt2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_shrInt2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_shrInt2addrInstruction }
}
antlr_rust::tid!{ShrInt2addrInstructionContextExt<'a>}

impl<'input> ShrInt2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ShrInt2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ShrInt2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ShrInt2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ShrInt2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SHR_INT_2ADDR
/// Returns `None` if there is no child corresponding to token OP_SHR_INT_2ADDR
fn OP_SHR_INT_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SHR_INT_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ShrInt2addrInstructionContextAttrs<'input> for ShrInt2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn shrInt2addrInstruction(&mut self,)
	-> Result<Rc<ShrInt2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ShrInt2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 288, RULE_shrInt2addrInstruction);
        let mut _localctx: Rc<ShrInt2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1319);
			recog.base.match_token(OP_SHR_INT_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1320);
			recog.leftRegister()?;

			recog.base.set_state(1321);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1322);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ushrInt2addrInstruction ----------------
pub type UshrInt2addrInstructionContextAll<'input> = UshrInt2addrInstructionContext<'input>;


pub type UshrInt2addrInstructionContext<'input> = BaseParserRuleContext<'input,UshrInt2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct UshrInt2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for UshrInt2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for UshrInt2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ushrInt2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_ushrInt2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UshrInt2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ushrInt2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ushrInt2addrInstruction }
}
antlr_rust::tid!{UshrInt2addrInstructionContextExt<'a>}

impl<'input> UshrInt2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UshrInt2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UshrInt2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UshrInt2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<UshrInt2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_USHR_INT_2ADDR
/// Returns `None` if there is no child corresponding to token OP_USHR_INT_2ADDR
fn OP_USHR_INT_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_USHR_INT_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UshrInt2addrInstructionContextAttrs<'input> for UshrInt2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ushrInt2addrInstruction(&mut self,)
	-> Result<Rc<UshrInt2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UshrInt2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 290, RULE_ushrInt2addrInstruction);
        let mut _localctx: Rc<UshrInt2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1324);
			recog.base.match_token(OP_USHR_INT_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1325);
			recog.leftRegister()?;

			recog.base.set_state(1326);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1327);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- addLong2addrInstruction ----------------
pub type AddLong2addrInstructionContextAll<'input> = AddLong2addrInstructionContext<'input>;


pub type AddLong2addrInstructionContext<'input> = BaseParserRuleContext<'input,AddLong2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AddLong2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AddLong2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AddLong2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_addLong2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_addLong2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AddLong2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_addLong2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_addLong2addrInstruction }
}
antlr_rust::tid!{AddLong2addrInstructionContextExt<'a>}

impl<'input> AddLong2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AddLong2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AddLong2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AddLong2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AddLong2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_ADD_LONG_2ADDR
/// Returns `None` if there is no child corresponding to token OP_ADD_LONG_2ADDR
fn OP_ADD_LONG_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_ADD_LONG_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AddLong2addrInstructionContextAttrs<'input> for AddLong2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn addLong2addrInstruction(&mut self,)
	-> Result<Rc<AddLong2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AddLong2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 292, RULE_addLong2addrInstruction);
        let mut _localctx: Rc<AddLong2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1329);
			recog.base.match_token(OP_ADD_LONG_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1330);
			recog.leftRegister()?;

			recog.base.set_state(1331);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1332);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- subLong2addrInstruction ----------------
pub type SubLong2addrInstructionContextAll<'input> = SubLong2addrInstructionContext<'input>;


pub type SubLong2addrInstructionContext<'input> = BaseParserRuleContext<'input,SubLong2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SubLong2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SubLong2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SubLong2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_subLong2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_subLong2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SubLong2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_subLong2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_subLong2addrInstruction }
}
antlr_rust::tid!{SubLong2addrInstructionContextExt<'a>}

impl<'input> SubLong2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SubLong2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SubLong2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SubLong2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SubLong2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SUB_LONG_2ADDR
/// Returns `None` if there is no child corresponding to token OP_SUB_LONG_2ADDR
fn OP_SUB_LONG_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SUB_LONG_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SubLong2addrInstructionContextAttrs<'input> for SubLong2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn subLong2addrInstruction(&mut self,)
	-> Result<Rc<SubLong2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SubLong2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 294, RULE_subLong2addrInstruction);
        let mut _localctx: Rc<SubLong2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1334);
			recog.base.match_token(OP_SUB_LONG_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1335);
			recog.leftRegister()?;

			recog.base.set_state(1336);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1337);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- mulLong2addrInstruction ----------------
pub type MulLong2addrInstructionContextAll<'input> = MulLong2addrInstructionContext<'input>;


pub type MulLong2addrInstructionContext<'input> = BaseParserRuleContext<'input,MulLong2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MulLong2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MulLong2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MulLong2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_mulLong2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_mulLong2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MulLong2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_mulLong2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_mulLong2addrInstruction }
}
antlr_rust::tid!{MulLong2addrInstructionContextExt<'a>}

impl<'input> MulLong2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MulLong2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MulLong2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MulLong2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MulLong2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MUL_LONG_2ADDR
/// Returns `None` if there is no child corresponding to token OP_MUL_LONG_2ADDR
fn OP_MUL_LONG_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MUL_LONG_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MulLong2addrInstructionContextAttrs<'input> for MulLong2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn mulLong2addrInstruction(&mut self,)
	-> Result<Rc<MulLong2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MulLong2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 296, RULE_mulLong2addrInstruction);
        let mut _localctx: Rc<MulLong2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1339);
			recog.base.match_token(OP_MUL_LONG_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1340);
			recog.leftRegister()?;

			recog.base.set_state(1341);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1342);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- divLong2addrInstruction ----------------
pub type DivLong2addrInstructionContextAll<'input> = DivLong2addrInstructionContext<'input>;


pub type DivLong2addrInstructionContext<'input> = BaseParserRuleContext<'input,DivLong2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct DivLong2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for DivLong2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for DivLong2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_divLong2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_divLong2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DivLong2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_divLong2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_divLong2addrInstruction }
}
antlr_rust::tid!{DivLong2addrInstructionContextExt<'a>}

impl<'input> DivLong2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DivLong2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DivLong2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DivLong2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<DivLong2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_DIV_LONG_2ADDR
/// Returns `None` if there is no child corresponding to token OP_DIV_LONG_2ADDR
fn OP_DIV_LONG_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_DIV_LONG_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DivLong2addrInstructionContextAttrs<'input> for DivLong2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn divLong2addrInstruction(&mut self,)
	-> Result<Rc<DivLong2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DivLong2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 298, RULE_divLong2addrInstruction);
        let mut _localctx: Rc<DivLong2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1344);
			recog.base.match_token(OP_DIV_LONG_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1345);
			recog.leftRegister()?;

			recog.base.set_state(1346);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1347);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- remLong2addrInstruction ----------------
pub type RemLong2addrInstructionContextAll<'input> = RemLong2addrInstructionContext<'input>;


pub type RemLong2addrInstructionContext<'input> = BaseParserRuleContext<'input,RemLong2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct RemLong2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for RemLong2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for RemLong2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_remLong2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_remLong2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RemLong2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_remLong2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_remLong2addrInstruction }
}
antlr_rust::tid!{RemLong2addrInstructionContextExt<'a>}

impl<'input> RemLong2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RemLong2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RemLong2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RemLong2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<RemLong2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_REM_LONG_2ADDR
/// Returns `None` if there is no child corresponding to token OP_REM_LONG_2ADDR
fn OP_REM_LONG_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_REM_LONG_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RemLong2addrInstructionContextAttrs<'input> for RemLong2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn remLong2addrInstruction(&mut self,)
	-> Result<Rc<RemLong2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RemLong2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 300, RULE_remLong2addrInstruction);
        let mut _localctx: Rc<RemLong2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1349);
			recog.base.match_token(OP_REM_LONG_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1350);
			recog.leftRegister()?;

			recog.base.set_state(1351);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1352);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- andLong2addrInstruction ----------------
pub type AndLong2addrInstructionContextAll<'input> = AndLong2addrInstructionContext<'input>;


pub type AndLong2addrInstructionContext<'input> = BaseParserRuleContext<'input,AndLong2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AndLong2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AndLong2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AndLong2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_andLong2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_andLong2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AndLong2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_andLong2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_andLong2addrInstruction }
}
antlr_rust::tid!{AndLong2addrInstructionContextExt<'a>}

impl<'input> AndLong2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AndLong2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AndLong2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AndLong2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AndLong2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_AND_LONG_2ADDR
/// Returns `None` if there is no child corresponding to token OP_AND_LONG_2ADDR
fn OP_AND_LONG_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_AND_LONG_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AndLong2addrInstructionContextAttrs<'input> for AndLong2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn andLong2addrInstruction(&mut self,)
	-> Result<Rc<AndLong2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AndLong2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 302, RULE_andLong2addrInstruction);
        let mut _localctx: Rc<AndLong2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1354);
			recog.base.match_token(OP_AND_LONG_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1355);
			recog.leftRegister()?;

			recog.base.set_state(1356);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1357);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- orLong2addrInstruction ----------------
pub type OrLong2addrInstructionContextAll<'input> = OrLong2addrInstructionContext<'input>;


pub type OrLong2addrInstructionContext<'input> = BaseParserRuleContext<'input,OrLong2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct OrLong2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for OrLong2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for OrLong2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_orLong2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_orLong2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for OrLong2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_orLong2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_orLong2addrInstruction }
}
antlr_rust::tid!{OrLong2addrInstructionContextExt<'a>}

impl<'input> OrLong2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OrLong2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OrLong2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OrLong2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<OrLong2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_OR_LONG_2ADDR
/// Returns `None` if there is no child corresponding to token OP_OR_LONG_2ADDR
fn OP_OR_LONG_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_OR_LONG_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> OrLong2addrInstructionContextAttrs<'input> for OrLong2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn orLong2addrInstruction(&mut self,)
	-> Result<Rc<OrLong2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OrLong2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 304, RULE_orLong2addrInstruction);
        let mut _localctx: Rc<OrLong2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1359);
			recog.base.match_token(OP_OR_LONG_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1360);
			recog.leftRegister()?;

			recog.base.set_state(1361);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1362);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- xorLong2addrInstruction ----------------
pub type XorLong2addrInstructionContextAll<'input> = XorLong2addrInstructionContext<'input>;


pub type XorLong2addrInstructionContext<'input> = BaseParserRuleContext<'input,XorLong2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct XorLong2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for XorLong2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for XorLong2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_xorLong2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_xorLong2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for XorLong2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_xorLong2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_xorLong2addrInstruction }
}
antlr_rust::tid!{XorLong2addrInstructionContextExt<'a>}

impl<'input> XorLong2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<XorLong2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,XorLong2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait XorLong2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<XorLong2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_XOR_LONG_2ADDR
/// Returns `None` if there is no child corresponding to token OP_XOR_LONG_2ADDR
fn OP_XOR_LONG_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_XOR_LONG_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> XorLong2addrInstructionContextAttrs<'input> for XorLong2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn xorLong2addrInstruction(&mut self,)
	-> Result<Rc<XorLong2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = XorLong2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 306, RULE_xorLong2addrInstruction);
        let mut _localctx: Rc<XorLong2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1364);
			recog.base.match_token(OP_XOR_LONG_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1365);
			recog.leftRegister()?;

			recog.base.set_state(1366);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1367);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- shlLong2addrInstruction ----------------
pub type ShlLong2addrInstructionContextAll<'input> = ShlLong2addrInstructionContext<'input>;


pub type ShlLong2addrInstructionContext<'input> = BaseParserRuleContext<'input,ShlLong2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ShlLong2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ShlLong2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ShlLong2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_shlLong2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_shlLong2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ShlLong2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_shlLong2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_shlLong2addrInstruction }
}
antlr_rust::tid!{ShlLong2addrInstructionContextExt<'a>}

impl<'input> ShlLong2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ShlLong2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ShlLong2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ShlLong2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ShlLong2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SHL_LONG_2ADDR
/// Returns `None` if there is no child corresponding to token OP_SHL_LONG_2ADDR
fn OP_SHL_LONG_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SHL_LONG_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ShlLong2addrInstructionContextAttrs<'input> for ShlLong2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn shlLong2addrInstruction(&mut self,)
	-> Result<Rc<ShlLong2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ShlLong2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 308, RULE_shlLong2addrInstruction);
        let mut _localctx: Rc<ShlLong2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1369);
			recog.base.match_token(OP_SHL_LONG_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1370);
			recog.leftRegister()?;

			recog.base.set_state(1371);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1372);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- shrLong2addrInstruction ----------------
pub type ShrLong2addrInstructionContextAll<'input> = ShrLong2addrInstructionContext<'input>;


pub type ShrLong2addrInstructionContext<'input> = BaseParserRuleContext<'input,ShrLong2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ShrLong2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ShrLong2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ShrLong2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_shrLong2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_shrLong2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ShrLong2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_shrLong2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_shrLong2addrInstruction }
}
antlr_rust::tid!{ShrLong2addrInstructionContextExt<'a>}

impl<'input> ShrLong2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ShrLong2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ShrLong2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ShrLong2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ShrLong2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SHR_LONG_2ADDR
/// Returns `None` if there is no child corresponding to token OP_SHR_LONG_2ADDR
fn OP_SHR_LONG_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SHR_LONG_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ShrLong2addrInstructionContextAttrs<'input> for ShrLong2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn shrLong2addrInstruction(&mut self,)
	-> Result<Rc<ShrLong2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ShrLong2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 310, RULE_shrLong2addrInstruction);
        let mut _localctx: Rc<ShrLong2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1374);
			recog.base.match_token(OP_SHR_LONG_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1375);
			recog.leftRegister()?;

			recog.base.set_state(1376);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1377);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ushrLong2addrInstruction ----------------
pub type UshrLong2addrInstructionContextAll<'input> = UshrLong2addrInstructionContext<'input>;


pub type UshrLong2addrInstructionContext<'input> = BaseParserRuleContext<'input,UshrLong2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct UshrLong2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for UshrLong2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for UshrLong2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ushrLong2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_ushrLong2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UshrLong2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ushrLong2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ushrLong2addrInstruction }
}
antlr_rust::tid!{UshrLong2addrInstructionContextExt<'a>}

impl<'input> UshrLong2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UshrLong2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UshrLong2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UshrLong2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<UshrLong2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_USHR_LONG_2ADDR
/// Returns `None` if there is no child corresponding to token OP_USHR_LONG_2ADDR
fn OP_USHR_LONG_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_USHR_LONG_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UshrLong2addrInstructionContextAttrs<'input> for UshrLong2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ushrLong2addrInstruction(&mut self,)
	-> Result<Rc<UshrLong2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UshrLong2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 312, RULE_ushrLong2addrInstruction);
        let mut _localctx: Rc<UshrLong2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1379);
			recog.base.match_token(OP_USHR_LONG_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1380);
			recog.leftRegister()?;

			recog.base.set_state(1381);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1382);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- addFloat2addrInstruction ----------------
pub type AddFloat2addrInstructionContextAll<'input> = AddFloat2addrInstructionContext<'input>;


pub type AddFloat2addrInstructionContext<'input> = BaseParserRuleContext<'input,AddFloat2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AddFloat2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AddFloat2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AddFloat2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_addFloat2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_addFloat2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AddFloat2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_addFloat2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_addFloat2addrInstruction }
}
antlr_rust::tid!{AddFloat2addrInstructionContextExt<'a>}

impl<'input> AddFloat2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AddFloat2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AddFloat2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AddFloat2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AddFloat2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_ADD_FLOAT_2ADDR
/// Returns `None` if there is no child corresponding to token OP_ADD_FLOAT_2ADDR
fn OP_ADD_FLOAT_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_ADD_FLOAT_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AddFloat2addrInstructionContextAttrs<'input> for AddFloat2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn addFloat2addrInstruction(&mut self,)
	-> Result<Rc<AddFloat2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AddFloat2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 314, RULE_addFloat2addrInstruction);
        let mut _localctx: Rc<AddFloat2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1384);
			recog.base.match_token(OP_ADD_FLOAT_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1385);
			recog.leftRegister()?;

			recog.base.set_state(1386);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1387);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- subFloat2addrInstruction ----------------
pub type SubFloat2addrInstructionContextAll<'input> = SubFloat2addrInstructionContext<'input>;


pub type SubFloat2addrInstructionContext<'input> = BaseParserRuleContext<'input,SubFloat2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SubFloat2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SubFloat2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SubFloat2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_subFloat2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_subFloat2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SubFloat2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_subFloat2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_subFloat2addrInstruction }
}
antlr_rust::tid!{SubFloat2addrInstructionContextExt<'a>}

impl<'input> SubFloat2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SubFloat2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SubFloat2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SubFloat2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SubFloat2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SUB_FLOAT_2ADDR
/// Returns `None` if there is no child corresponding to token OP_SUB_FLOAT_2ADDR
fn OP_SUB_FLOAT_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SUB_FLOAT_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SubFloat2addrInstructionContextAttrs<'input> for SubFloat2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn subFloat2addrInstruction(&mut self,)
	-> Result<Rc<SubFloat2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SubFloat2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 316, RULE_subFloat2addrInstruction);
        let mut _localctx: Rc<SubFloat2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1389);
			recog.base.match_token(OP_SUB_FLOAT_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1390);
			recog.leftRegister()?;

			recog.base.set_state(1391);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1392);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- mulFloat2addrInstruction ----------------
pub type MulFloat2addrInstructionContextAll<'input> = MulFloat2addrInstructionContext<'input>;


pub type MulFloat2addrInstructionContext<'input> = BaseParserRuleContext<'input,MulFloat2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MulFloat2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MulFloat2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MulFloat2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_mulFloat2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_mulFloat2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MulFloat2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_mulFloat2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_mulFloat2addrInstruction }
}
antlr_rust::tid!{MulFloat2addrInstructionContextExt<'a>}

impl<'input> MulFloat2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MulFloat2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MulFloat2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MulFloat2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MulFloat2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MUL_FLOAT_2ADDR
/// Returns `None` if there is no child corresponding to token OP_MUL_FLOAT_2ADDR
fn OP_MUL_FLOAT_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MUL_FLOAT_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MulFloat2addrInstructionContextAttrs<'input> for MulFloat2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn mulFloat2addrInstruction(&mut self,)
	-> Result<Rc<MulFloat2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MulFloat2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 318, RULE_mulFloat2addrInstruction);
        let mut _localctx: Rc<MulFloat2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1394);
			recog.base.match_token(OP_MUL_FLOAT_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1395);
			recog.leftRegister()?;

			recog.base.set_state(1396);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1397);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- divFloat2addrInstruction ----------------
pub type DivFloat2addrInstructionContextAll<'input> = DivFloat2addrInstructionContext<'input>;


pub type DivFloat2addrInstructionContext<'input> = BaseParserRuleContext<'input,DivFloat2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct DivFloat2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for DivFloat2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for DivFloat2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_divFloat2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_divFloat2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DivFloat2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_divFloat2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_divFloat2addrInstruction }
}
antlr_rust::tid!{DivFloat2addrInstructionContextExt<'a>}

impl<'input> DivFloat2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DivFloat2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DivFloat2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DivFloat2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<DivFloat2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_DIV_FLOAT_2ADDR
/// Returns `None` if there is no child corresponding to token OP_DIV_FLOAT_2ADDR
fn OP_DIV_FLOAT_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_DIV_FLOAT_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DivFloat2addrInstructionContextAttrs<'input> for DivFloat2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn divFloat2addrInstruction(&mut self,)
	-> Result<Rc<DivFloat2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DivFloat2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 320, RULE_divFloat2addrInstruction);
        let mut _localctx: Rc<DivFloat2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1399);
			recog.base.match_token(OP_DIV_FLOAT_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1400);
			recog.leftRegister()?;

			recog.base.set_state(1401);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1402);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- remFloat2addrInstruction ----------------
pub type RemFloat2addrInstructionContextAll<'input> = RemFloat2addrInstructionContext<'input>;


pub type RemFloat2addrInstructionContext<'input> = BaseParserRuleContext<'input,RemFloat2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct RemFloat2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for RemFloat2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for RemFloat2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_remFloat2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_remFloat2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RemFloat2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_remFloat2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_remFloat2addrInstruction }
}
antlr_rust::tid!{RemFloat2addrInstructionContextExt<'a>}

impl<'input> RemFloat2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RemFloat2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RemFloat2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RemFloat2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<RemFloat2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_REM_FLOAT_2ADDR
/// Returns `None` if there is no child corresponding to token OP_REM_FLOAT_2ADDR
fn OP_REM_FLOAT_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_REM_FLOAT_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RemFloat2addrInstructionContextAttrs<'input> for RemFloat2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn remFloat2addrInstruction(&mut self,)
	-> Result<Rc<RemFloat2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RemFloat2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 322, RULE_remFloat2addrInstruction);
        let mut _localctx: Rc<RemFloat2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1404);
			recog.base.match_token(OP_REM_FLOAT_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1405);
			recog.leftRegister()?;

			recog.base.set_state(1406);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1407);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- addDouble2addrInstruction ----------------
pub type AddDouble2addrInstructionContextAll<'input> = AddDouble2addrInstructionContext<'input>;


pub type AddDouble2addrInstructionContext<'input> = BaseParserRuleContext<'input,AddDouble2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AddDouble2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AddDouble2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AddDouble2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_addDouble2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_addDouble2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AddDouble2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_addDouble2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_addDouble2addrInstruction }
}
antlr_rust::tid!{AddDouble2addrInstructionContextExt<'a>}

impl<'input> AddDouble2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AddDouble2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AddDouble2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AddDouble2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AddDouble2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_ADD_DOUBLE_2ADDR
/// Returns `None` if there is no child corresponding to token OP_ADD_DOUBLE_2ADDR
fn OP_ADD_DOUBLE_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_ADD_DOUBLE_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AddDouble2addrInstructionContextAttrs<'input> for AddDouble2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn addDouble2addrInstruction(&mut self,)
	-> Result<Rc<AddDouble2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AddDouble2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 324, RULE_addDouble2addrInstruction);
        let mut _localctx: Rc<AddDouble2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1409);
			recog.base.match_token(OP_ADD_DOUBLE_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1410);
			recog.leftRegister()?;

			recog.base.set_state(1411);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1412);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- subDouble2addrInstruction ----------------
pub type SubDouble2addrInstructionContextAll<'input> = SubDouble2addrInstructionContext<'input>;


pub type SubDouble2addrInstructionContext<'input> = BaseParserRuleContext<'input,SubDouble2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SubDouble2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SubDouble2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SubDouble2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_subDouble2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_subDouble2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SubDouble2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_subDouble2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_subDouble2addrInstruction }
}
antlr_rust::tid!{SubDouble2addrInstructionContextExt<'a>}

impl<'input> SubDouble2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SubDouble2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SubDouble2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SubDouble2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SubDouble2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SUB_DOUBLE_2ADDR
/// Returns `None` if there is no child corresponding to token OP_SUB_DOUBLE_2ADDR
fn OP_SUB_DOUBLE_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SUB_DOUBLE_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SubDouble2addrInstructionContextAttrs<'input> for SubDouble2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn subDouble2addrInstruction(&mut self,)
	-> Result<Rc<SubDouble2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SubDouble2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 326, RULE_subDouble2addrInstruction);
        let mut _localctx: Rc<SubDouble2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1414);
			recog.base.match_token(OP_SUB_DOUBLE_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1415);
			recog.leftRegister()?;

			recog.base.set_state(1416);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1417);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- mulDouble2addrInstruction ----------------
pub type MulDouble2addrInstructionContextAll<'input> = MulDouble2addrInstructionContext<'input>;


pub type MulDouble2addrInstructionContext<'input> = BaseParserRuleContext<'input,MulDouble2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MulDouble2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MulDouble2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MulDouble2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_mulDouble2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_mulDouble2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MulDouble2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_mulDouble2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_mulDouble2addrInstruction }
}
antlr_rust::tid!{MulDouble2addrInstructionContextExt<'a>}

impl<'input> MulDouble2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MulDouble2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MulDouble2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MulDouble2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MulDouble2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MUL_DOUBLE_2ADDR
/// Returns `None` if there is no child corresponding to token OP_MUL_DOUBLE_2ADDR
fn OP_MUL_DOUBLE_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MUL_DOUBLE_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MulDouble2addrInstructionContextAttrs<'input> for MulDouble2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn mulDouble2addrInstruction(&mut self,)
	-> Result<Rc<MulDouble2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MulDouble2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 328, RULE_mulDouble2addrInstruction);
        let mut _localctx: Rc<MulDouble2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1419);
			recog.base.match_token(OP_MUL_DOUBLE_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1420);
			recog.leftRegister()?;

			recog.base.set_state(1421);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1422);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- divDouble2addrInstruction ----------------
pub type DivDouble2addrInstructionContextAll<'input> = DivDouble2addrInstructionContext<'input>;


pub type DivDouble2addrInstructionContext<'input> = BaseParserRuleContext<'input,DivDouble2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct DivDouble2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for DivDouble2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for DivDouble2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_divDouble2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_divDouble2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DivDouble2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_divDouble2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_divDouble2addrInstruction }
}
antlr_rust::tid!{DivDouble2addrInstructionContextExt<'a>}

impl<'input> DivDouble2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DivDouble2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DivDouble2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DivDouble2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<DivDouble2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_DIV_DOUBLE_2ADDR
/// Returns `None` if there is no child corresponding to token OP_DIV_DOUBLE_2ADDR
fn OP_DIV_DOUBLE_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_DIV_DOUBLE_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DivDouble2addrInstructionContextAttrs<'input> for DivDouble2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn divDouble2addrInstruction(&mut self,)
	-> Result<Rc<DivDouble2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DivDouble2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 330, RULE_divDouble2addrInstruction);
        let mut _localctx: Rc<DivDouble2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1424);
			recog.base.match_token(OP_DIV_DOUBLE_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1425);
			recog.leftRegister()?;

			recog.base.set_state(1426);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1427);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- remDouble2addrInstruction ----------------
pub type RemDouble2addrInstructionContextAll<'input> = RemDouble2addrInstructionContext<'input>;


pub type RemDouble2addrInstructionContext<'input> = BaseParserRuleContext<'input,RemDouble2addrInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct RemDouble2addrInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for RemDouble2addrInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for RemDouble2addrInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_remDouble2addrInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_remDouble2addrInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RemDouble2addrInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_remDouble2addrInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_remDouble2addrInstruction }
}
antlr_rust::tid!{RemDouble2addrInstructionContextExt<'a>}

impl<'input> RemDouble2addrInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RemDouble2addrInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RemDouble2addrInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RemDouble2addrInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<RemDouble2addrInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_REM_DOUBLE_2ADDR
/// Returns `None` if there is no child corresponding to token OP_REM_DOUBLE_2ADDR
fn OP_REM_DOUBLE_2ADDR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_REM_DOUBLE_2ADDR, 0)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RemDouble2addrInstructionContextAttrs<'input> for RemDouble2addrInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn remDouble2addrInstruction(&mut self,)
	-> Result<Rc<RemDouble2addrInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RemDouble2addrInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 332, RULE_remDouble2addrInstruction);
        let mut _localctx: Rc<RemDouble2addrInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1429);
			recog.base.match_token(OP_REM_DOUBLE_2ADDR,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1430);
			recog.leftRegister()?;

			recog.base.set_state(1431);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1432);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- cmplFloatInstruction ----------------
pub type CmplFloatInstructionContextAll<'input> = CmplFloatInstructionContext<'input>;


pub type CmplFloatInstructionContext<'input> = BaseParserRuleContext<'input,CmplFloatInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct CmplFloatInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for CmplFloatInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for CmplFloatInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_cmplFloatInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_cmplFloatInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CmplFloatInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_cmplFloatInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_cmplFloatInstruction }
}
antlr_rust::tid!{CmplFloatInstructionContextExt<'a>}

impl<'input> CmplFloatInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CmplFloatInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CmplFloatInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CmplFloatInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<CmplFloatInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_CMPL_FLOAT
/// Returns `None` if there is no child corresponding to token OP_CMPL_FLOAT
fn OP_CMPL_FLOAT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_CMPL_FLOAT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CmplFloatInstructionContextAttrs<'input> for CmplFloatInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn cmplFloatInstruction(&mut self,)
	-> Result<Rc<CmplFloatInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CmplFloatInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 334, RULE_cmplFloatInstruction);
        let mut _localctx: Rc<CmplFloatInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1434);
			recog.base.match_token(OP_CMPL_FLOAT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1435);
			recog.targetRegister()?;

			recog.base.set_state(1436);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1437);
			recog.leftRegister()?;

			recog.base.set_state(1438);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1439);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- cmpgFloatInstruction ----------------
pub type CmpgFloatInstructionContextAll<'input> = CmpgFloatInstructionContext<'input>;


pub type CmpgFloatInstructionContext<'input> = BaseParserRuleContext<'input,CmpgFloatInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct CmpgFloatInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for CmpgFloatInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for CmpgFloatInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_cmpgFloatInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_cmpgFloatInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CmpgFloatInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_cmpgFloatInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_cmpgFloatInstruction }
}
antlr_rust::tid!{CmpgFloatInstructionContextExt<'a>}

impl<'input> CmpgFloatInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CmpgFloatInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CmpgFloatInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CmpgFloatInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<CmpgFloatInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_CMPG_FLOAT
/// Returns `None` if there is no child corresponding to token OP_CMPG_FLOAT
fn OP_CMPG_FLOAT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_CMPG_FLOAT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CmpgFloatInstructionContextAttrs<'input> for CmpgFloatInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn cmpgFloatInstruction(&mut self,)
	-> Result<Rc<CmpgFloatInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CmpgFloatInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 336, RULE_cmpgFloatInstruction);
        let mut _localctx: Rc<CmpgFloatInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1441);
			recog.base.match_token(OP_CMPG_FLOAT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1442);
			recog.targetRegister()?;

			recog.base.set_state(1443);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1444);
			recog.leftRegister()?;

			recog.base.set_state(1445);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1446);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- cmplDoubleInstruction ----------------
pub type CmplDoubleInstructionContextAll<'input> = CmplDoubleInstructionContext<'input>;


pub type CmplDoubleInstructionContext<'input> = BaseParserRuleContext<'input,CmplDoubleInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct CmplDoubleInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for CmplDoubleInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for CmplDoubleInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_cmplDoubleInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_cmplDoubleInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CmplDoubleInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_cmplDoubleInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_cmplDoubleInstruction }
}
antlr_rust::tid!{CmplDoubleInstructionContextExt<'a>}

impl<'input> CmplDoubleInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CmplDoubleInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CmplDoubleInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CmplDoubleInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<CmplDoubleInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_CMPL_DOUBLE
/// Returns `None` if there is no child corresponding to token OP_CMPL_DOUBLE
fn OP_CMPL_DOUBLE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_CMPL_DOUBLE, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CmplDoubleInstructionContextAttrs<'input> for CmplDoubleInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn cmplDoubleInstruction(&mut self,)
	-> Result<Rc<CmplDoubleInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CmplDoubleInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 338, RULE_cmplDoubleInstruction);
        let mut _localctx: Rc<CmplDoubleInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1448);
			recog.base.match_token(OP_CMPL_DOUBLE,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1449);
			recog.targetRegister()?;

			recog.base.set_state(1450);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1451);
			recog.leftRegister()?;

			recog.base.set_state(1452);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1453);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- cmpgDoubleInstruction ----------------
pub type CmpgDoubleInstructionContextAll<'input> = CmpgDoubleInstructionContext<'input>;


pub type CmpgDoubleInstructionContext<'input> = BaseParserRuleContext<'input,CmpgDoubleInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct CmpgDoubleInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for CmpgDoubleInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for CmpgDoubleInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_cmpgDoubleInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_cmpgDoubleInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CmpgDoubleInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_cmpgDoubleInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_cmpgDoubleInstruction }
}
antlr_rust::tid!{CmpgDoubleInstructionContextExt<'a>}

impl<'input> CmpgDoubleInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CmpgDoubleInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CmpgDoubleInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CmpgDoubleInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<CmpgDoubleInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_CMPG_DOUBLE
/// Returns `None` if there is no child corresponding to token OP_CMPG_DOUBLE
fn OP_CMPG_DOUBLE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_CMPG_DOUBLE, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CmpgDoubleInstructionContextAttrs<'input> for CmpgDoubleInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn cmpgDoubleInstruction(&mut self,)
	-> Result<Rc<CmpgDoubleInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CmpgDoubleInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 340, RULE_cmpgDoubleInstruction);
        let mut _localctx: Rc<CmpgDoubleInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1455);
			recog.base.match_token(OP_CMPG_DOUBLE,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1456);
			recog.targetRegister()?;

			recog.base.set_state(1457);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1458);
			recog.leftRegister()?;

			recog.base.set_state(1459);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1460);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- cmpLongInstruction ----------------
pub type CmpLongInstructionContextAll<'input> = CmpLongInstructionContext<'input>;


pub type CmpLongInstructionContext<'input> = BaseParserRuleContext<'input,CmpLongInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct CmpLongInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for CmpLongInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for CmpLongInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_cmpLongInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_cmpLongInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CmpLongInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_cmpLongInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_cmpLongInstruction }
}
antlr_rust::tid!{CmpLongInstructionContextExt<'a>}

impl<'input> CmpLongInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CmpLongInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CmpLongInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CmpLongInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<CmpLongInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_CMP_LONG
/// Returns `None` if there is no child corresponding to token OP_CMP_LONG
fn OP_CMP_LONG(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_CMP_LONG, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CmpLongInstructionContextAttrs<'input> for CmpLongInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn cmpLongInstruction(&mut self,)
	-> Result<Rc<CmpLongInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CmpLongInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 342, RULE_cmpLongInstruction);
        let mut _localctx: Rc<CmpLongInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1462);
			recog.base.match_token(OP_CMP_LONG,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1463);
			recog.targetRegister()?;

			recog.base.set_state(1464);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1465);
			recog.leftRegister()?;

			recog.base.set_state(1466);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1467);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- field ----------------
pub type FieldContextAll<'input> = FieldContext<'input>;


pub type FieldContext<'input> = BaseParserRuleContext<'input,FieldContextExt<'input>>;

#[derive(Clone)]
pub struct FieldContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for FieldContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for FieldContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_field(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_field(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FieldContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_field }
	//fn type_rule_index() -> usize where Self: Sized { RULE_field }
}
antlr_rust::tid!{FieldContextExt<'a>}

impl<'input> FieldContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FieldContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FieldContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FieldContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<FieldContextExt<'input>>{

fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FieldContextAttrs<'input> for FieldContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn field(&mut self,)
	-> Result<Rc<FieldContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FieldContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 344, RULE_field);
        let mut _localctx: Rc<FieldContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1469);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayRegister ----------------
pub type ArrayRegisterContextAll<'input> = ArrayRegisterContext<'input>;


pub type ArrayRegisterContext<'input> = BaseParserRuleContext<'input,ArrayRegisterContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayRegisterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ArrayRegisterContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ArrayRegisterContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayRegister(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_arrayRegister(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ArrayRegisterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayRegister }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayRegister }
}
antlr_rust::tid!{ArrayRegisterContextExt<'a>}

impl<'input> ArrayRegisterContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayRegisterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayRegisterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayRegisterContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ArrayRegisterContextExt<'input>>{

fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ArrayRegisterContextAttrs<'input> for ArrayRegisterContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayRegister(&mut self,)
	-> Result<Rc<ArrayRegisterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayRegisterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 346, RULE_arrayRegister);
        let mut _localctx: Rc<ArrayRegisterContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1471);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- indexRegister ----------------
pub type IndexRegisterContextAll<'input> = IndexRegisterContext<'input>;


pub type IndexRegisterContext<'input> = BaseParserRuleContext<'input,IndexRegisterContextExt<'input>>;

#[derive(Clone)]
pub struct IndexRegisterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IndexRegisterContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IndexRegisterContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_indexRegister(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_indexRegister(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IndexRegisterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_indexRegister }
	//fn type_rule_index() -> usize where Self: Sized { RULE_indexRegister }
}
antlr_rust::tid!{IndexRegisterContextExt<'a>}

impl<'input> IndexRegisterContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IndexRegisterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IndexRegisterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IndexRegisterContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IndexRegisterContextExt<'input>>{

fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IndexRegisterContextAttrs<'input> for IndexRegisterContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn indexRegister(&mut self,)
	-> Result<Rc<IndexRegisterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IndexRegisterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 348, RULE_indexRegister);
        let mut _localctx: Rc<IndexRegisterContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1473);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- instanceRegister ----------------
pub type InstanceRegisterContextAll<'input> = InstanceRegisterContext<'input>;


pub type InstanceRegisterContext<'input> = BaseParserRuleContext<'input,InstanceRegisterContextExt<'input>>;

#[derive(Clone)]
pub struct InstanceRegisterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InstanceRegisterContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InstanceRegisterContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_instanceRegister(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_instanceRegister(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InstanceRegisterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_instanceRegister }
	//fn type_rule_index() -> usize where Self: Sized { RULE_instanceRegister }
}
antlr_rust::tid!{InstanceRegisterContextExt<'a>}

impl<'input> InstanceRegisterContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InstanceRegisterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InstanceRegisterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InstanceRegisterContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InstanceRegisterContextExt<'input>>{

fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InstanceRegisterContextAttrs<'input> for InstanceRegisterContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn instanceRegister(&mut self,)
	-> Result<Rc<InstanceRegisterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InstanceRegisterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 350, RULE_instanceRegister);
        let mut _localctx: Rc<InstanceRegisterContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1475);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sourceRegister ----------------
pub type SourceRegisterContextAll<'input> = SourceRegisterContext<'input>;


pub type SourceRegisterContext<'input> = BaseParserRuleContext<'input,SourceRegisterContextExt<'input>>;

#[derive(Clone)]
pub struct SourceRegisterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SourceRegisterContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SourceRegisterContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sourceRegister(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sourceRegister(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SourceRegisterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sourceRegister }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sourceRegister }
}
antlr_rust::tid!{SourceRegisterContextExt<'a>}

impl<'input> SourceRegisterContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SourceRegisterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SourceRegisterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SourceRegisterContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SourceRegisterContextExt<'input>>{

fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SourceRegisterContextAttrs<'input> for SourceRegisterContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sourceRegister(&mut self,)
	-> Result<Rc<SourceRegisterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SourceRegisterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 352, RULE_sourceRegister);
        let mut _localctx: Rc<SourceRegisterContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1477);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- targetRegister ----------------
pub type TargetRegisterContextAll<'input> = TargetRegisterContext<'input>;


pub type TargetRegisterContext<'input> = BaseParserRuleContext<'input,TargetRegisterContextExt<'input>>;

#[derive(Clone)]
pub struct TargetRegisterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for TargetRegisterContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for TargetRegisterContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_targetRegister(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_targetRegister(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TargetRegisterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_targetRegister }
	//fn type_rule_index() -> usize where Self: Sized { RULE_targetRegister }
}
antlr_rust::tid!{TargetRegisterContextExt<'a>}

impl<'input> TargetRegisterContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TargetRegisterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TargetRegisterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TargetRegisterContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<TargetRegisterContextExt<'input>>{

fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TargetRegisterContextAttrs<'input> for TargetRegisterContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn targetRegister(&mut self,)
	-> Result<Rc<TargetRegisterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TargetRegisterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 354, RULE_targetRegister);
        let mut _localctx: Rc<TargetRegisterContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule registerIdentifier*/
			recog.base.set_state(1479);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- instanceField ----------------
pub type InstanceFieldContextAll<'input> = InstanceFieldContext<'input>;


pub type InstanceFieldContext<'input> = BaseParserRuleContext<'input,InstanceFieldContextExt<'input>>;

#[derive(Clone)]
pub struct InstanceFieldContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InstanceFieldContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InstanceFieldContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_instanceField(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_instanceField(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InstanceFieldContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_instanceField }
	//fn type_rule_index() -> usize where Self: Sized { RULE_instanceField }
}
antlr_rust::tid!{InstanceFieldContextExt<'a>}

impl<'input> InstanceFieldContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InstanceFieldContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InstanceFieldContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InstanceFieldContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InstanceFieldContextExt<'input>>{

fn fieldInvocationTarget(&self) -> Option<Rc<FieldInvocationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InstanceFieldContextAttrs<'input> for InstanceFieldContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn instanceField(&mut self,)
	-> Result<Rc<InstanceFieldContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InstanceFieldContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 356, RULE_instanceField);
        let mut _localctx: Rc<InstanceFieldContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule fieldInvocationTarget*/
			recog.base.set_state(1481);
			recog.fieldInvocationTarget()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- agetInstruction ----------------
pub type AgetInstructionContextAll<'input> = AgetInstructionContext<'input>;


pub type AgetInstructionContext<'input> = BaseParserRuleContext<'input,AgetInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AgetInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AgetInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AgetInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_agetInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_agetInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AgetInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_agetInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_agetInstruction }
}
antlr_rust::tid!{AgetInstructionContextExt<'a>}

impl<'input> AgetInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AgetInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AgetInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AgetInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AgetInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_AGET
/// Returns `None` if there is no child corresponding to token OP_AGET
fn OP_AGET(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_AGET, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn arrayRegister(&self) -> Option<Rc<ArrayRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexRegister(&self) -> Option<Rc<IndexRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AgetInstructionContextAttrs<'input> for AgetInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn agetInstruction(&mut self,)
	-> Result<Rc<AgetInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AgetInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 358, RULE_agetInstruction);
        let mut _localctx: Rc<AgetInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1483);
			recog.base.match_token(OP_AGET,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1484);
			recog.targetRegister()?;

			recog.base.set_state(1485);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule arrayRegister*/
			recog.base.set_state(1486);
			recog.arrayRegister()?;

			recog.base.set_state(1487);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule indexRegister*/
			recog.base.set_state(1488);
			recog.indexRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- agetWideInstruction ----------------
pub type AgetWideInstructionContextAll<'input> = AgetWideInstructionContext<'input>;


pub type AgetWideInstructionContext<'input> = BaseParserRuleContext<'input,AgetWideInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AgetWideInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AgetWideInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AgetWideInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_agetWideInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_agetWideInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AgetWideInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_agetWideInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_agetWideInstruction }
}
antlr_rust::tid!{AgetWideInstructionContextExt<'a>}

impl<'input> AgetWideInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AgetWideInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AgetWideInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AgetWideInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AgetWideInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_AGET_WIDE
/// Returns `None` if there is no child corresponding to token OP_AGET_WIDE
fn OP_AGET_WIDE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_AGET_WIDE, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn arrayRegister(&self) -> Option<Rc<ArrayRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexRegister(&self) -> Option<Rc<IndexRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AgetWideInstructionContextAttrs<'input> for AgetWideInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn agetWideInstruction(&mut self,)
	-> Result<Rc<AgetWideInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AgetWideInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 360, RULE_agetWideInstruction);
        let mut _localctx: Rc<AgetWideInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1490);
			recog.base.match_token(OP_AGET_WIDE,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1491);
			recog.targetRegister()?;

			recog.base.set_state(1492);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule arrayRegister*/
			recog.base.set_state(1493);
			recog.arrayRegister()?;

			recog.base.set_state(1494);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule indexRegister*/
			recog.base.set_state(1495);
			recog.indexRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- agetObjectInstruction ----------------
pub type AgetObjectInstructionContextAll<'input> = AgetObjectInstructionContext<'input>;


pub type AgetObjectInstructionContext<'input> = BaseParserRuleContext<'input,AgetObjectInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AgetObjectInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AgetObjectInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AgetObjectInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_agetObjectInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_agetObjectInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AgetObjectInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_agetObjectInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_agetObjectInstruction }
}
antlr_rust::tid!{AgetObjectInstructionContextExt<'a>}

impl<'input> AgetObjectInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AgetObjectInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AgetObjectInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AgetObjectInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AgetObjectInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_AGET_OBJECT
/// Returns `None` if there is no child corresponding to token OP_AGET_OBJECT
fn OP_AGET_OBJECT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_AGET_OBJECT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn arrayRegister(&self) -> Option<Rc<ArrayRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexRegister(&self) -> Option<Rc<IndexRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AgetObjectInstructionContextAttrs<'input> for AgetObjectInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn agetObjectInstruction(&mut self,)
	-> Result<Rc<AgetObjectInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AgetObjectInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 362, RULE_agetObjectInstruction);
        let mut _localctx: Rc<AgetObjectInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1497);
			recog.base.match_token(OP_AGET_OBJECT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1498);
			recog.targetRegister()?;

			recog.base.set_state(1499);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule arrayRegister*/
			recog.base.set_state(1500);
			recog.arrayRegister()?;

			recog.base.set_state(1501);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule indexRegister*/
			recog.base.set_state(1502);
			recog.indexRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- agetBooleanInstruction ----------------
pub type AgetBooleanInstructionContextAll<'input> = AgetBooleanInstructionContext<'input>;


pub type AgetBooleanInstructionContext<'input> = BaseParserRuleContext<'input,AgetBooleanInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AgetBooleanInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AgetBooleanInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AgetBooleanInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_agetBooleanInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_agetBooleanInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AgetBooleanInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_agetBooleanInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_agetBooleanInstruction }
}
antlr_rust::tid!{AgetBooleanInstructionContextExt<'a>}

impl<'input> AgetBooleanInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AgetBooleanInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AgetBooleanInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AgetBooleanInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AgetBooleanInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_AGET_BOOLEAN
/// Returns `None` if there is no child corresponding to token OP_AGET_BOOLEAN
fn OP_AGET_BOOLEAN(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_AGET_BOOLEAN, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn arrayRegister(&self) -> Option<Rc<ArrayRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexRegister(&self) -> Option<Rc<IndexRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AgetBooleanInstructionContextAttrs<'input> for AgetBooleanInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn agetBooleanInstruction(&mut self,)
	-> Result<Rc<AgetBooleanInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AgetBooleanInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 364, RULE_agetBooleanInstruction);
        let mut _localctx: Rc<AgetBooleanInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1504);
			recog.base.match_token(OP_AGET_BOOLEAN,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1505);
			recog.targetRegister()?;

			recog.base.set_state(1506);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule arrayRegister*/
			recog.base.set_state(1507);
			recog.arrayRegister()?;

			recog.base.set_state(1508);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule indexRegister*/
			recog.base.set_state(1509);
			recog.indexRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- agetByteInstruction ----------------
pub type AgetByteInstructionContextAll<'input> = AgetByteInstructionContext<'input>;


pub type AgetByteInstructionContext<'input> = BaseParserRuleContext<'input,AgetByteInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AgetByteInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AgetByteInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AgetByteInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_agetByteInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_agetByteInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AgetByteInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_agetByteInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_agetByteInstruction }
}
antlr_rust::tid!{AgetByteInstructionContextExt<'a>}

impl<'input> AgetByteInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AgetByteInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AgetByteInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AgetByteInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AgetByteInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_AGET_BYTE
/// Returns `None` if there is no child corresponding to token OP_AGET_BYTE
fn OP_AGET_BYTE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_AGET_BYTE, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn arrayRegister(&self) -> Option<Rc<ArrayRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexRegister(&self) -> Option<Rc<IndexRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AgetByteInstructionContextAttrs<'input> for AgetByteInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn agetByteInstruction(&mut self,)
	-> Result<Rc<AgetByteInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AgetByteInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 366, RULE_agetByteInstruction);
        let mut _localctx: Rc<AgetByteInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1511);
			recog.base.match_token(OP_AGET_BYTE,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1512);
			recog.targetRegister()?;

			recog.base.set_state(1513);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule arrayRegister*/
			recog.base.set_state(1514);
			recog.arrayRegister()?;

			recog.base.set_state(1515);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule indexRegister*/
			recog.base.set_state(1516);
			recog.indexRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- agetCharInstruction ----------------
pub type AgetCharInstructionContextAll<'input> = AgetCharInstructionContext<'input>;


pub type AgetCharInstructionContext<'input> = BaseParserRuleContext<'input,AgetCharInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AgetCharInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AgetCharInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AgetCharInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_agetCharInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_agetCharInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AgetCharInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_agetCharInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_agetCharInstruction }
}
antlr_rust::tid!{AgetCharInstructionContextExt<'a>}

impl<'input> AgetCharInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AgetCharInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AgetCharInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AgetCharInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AgetCharInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_AGET_CHAR
/// Returns `None` if there is no child corresponding to token OP_AGET_CHAR
fn OP_AGET_CHAR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_AGET_CHAR, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn arrayRegister(&self) -> Option<Rc<ArrayRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexRegister(&self) -> Option<Rc<IndexRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AgetCharInstructionContextAttrs<'input> for AgetCharInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn agetCharInstruction(&mut self,)
	-> Result<Rc<AgetCharInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AgetCharInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 368, RULE_agetCharInstruction);
        let mut _localctx: Rc<AgetCharInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1518);
			recog.base.match_token(OP_AGET_CHAR,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1519);
			recog.targetRegister()?;

			recog.base.set_state(1520);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule arrayRegister*/
			recog.base.set_state(1521);
			recog.arrayRegister()?;

			recog.base.set_state(1522);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule indexRegister*/
			recog.base.set_state(1523);
			recog.indexRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- agetShortInstruction ----------------
pub type AgetShortInstructionContextAll<'input> = AgetShortInstructionContext<'input>;


pub type AgetShortInstructionContext<'input> = BaseParserRuleContext<'input,AgetShortInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AgetShortInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AgetShortInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AgetShortInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_agetShortInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_agetShortInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AgetShortInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_agetShortInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_agetShortInstruction }
}
antlr_rust::tid!{AgetShortInstructionContextExt<'a>}

impl<'input> AgetShortInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AgetShortInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AgetShortInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AgetShortInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AgetShortInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_AGET_SHORT
/// Returns `None` if there is no child corresponding to token OP_AGET_SHORT
fn OP_AGET_SHORT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_AGET_SHORT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn arrayRegister(&self) -> Option<Rc<ArrayRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexRegister(&self) -> Option<Rc<IndexRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AgetShortInstructionContextAttrs<'input> for AgetShortInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn agetShortInstruction(&mut self,)
	-> Result<Rc<AgetShortInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AgetShortInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 370, RULE_agetShortInstruction);
        let mut _localctx: Rc<AgetShortInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1525);
			recog.base.match_token(OP_AGET_SHORT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1526);
			recog.targetRegister()?;

			recog.base.set_state(1527);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule arrayRegister*/
			recog.base.set_state(1528);
			recog.arrayRegister()?;

			recog.base.set_state(1529);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule indexRegister*/
			recog.base.set_state(1530);
			recog.indexRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- aputInstruction ----------------
pub type AputInstructionContextAll<'input> = AputInstructionContext<'input>;


pub type AputInstructionContext<'input> = BaseParserRuleContext<'input,AputInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AputInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AputInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AputInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_aputInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_aputInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AputInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_aputInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_aputInstruction }
}
antlr_rust::tid!{AputInstructionContextExt<'a>}

impl<'input> AputInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AputInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AputInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AputInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AputInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_APUT
/// Returns `None` if there is no child corresponding to token OP_APUT
fn OP_APUT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_APUT, 0)
}
fn sourceRegister(&self) -> Option<Rc<SourceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn arrayRegister(&self) -> Option<Rc<ArrayRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexRegister(&self) -> Option<Rc<IndexRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AputInstructionContextAttrs<'input> for AputInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn aputInstruction(&mut self,)
	-> Result<Rc<AputInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AputInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 372, RULE_aputInstruction);
        let mut _localctx: Rc<AputInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1532);
			recog.base.match_token(OP_APUT,&mut recog.err_handler)?;

			/*InvokeRule sourceRegister*/
			recog.base.set_state(1533);
			recog.sourceRegister()?;

			recog.base.set_state(1534);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule arrayRegister*/
			recog.base.set_state(1535);
			recog.arrayRegister()?;

			recog.base.set_state(1536);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule indexRegister*/
			recog.base.set_state(1537);
			recog.indexRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- aputWideInstruction ----------------
pub type AputWideInstructionContextAll<'input> = AputWideInstructionContext<'input>;


pub type AputWideInstructionContext<'input> = BaseParserRuleContext<'input,AputWideInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AputWideInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AputWideInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AputWideInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_aputWideInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_aputWideInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AputWideInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_aputWideInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_aputWideInstruction }
}
antlr_rust::tid!{AputWideInstructionContextExt<'a>}

impl<'input> AputWideInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AputWideInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AputWideInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AputWideInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AputWideInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_APUT_WIDE
/// Returns `None` if there is no child corresponding to token OP_APUT_WIDE
fn OP_APUT_WIDE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_APUT_WIDE, 0)
}
fn sourceRegister(&self) -> Option<Rc<SourceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn arrayRegister(&self) -> Option<Rc<ArrayRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexRegister(&self) -> Option<Rc<IndexRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AputWideInstructionContextAttrs<'input> for AputWideInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn aputWideInstruction(&mut self,)
	-> Result<Rc<AputWideInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AputWideInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 374, RULE_aputWideInstruction);
        let mut _localctx: Rc<AputWideInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1539);
			recog.base.match_token(OP_APUT_WIDE,&mut recog.err_handler)?;

			/*InvokeRule sourceRegister*/
			recog.base.set_state(1540);
			recog.sourceRegister()?;

			recog.base.set_state(1541);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule arrayRegister*/
			recog.base.set_state(1542);
			recog.arrayRegister()?;

			recog.base.set_state(1543);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule indexRegister*/
			recog.base.set_state(1544);
			recog.indexRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- aputObjectInstruction ----------------
pub type AputObjectInstructionContextAll<'input> = AputObjectInstructionContext<'input>;


pub type AputObjectInstructionContext<'input> = BaseParserRuleContext<'input,AputObjectInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AputObjectInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AputObjectInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AputObjectInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_aputObjectInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_aputObjectInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AputObjectInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_aputObjectInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_aputObjectInstruction }
}
antlr_rust::tid!{AputObjectInstructionContextExt<'a>}

impl<'input> AputObjectInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AputObjectInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AputObjectInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AputObjectInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AputObjectInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_APUT_OBJECT
/// Returns `None` if there is no child corresponding to token OP_APUT_OBJECT
fn OP_APUT_OBJECT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_APUT_OBJECT, 0)
}
fn sourceRegister(&self) -> Option<Rc<SourceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn arrayRegister(&self) -> Option<Rc<ArrayRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexRegister(&self) -> Option<Rc<IndexRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AputObjectInstructionContextAttrs<'input> for AputObjectInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn aputObjectInstruction(&mut self,)
	-> Result<Rc<AputObjectInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AputObjectInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 376, RULE_aputObjectInstruction);
        let mut _localctx: Rc<AputObjectInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1546);
			recog.base.match_token(OP_APUT_OBJECT,&mut recog.err_handler)?;

			/*InvokeRule sourceRegister*/
			recog.base.set_state(1547);
			recog.sourceRegister()?;

			recog.base.set_state(1548);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule arrayRegister*/
			recog.base.set_state(1549);
			recog.arrayRegister()?;

			recog.base.set_state(1550);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule indexRegister*/
			recog.base.set_state(1551);
			recog.indexRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- aputBooleanInstruction ----------------
pub type AputBooleanInstructionContextAll<'input> = AputBooleanInstructionContext<'input>;


pub type AputBooleanInstructionContext<'input> = BaseParserRuleContext<'input,AputBooleanInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AputBooleanInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AputBooleanInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AputBooleanInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_aputBooleanInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_aputBooleanInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AputBooleanInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_aputBooleanInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_aputBooleanInstruction }
}
antlr_rust::tid!{AputBooleanInstructionContextExt<'a>}

impl<'input> AputBooleanInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AputBooleanInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AputBooleanInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AputBooleanInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AputBooleanInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_APUT_BOOLEAN
/// Returns `None` if there is no child corresponding to token OP_APUT_BOOLEAN
fn OP_APUT_BOOLEAN(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_APUT_BOOLEAN, 0)
}
fn sourceRegister(&self) -> Option<Rc<SourceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn arrayRegister(&self) -> Option<Rc<ArrayRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexRegister(&self) -> Option<Rc<IndexRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AputBooleanInstructionContextAttrs<'input> for AputBooleanInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn aputBooleanInstruction(&mut self,)
	-> Result<Rc<AputBooleanInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AputBooleanInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 378, RULE_aputBooleanInstruction);
        let mut _localctx: Rc<AputBooleanInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1553);
			recog.base.match_token(OP_APUT_BOOLEAN,&mut recog.err_handler)?;

			/*InvokeRule sourceRegister*/
			recog.base.set_state(1554);
			recog.sourceRegister()?;

			recog.base.set_state(1555);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule arrayRegister*/
			recog.base.set_state(1556);
			recog.arrayRegister()?;

			recog.base.set_state(1557);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule indexRegister*/
			recog.base.set_state(1558);
			recog.indexRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- aputByteInstruction ----------------
pub type AputByteInstructionContextAll<'input> = AputByteInstructionContext<'input>;


pub type AputByteInstructionContext<'input> = BaseParserRuleContext<'input,AputByteInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AputByteInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AputByteInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AputByteInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_aputByteInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_aputByteInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AputByteInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_aputByteInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_aputByteInstruction }
}
antlr_rust::tid!{AputByteInstructionContextExt<'a>}

impl<'input> AputByteInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AputByteInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AputByteInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AputByteInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AputByteInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_APUT_BYTE
/// Returns `None` if there is no child corresponding to token OP_APUT_BYTE
fn OP_APUT_BYTE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_APUT_BYTE, 0)
}
fn sourceRegister(&self) -> Option<Rc<SourceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn arrayRegister(&self) -> Option<Rc<ArrayRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexRegister(&self) -> Option<Rc<IndexRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AputByteInstructionContextAttrs<'input> for AputByteInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn aputByteInstruction(&mut self,)
	-> Result<Rc<AputByteInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AputByteInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 380, RULE_aputByteInstruction);
        let mut _localctx: Rc<AputByteInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1560);
			recog.base.match_token(OP_APUT_BYTE,&mut recog.err_handler)?;

			/*InvokeRule sourceRegister*/
			recog.base.set_state(1561);
			recog.sourceRegister()?;

			recog.base.set_state(1562);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule arrayRegister*/
			recog.base.set_state(1563);
			recog.arrayRegister()?;

			recog.base.set_state(1564);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule indexRegister*/
			recog.base.set_state(1565);
			recog.indexRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- aputCharInstruction ----------------
pub type AputCharInstructionContextAll<'input> = AputCharInstructionContext<'input>;


pub type AputCharInstructionContext<'input> = BaseParserRuleContext<'input,AputCharInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AputCharInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AputCharInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AputCharInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_aputCharInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_aputCharInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AputCharInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_aputCharInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_aputCharInstruction }
}
antlr_rust::tid!{AputCharInstructionContextExt<'a>}

impl<'input> AputCharInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AputCharInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AputCharInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AputCharInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AputCharInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_APUT_CHAR
/// Returns `None` if there is no child corresponding to token OP_APUT_CHAR
fn OP_APUT_CHAR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_APUT_CHAR, 0)
}
fn sourceRegister(&self) -> Option<Rc<SourceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn arrayRegister(&self) -> Option<Rc<ArrayRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexRegister(&self) -> Option<Rc<IndexRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AputCharInstructionContextAttrs<'input> for AputCharInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn aputCharInstruction(&mut self,)
	-> Result<Rc<AputCharInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AputCharInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 382, RULE_aputCharInstruction);
        let mut _localctx: Rc<AputCharInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1567);
			recog.base.match_token(OP_APUT_CHAR,&mut recog.err_handler)?;

			/*InvokeRule sourceRegister*/
			recog.base.set_state(1568);
			recog.sourceRegister()?;

			recog.base.set_state(1569);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule arrayRegister*/
			recog.base.set_state(1570);
			recog.arrayRegister()?;

			recog.base.set_state(1571);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule indexRegister*/
			recog.base.set_state(1572);
			recog.indexRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- aputShortInstruction ----------------
pub type AputShortInstructionContextAll<'input> = AputShortInstructionContext<'input>;


pub type AputShortInstructionContext<'input> = BaseParserRuleContext<'input,AputShortInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AputShortInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AputShortInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AputShortInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_aputShortInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_aputShortInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AputShortInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_aputShortInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_aputShortInstruction }
}
antlr_rust::tid!{AputShortInstructionContextExt<'a>}

impl<'input> AputShortInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AputShortInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AputShortInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AputShortInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AputShortInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_APUT_SHORT
/// Returns `None` if there is no child corresponding to token OP_APUT_SHORT
fn OP_APUT_SHORT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_APUT_SHORT, 0)
}
fn sourceRegister(&self) -> Option<Rc<SourceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn arrayRegister(&self) -> Option<Rc<ArrayRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn indexRegister(&self) -> Option<Rc<IndexRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AputShortInstructionContextAttrs<'input> for AputShortInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn aputShortInstruction(&mut self,)
	-> Result<Rc<AputShortInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AputShortInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 384, RULE_aputShortInstruction);
        let mut _localctx: Rc<AputShortInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1574);
			recog.base.match_token(OP_APUT_SHORT,&mut recog.err_handler)?;

			/*InvokeRule sourceRegister*/
			recog.base.set_state(1575);
			recog.sourceRegister()?;

			recog.base.set_state(1576);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule arrayRegister*/
			recog.base.set_state(1577);
			recog.arrayRegister()?;

			recog.base.set_state(1578);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule indexRegister*/
			recog.base.set_state(1579);
			recog.indexRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- igetInstruction ----------------
pub type IgetInstructionContextAll<'input> = IgetInstructionContext<'input>;


pub type IgetInstructionContext<'input> = BaseParserRuleContext<'input,IgetInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IgetInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IgetInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IgetInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_igetInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_igetInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IgetInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_igetInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_igetInstruction }
}
antlr_rust::tid!{IgetInstructionContextExt<'a>}

impl<'input> IgetInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IgetInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IgetInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IgetInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IgetInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IGET
/// Returns `None` if there is no child corresponding to token OP_IGET
fn OP_IGET(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IGET, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn instanceRegister(&self) -> Option<Rc<InstanceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn instanceField(&self) -> Option<Rc<InstanceFieldContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IgetInstructionContextAttrs<'input> for IgetInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn igetInstruction(&mut self,)
	-> Result<Rc<IgetInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IgetInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 386, RULE_igetInstruction);
        let mut _localctx: Rc<IgetInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1581);
			recog.base.match_token(OP_IGET,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1582);
			recog.targetRegister()?;

			recog.base.set_state(1583);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceRegister*/
			recog.base.set_state(1584);
			recog.instanceRegister()?;

			recog.base.set_state(1585);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceField*/
			recog.base.set_state(1586);
			recog.instanceField()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- igetWideInstruction ----------------
pub type IgetWideInstructionContextAll<'input> = IgetWideInstructionContext<'input>;


pub type IgetWideInstructionContext<'input> = BaseParserRuleContext<'input,IgetWideInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IgetWideInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IgetWideInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IgetWideInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_igetWideInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_igetWideInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IgetWideInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_igetWideInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_igetWideInstruction }
}
antlr_rust::tid!{IgetWideInstructionContextExt<'a>}

impl<'input> IgetWideInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IgetWideInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IgetWideInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IgetWideInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IgetWideInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IGET_WIDE
/// Returns `None` if there is no child corresponding to token OP_IGET_WIDE
fn OP_IGET_WIDE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IGET_WIDE, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn instanceRegister(&self) -> Option<Rc<InstanceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn instanceField(&self) -> Option<Rc<InstanceFieldContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IgetWideInstructionContextAttrs<'input> for IgetWideInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn igetWideInstruction(&mut self,)
	-> Result<Rc<IgetWideInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IgetWideInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 388, RULE_igetWideInstruction);
        let mut _localctx: Rc<IgetWideInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1588);
			recog.base.match_token(OP_IGET_WIDE,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1589);
			recog.targetRegister()?;

			recog.base.set_state(1590);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceRegister*/
			recog.base.set_state(1591);
			recog.instanceRegister()?;

			recog.base.set_state(1592);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceField*/
			recog.base.set_state(1593);
			recog.instanceField()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- igetObjectInstruction ----------------
pub type IgetObjectInstructionContextAll<'input> = IgetObjectInstructionContext<'input>;


pub type IgetObjectInstructionContext<'input> = BaseParserRuleContext<'input,IgetObjectInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IgetObjectInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IgetObjectInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IgetObjectInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_igetObjectInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_igetObjectInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IgetObjectInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_igetObjectInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_igetObjectInstruction }
}
antlr_rust::tid!{IgetObjectInstructionContextExt<'a>}

impl<'input> IgetObjectInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IgetObjectInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IgetObjectInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IgetObjectInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IgetObjectInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IGET_OBJECT
/// Returns `None` if there is no child corresponding to token OP_IGET_OBJECT
fn OP_IGET_OBJECT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IGET_OBJECT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn instanceRegister(&self) -> Option<Rc<InstanceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn instanceField(&self) -> Option<Rc<InstanceFieldContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IgetObjectInstructionContextAttrs<'input> for IgetObjectInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn igetObjectInstruction(&mut self,)
	-> Result<Rc<IgetObjectInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IgetObjectInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 390, RULE_igetObjectInstruction);
        let mut _localctx: Rc<IgetObjectInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1595);
			recog.base.match_token(OP_IGET_OBJECT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1596);
			recog.targetRegister()?;

			recog.base.set_state(1597);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceRegister*/
			recog.base.set_state(1598);
			recog.instanceRegister()?;

			recog.base.set_state(1599);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceField*/
			recog.base.set_state(1600);
			recog.instanceField()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- igetBooleanInstruction ----------------
pub type IgetBooleanInstructionContextAll<'input> = IgetBooleanInstructionContext<'input>;


pub type IgetBooleanInstructionContext<'input> = BaseParserRuleContext<'input,IgetBooleanInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IgetBooleanInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IgetBooleanInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IgetBooleanInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_igetBooleanInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_igetBooleanInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IgetBooleanInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_igetBooleanInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_igetBooleanInstruction }
}
antlr_rust::tid!{IgetBooleanInstructionContextExt<'a>}

impl<'input> IgetBooleanInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IgetBooleanInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IgetBooleanInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IgetBooleanInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IgetBooleanInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IGET_BOOLEAN
/// Returns `None` if there is no child corresponding to token OP_IGET_BOOLEAN
fn OP_IGET_BOOLEAN(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IGET_BOOLEAN, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn instanceRegister(&self) -> Option<Rc<InstanceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn instanceField(&self) -> Option<Rc<InstanceFieldContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IgetBooleanInstructionContextAttrs<'input> for IgetBooleanInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn igetBooleanInstruction(&mut self,)
	-> Result<Rc<IgetBooleanInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IgetBooleanInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 392, RULE_igetBooleanInstruction);
        let mut _localctx: Rc<IgetBooleanInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1602);
			recog.base.match_token(OP_IGET_BOOLEAN,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1603);
			recog.targetRegister()?;

			recog.base.set_state(1604);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceRegister*/
			recog.base.set_state(1605);
			recog.instanceRegister()?;

			recog.base.set_state(1606);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceField*/
			recog.base.set_state(1607);
			recog.instanceField()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- igetByteInstruction ----------------
pub type IgetByteInstructionContextAll<'input> = IgetByteInstructionContext<'input>;


pub type IgetByteInstructionContext<'input> = BaseParserRuleContext<'input,IgetByteInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IgetByteInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IgetByteInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IgetByteInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_igetByteInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_igetByteInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IgetByteInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_igetByteInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_igetByteInstruction }
}
antlr_rust::tid!{IgetByteInstructionContextExt<'a>}

impl<'input> IgetByteInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IgetByteInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IgetByteInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IgetByteInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IgetByteInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IGET_BYTE
/// Returns `None` if there is no child corresponding to token OP_IGET_BYTE
fn OP_IGET_BYTE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IGET_BYTE, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn instanceRegister(&self) -> Option<Rc<InstanceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn instanceField(&self) -> Option<Rc<InstanceFieldContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IgetByteInstructionContextAttrs<'input> for IgetByteInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn igetByteInstruction(&mut self,)
	-> Result<Rc<IgetByteInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IgetByteInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 394, RULE_igetByteInstruction);
        let mut _localctx: Rc<IgetByteInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1609);
			recog.base.match_token(OP_IGET_BYTE,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1610);
			recog.targetRegister()?;

			recog.base.set_state(1611);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceRegister*/
			recog.base.set_state(1612);
			recog.instanceRegister()?;

			recog.base.set_state(1613);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceField*/
			recog.base.set_state(1614);
			recog.instanceField()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- igetCharInstruction ----------------
pub type IgetCharInstructionContextAll<'input> = IgetCharInstructionContext<'input>;


pub type IgetCharInstructionContext<'input> = BaseParserRuleContext<'input,IgetCharInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IgetCharInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IgetCharInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IgetCharInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_igetCharInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_igetCharInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IgetCharInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_igetCharInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_igetCharInstruction }
}
antlr_rust::tid!{IgetCharInstructionContextExt<'a>}

impl<'input> IgetCharInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IgetCharInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IgetCharInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IgetCharInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IgetCharInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IGET_CHAR
/// Returns `None` if there is no child corresponding to token OP_IGET_CHAR
fn OP_IGET_CHAR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IGET_CHAR, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn instanceRegister(&self) -> Option<Rc<InstanceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn instanceField(&self) -> Option<Rc<InstanceFieldContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IgetCharInstructionContextAttrs<'input> for IgetCharInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn igetCharInstruction(&mut self,)
	-> Result<Rc<IgetCharInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IgetCharInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 396, RULE_igetCharInstruction);
        let mut _localctx: Rc<IgetCharInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1616);
			recog.base.match_token(OP_IGET_CHAR,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1617);
			recog.targetRegister()?;

			recog.base.set_state(1618);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceRegister*/
			recog.base.set_state(1619);
			recog.instanceRegister()?;

			recog.base.set_state(1620);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceField*/
			recog.base.set_state(1621);
			recog.instanceField()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- igetShortInstruction ----------------
pub type IgetShortInstructionContextAll<'input> = IgetShortInstructionContext<'input>;


pub type IgetShortInstructionContext<'input> = BaseParserRuleContext<'input,IgetShortInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IgetShortInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IgetShortInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IgetShortInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_igetShortInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_igetShortInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IgetShortInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_igetShortInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_igetShortInstruction }
}
antlr_rust::tid!{IgetShortInstructionContextExt<'a>}

impl<'input> IgetShortInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IgetShortInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IgetShortInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IgetShortInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IgetShortInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IGET_SHORT
/// Returns `None` if there is no child corresponding to token OP_IGET_SHORT
fn OP_IGET_SHORT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IGET_SHORT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn instanceRegister(&self) -> Option<Rc<InstanceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn instanceField(&self) -> Option<Rc<InstanceFieldContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IgetShortInstructionContextAttrs<'input> for IgetShortInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn igetShortInstruction(&mut self,)
	-> Result<Rc<IgetShortInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IgetShortInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 398, RULE_igetShortInstruction);
        let mut _localctx: Rc<IgetShortInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1623);
			recog.base.match_token(OP_IGET_SHORT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1624);
			recog.targetRegister()?;

			recog.base.set_state(1625);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceRegister*/
			recog.base.set_state(1626);
			recog.instanceRegister()?;

			recog.base.set_state(1627);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceField*/
			recog.base.set_state(1628);
			recog.instanceField()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- iputInstruction ----------------
pub type IputInstructionContextAll<'input> = IputInstructionContext<'input>;


pub type IputInstructionContext<'input> = BaseParserRuleContext<'input,IputInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IputInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IputInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IputInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_iputInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_iputInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IputInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_iputInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_iputInstruction }
}
antlr_rust::tid!{IputInstructionContextExt<'a>}

impl<'input> IputInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IputInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IputInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IputInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IputInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IPUT
/// Returns `None` if there is no child corresponding to token OP_IPUT
fn OP_IPUT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IPUT, 0)
}
fn sourceRegister(&self) -> Option<Rc<SourceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn instanceRegister(&self) -> Option<Rc<InstanceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn instanceField(&self) -> Option<Rc<InstanceFieldContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IputInstructionContextAttrs<'input> for IputInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn iputInstruction(&mut self,)
	-> Result<Rc<IputInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IputInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 400, RULE_iputInstruction);
        let mut _localctx: Rc<IputInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1630);
			recog.base.match_token(OP_IPUT,&mut recog.err_handler)?;

			/*InvokeRule sourceRegister*/
			recog.base.set_state(1631);
			recog.sourceRegister()?;

			recog.base.set_state(1632);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceRegister*/
			recog.base.set_state(1633);
			recog.instanceRegister()?;

			recog.base.set_state(1634);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceField*/
			recog.base.set_state(1635);
			recog.instanceField()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- iputWideInstruction ----------------
pub type IputWideInstructionContextAll<'input> = IputWideInstructionContext<'input>;


pub type IputWideInstructionContext<'input> = BaseParserRuleContext<'input,IputWideInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IputWideInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IputWideInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IputWideInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_iputWideInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_iputWideInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IputWideInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_iputWideInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_iputWideInstruction }
}
antlr_rust::tid!{IputWideInstructionContextExt<'a>}

impl<'input> IputWideInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IputWideInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IputWideInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IputWideInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IputWideInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IPUT_WIDE
/// Returns `None` if there is no child corresponding to token OP_IPUT_WIDE
fn OP_IPUT_WIDE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IPUT_WIDE, 0)
}
fn sourceRegister(&self) -> Option<Rc<SourceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn instanceRegister(&self) -> Option<Rc<InstanceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn instanceField(&self) -> Option<Rc<InstanceFieldContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IputWideInstructionContextAttrs<'input> for IputWideInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn iputWideInstruction(&mut self,)
	-> Result<Rc<IputWideInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IputWideInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 402, RULE_iputWideInstruction);
        let mut _localctx: Rc<IputWideInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1637);
			recog.base.match_token(OP_IPUT_WIDE,&mut recog.err_handler)?;

			/*InvokeRule sourceRegister*/
			recog.base.set_state(1638);
			recog.sourceRegister()?;

			recog.base.set_state(1639);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceRegister*/
			recog.base.set_state(1640);
			recog.instanceRegister()?;

			recog.base.set_state(1641);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceField*/
			recog.base.set_state(1642);
			recog.instanceField()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- iputObjectInstruction ----------------
pub type IputObjectInstructionContextAll<'input> = IputObjectInstructionContext<'input>;


pub type IputObjectInstructionContext<'input> = BaseParserRuleContext<'input,IputObjectInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IputObjectInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IputObjectInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IputObjectInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_iputObjectInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_iputObjectInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IputObjectInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_iputObjectInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_iputObjectInstruction }
}
antlr_rust::tid!{IputObjectInstructionContextExt<'a>}

impl<'input> IputObjectInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IputObjectInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IputObjectInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IputObjectInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IputObjectInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IPUT_OBJECT
/// Returns `None` if there is no child corresponding to token OP_IPUT_OBJECT
fn OP_IPUT_OBJECT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IPUT_OBJECT, 0)
}
fn sourceRegister(&self) -> Option<Rc<SourceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn instanceRegister(&self) -> Option<Rc<InstanceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn instanceField(&self) -> Option<Rc<InstanceFieldContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IputObjectInstructionContextAttrs<'input> for IputObjectInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn iputObjectInstruction(&mut self,)
	-> Result<Rc<IputObjectInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IputObjectInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 404, RULE_iputObjectInstruction);
        let mut _localctx: Rc<IputObjectInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1644);
			recog.base.match_token(OP_IPUT_OBJECT,&mut recog.err_handler)?;

			/*InvokeRule sourceRegister*/
			recog.base.set_state(1645);
			recog.sourceRegister()?;

			recog.base.set_state(1646);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceRegister*/
			recog.base.set_state(1647);
			recog.instanceRegister()?;

			recog.base.set_state(1648);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceField*/
			recog.base.set_state(1649);
			recog.instanceField()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- iputBooleanInstruction ----------------
pub type IputBooleanInstructionContextAll<'input> = IputBooleanInstructionContext<'input>;


pub type IputBooleanInstructionContext<'input> = BaseParserRuleContext<'input,IputBooleanInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IputBooleanInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IputBooleanInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IputBooleanInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_iputBooleanInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_iputBooleanInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IputBooleanInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_iputBooleanInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_iputBooleanInstruction }
}
antlr_rust::tid!{IputBooleanInstructionContextExt<'a>}

impl<'input> IputBooleanInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IputBooleanInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IputBooleanInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IputBooleanInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IputBooleanInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IPUT_BOOLEAN
/// Returns `None` if there is no child corresponding to token OP_IPUT_BOOLEAN
fn OP_IPUT_BOOLEAN(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IPUT_BOOLEAN, 0)
}
fn sourceRegister(&self) -> Option<Rc<SourceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn instanceRegister(&self) -> Option<Rc<InstanceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn instanceField(&self) -> Option<Rc<InstanceFieldContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IputBooleanInstructionContextAttrs<'input> for IputBooleanInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn iputBooleanInstruction(&mut self,)
	-> Result<Rc<IputBooleanInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IputBooleanInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 406, RULE_iputBooleanInstruction);
        let mut _localctx: Rc<IputBooleanInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1651);
			recog.base.match_token(OP_IPUT_BOOLEAN,&mut recog.err_handler)?;

			/*InvokeRule sourceRegister*/
			recog.base.set_state(1652);
			recog.sourceRegister()?;

			recog.base.set_state(1653);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceRegister*/
			recog.base.set_state(1654);
			recog.instanceRegister()?;

			recog.base.set_state(1655);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceField*/
			recog.base.set_state(1656);
			recog.instanceField()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- iputByteInstruction ----------------
pub type IputByteInstructionContextAll<'input> = IputByteInstructionContext<'input>;


pub type IputByteInstructionContext<'input> = BaseParserRuleContext<'input,IputByteInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IputByteInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IputByteInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IputByteInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_iputByteInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_iputByteInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IputByteInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_iputByteInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_iputByteInstruction }
}
antlr_rust::tid!{IputByteInstructionContextExt<'a>}

impl<'input> IputByteInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IputByteInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IputByteInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IputByteInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IputByteInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IPUT_BYTE
/// Returns `None` if there is no child corresponding to token OP_IPUT_BYTE
fn OP_IPUT_BYTE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IPUT_BYTE, 0)
}
fn sourceRegister(&self) -> Option<Rc<SourceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn instanceRegister(&self) -> Option<Rc<InstanceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn instanceField(&self) -> Option<Rc<InstanceFieldContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IputByteInstructionContextAttrs<'input> for IputByteInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn iputByteInstruction(&mut self,)
	-> Result<Rc<IputByteInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IputByteInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 408, RULE_iputByteInstruction);
        let mut _localctx: Rc<IputByteInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1658);
			recog.base.match_token(OP_IPUT_BYTE,&mut recog.err_handler)?;

			/*InvokeRule sourceRegister*/
			recog.base.set_state(1659);
			recog.sourceRegister()?;

			recog.base.set_state(1660);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceRegister*/
			recog.base.set_state(1661);
			recog.instanceRegister()?;

			recog.base.set_state(1662);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceField*/
			recog.base.set_state(1663);
			recog.instanceField()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- iputCharInstruction ----------------
pub type IputCharInstructionContextAll<'input> = IputCharInstructionContext<'input>;


pub type IputCharInstructionContext<'input> = BaseParserRuleContext<'input,IputCharInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IputCharInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IputCharInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IputCharInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_iputCharInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_iputCharInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IputCharInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_iputCharInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_iputCharInstruction }
}
antlr_rust::tid!{IputCharInstructionContextExt<'a>}

impl<'input> IputCharInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IputCharInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IputCharInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IputCharInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IputCharInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IPUT_CHAR
/// Returns `None` if there is no child corresponding to token OP_IPUT_CHAR
fn OP_IPUT_CHAR(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IPUT_CHAR, 0)
}
fn sourceRegister(&self) -> Option<Rc<SourceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn instanceRegister(&self) -> Option<Rc<InstanceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn instanceField(&self) -> Option<Rc<InstanceFieldContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IputCharInstructionContextAttrs<'input> for IputCharInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn iputCharInstruction(&mut self,)
	-> Result<Rc<IputCharInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IputCharInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 410, RULE_iputCharInstruction);
        let mut _localctx: Rc<IputCharInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1665);
			recog.base.match_token(OP_IPUT_CHAR,&mut recog.err_handler)?;

			/*InvokeRule sourceRegister*/
			recog.base.set_state(1666);
			recog.sourceRegister()?;

			recog.base.set_state(1667);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceRegister*/
			recog.base.set_state(1668);
			recog.instanceRegister()?;

			recog.base.set_state(1669);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceField*/
			recog.base.set_state(1670);
			recog.instanceField()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- iputShortInstruction ----------------
pub type IputShortInstructionContextAll<'input> = IputShortInstructionContext<'input>;


pub type IputShortInstructionContext<'input> = BaseParserRuleContext<'input,IputShortInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct IputShortInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for IputShortInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for IputShortInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_iputShortInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_iputShortInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for IputShortInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_iputShortInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_iputShortInstruction }
}
antlr_rust::tid!{IputShortInstructionContextExt<'a>}

impl<'input> IputShortInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IputShortInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IputShortInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IputShortInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<IputShortInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_IPUT_SHORT
/// Returns `None` if there is no child corresponding to token OP_IPUT_SHORT
fn OP_IPUT_SHORT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_IPUT_SHORT, 0)
}
fn sourceRegister(&self) -> Option<Rc<SourceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn instanceRegister(&self) -> Option<Rc<InstanceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn instanceField(&self) -> Option<Rc<InstanceFieldContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IputShortInstructionContextAttrs<'input> for IputShortInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn iputShortInstruction(&mut self,)
	-> Result<Rc<IputShortInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IputShortInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 412, RULE_iputShortInstruction);
        let mut _localctx: Rc<IputShortInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1672);
			recog.base.match_token(OP_IPUT_SHORT,&mut recog.err_handler)?;

			/*InvokeRule sourceRegister*/
			recog.base.set_state(1673);
			recog.sourceRegister()?;

			recog.base.set_state(1674);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceRegister*/
			recog.base.set_state(1675);
			recog.instanceRegister()?;

			recog.base.set_state(1676);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceField*/
			recog.base.set_state(1677);
			recog.instanceField()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- addIntInstruction ----------------
pub type AddIntInstructionContextAll<'input> = AddIntInstructionContext<'input>;


pub type AddIntInstructionContext<'input> = BaseParserRuleContext<'input,AddIntInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AddIntInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AddIntInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AddIntInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_addIntInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_addIntInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AddIntInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_addIntInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_addIntInstruction }
}
antlr_rust::tid!{AddIntInstructionContextExt<'a>}

impl<'input> AddIntInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AddIntInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AddIntInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AddIntInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AddIntInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_ADD_INT
/// Returns `None` if there is no child corresponding to token OP_ADD_INT
fn OP_ADD_INT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_ADD_INT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AddIntInstructionContextAttrs<'input> for AddIntInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn addIntInstruction(&mut self,)
	-> Result<Rc<AddIntInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AddIntInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 414, RULE_addIntInstruction);
        let mut _localctx: Rc<AddIntInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1679);
			recog.base.match_token(OP_ADD_INT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1680);
			recog.targetRegister()?;

			recog.base.set_state(1681);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1682);
			recog.leftRegister()?;

			recog.base.set_state(1683);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1684);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- subIntInstruction ----------------
pub type SubIntInstructionContextAll<'input> = SubIntInstructionContext<'input>;


pub type SubIntInstructionContext<'input> = BaseParserRuleContext<'input,SubIntInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SubIntInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SubIntInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SubIntInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_subIntInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_subIntInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SubIntInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_subIntInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_subIntInstruction }
}
antlr_rust::tid!{SubIntInstructionContextExt<'a>}

impl<'input> SubIntInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SubIntInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SubIntInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SubIntInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SubIntInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SUB_INT
/// Returns `None` if there is no child corresponding to token OP_SUB_INT
fn OP_SUB_INT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SUB_INT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SubIntInstructionContextAttrs<'input> for SubIntInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn subIntInstruction(&mut self,)
	-> Result<Rc<SubIntInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SubIntInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 416, RULE_subIntInstruction);
        let mut _localctx: Rc<SubIntInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1686);
			recog.base.match_token(OP_SUB_INT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1687);
			recog.targetRegister()?;

			recog.base.set_state(1688);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1689);
			recog.leftRegister()?;

			recog.base.set_state(1690);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1691);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- mulIntInstruction ----------------
pub type MulIntInstructionContextAll<'input> = MulIntInstructionContext<'input>;


pub type MulIntInstructionContext<'input> = BaseParserRuleContext<'input,MulIntInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MulIntInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MulIntInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MulIntInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_mulIntInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_mulIntInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MulIntInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_mulIntInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_mulIntInstruction }
}
antlr_rust::tid!{MulIntInstructionContextExt<'a>}

impl<'input> MulIntInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MulIntInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MulIntInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MulIntInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MulIntInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MUL_INT
/// Returns `None` if there is no child corresponding to token OP_MUL_INT
fn OP_MUL_INT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MUL_INT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MulIntInstructionContextAttrs<'input> for MulIntInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn mulIntInstruction(&mut self,)
	-> Result<Rc<MulIntInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MulIntInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 418, RULE_mulIntInstruction);
        let mut _localctx: Rc<MulIntInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1693);
			recog.base.match_token(OP_MUL_INT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1694);
			recog.targetRegister()?;

			recog.base.set_state(1695);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1696);
			recog.leftRegister()?;

			recog.base.set_state(1697);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1698);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- divIntInstruction ----------------
pub type DivIntInstructionContextAll<'input> = DivIntInstructionContext<'input>;


pub type DivIntInstructionContext<'input> = BaseParserRuleContext<'input,DivIntInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct DivIntInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for DivIntInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for DivIntInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_divIntInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_divIntInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DivIntInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_divIntInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_divIntInstruction }
}
antlr_rust::tid!{DivIntInstructionContextExt<'a>}

impl<'input> DivIntInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DivIntInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DivIntInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DivIntInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<DivIntInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_DIV_INT
/// Returns `None` if there is no child corresponding to token OP_DIV_INT
fn OP_DIV_INT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_DIV_INT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DivIntInstructionContextAttrs<'input> for DivIntInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn divIntInstruction(&mut self,)
	-> Result<Rc<DivIntInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DivIntInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 420, RULE_divIntInstruction);
        let mut _localctx: Rc<DivIntInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1700);
			recog.base.match_token(OP_DIV_INT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1701);
			recog.targetRegister()?;

			recog.base.set_state(1702);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1703);
			recog.leftRegister()?;

			recog.base.set_state(1704);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1705);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- remIntInstruction ----------------
pub type RemIntInstructionContextAll<'input> = RemIntInstructionContext<'input>;


pub type RemIntInstructionContext<'input> = BaseParserRuleContext<'input,RemIntInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct RemIntInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for RemIntInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for RemIntInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_remIntInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_remIntInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RemIntInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_remIntInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_remIntInstruction }
}
antlr_rust::tid!{RemIntInstructionContextExt<'a>}

impl<'input> RemIntInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RemIntInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RemIntInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RemIntInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<RemIntInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_REM_INT
/// Returns `None` if there is no child corresponding to token OP_REM_INT
fn OP_REM_INT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_REM_INT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RemIntInstructionContextAttrs<'input> for RemIntInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn remIntInstruction(&mut self,)
	-> Result<Rc<RemIntInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RemIntInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 422, RULE_remIntInstruction);
        let mut _localctx: Rc<RemIntInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1707);
			recog.base.match_token(OP_REM_INT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1708);
			recog.targetRegister()?;

			recog.base.set_state(1709);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1710);
			recog.leftRegister()?;

			recog.base.set_state(1711);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1712);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- andIntInstruction ----------------
pub type AndIntInstructionContextAll<'input> = AndIntInstructionContext<'input>;


pub type AndIntInstructionContext<'input> = BaseParserRuleContext<'input,AndIntInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AndIntInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AndIntInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AndIntInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_andIntInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_andIntInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AndIntInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_andIntInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_andIntInstruction }
}
antlr_rust::tid!{AndIntInstructionContextExt<'a>}

impl<'input> AndIntInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AndIntInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AndIntInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AndIntInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AndIntInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_AND_INT
/// Returns `None` if there is no child corresponding to token OP_AND_INT
fn OP_AND_INT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_AND_INT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AndIntInstructionContextAttrs<'input> for AndIntInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn andIntInstruction(&mut self,)
	-> Result<Rc<AndIntInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AndIntInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 424, RULE_andIntInstruction);
        let mut _localctx: Rc<AndIntInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1714);
			recog.base.match_token(OP_AND_INT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1715);
			recog.targetRegister()?;

			recog.base.set_state(1716);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1717);
			recog.leftRegister()?;

			recog.base.set_state(1718);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1719);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- orIntInstruction ----------------
pub type OrIntInstructionContextAll<'input> = OrIntInstructionContext<'input>;


pub type OrIntInstructionContext<'input> = BaseParserRuleContext<'input,OrIntInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct OrIntInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for OrIntInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for OrIntInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_orIntInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_orIntInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for OrIntInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_orIntInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_orIntInstruction }
}
antlr_rust::tid!{OrIntInstructionContextExt<'a>}

impl<'input> OrIntInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OrIntInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OrIntInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OrIntInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<OrIntInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_OR_INT
/// Returns `None` if there is no child corresponding to token OP_OR_INT
fn OP_OR_INT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_OR_INT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> OrIntInstructionContextAttrs<'input> for OrIntInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn orIntInstruction(&mut self,)
	-> Result<Rc<OrIntInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OrIntInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 426, RULE_orIntInstruction);
        let mut _localctx: Rc<OrIntInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1721);
			recog.base.match_token(OP_OR_INT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1722);
			recog.targetRegister()?;

			recog.base.set_state(1723);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1724);
			recog.leftRegister()?;

			recog.base.set_state(1725);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1726);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- xorIntInstruction ----------------
pub type XorIntInstructionContextAll<'input> = XorIntInstructionContext<'input>;


pub type XorIntInstructionContext<'input> = BaseParserRuleContext<'input,XorIntInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct XorIntInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for XorIntInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for XorIntInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_xorIntInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_xorIntInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for XorIntInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_xorIntInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_xorIntInstruction }
}
antlr_rust::tid!{XorIntInstructionContextExt<'a>}

impl<'input> XorIntInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<XorIntInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,XorIntInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait XorIntInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<XorIntInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_XOR_INT
/// Returns `None` if there is no child corresponding to token OP_XOR_INT
fn OP_XOR_INT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_XOR_INT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> XorIntInstructionContextAttrs<'input> for XorIntInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn xorIntInstruction(&mut self,)
	-> Result<Rc<XorIntInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = XorIntInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 428, RULE_xorIntInstruction);
        let mut _localctx: Rc<XorIntInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1728);
			recog.base.match_token(OP_XOR_INT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1729);
			recog.targetRegister()?;

			recog.base.set_state(1730);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1731);
			recog.leftRegister()?;

			recog.base.set_state(1732);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1733);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- shlIntInstruction ----------------
pub type ShlIntInstructionContextAll<'input> = ShlIntInstructionContext<'input>;


pub type ShlIntInstructionContext<'input> = BaseParserRuleContext<'input,ShlIntInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ShlIntInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ShlIntInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ShlIntInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_shlIntInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_shlIntInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ShlIntInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_shlIntInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_shlIntInstruction }
}
antlr_rust::tid!{ShlIntInstructionContextExt<'a>}

impl<'input> ShlIntInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ShlIntInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ShlIntInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ShlIntInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ShlIntInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SHL_INT
/// Returns `None` if there is no child corresponding to token OP_SHL_INT
fn OP_SHL_INT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SHL_INT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ShlIntInstructionContextAttrs<'input> for ShlIntInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn shlIntInstruction(&mut self,)
	-> Result<Rc<ShlIntInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ShlIntInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 430, RULE_shlIntInstruction);
        let mut _localctx: Rc<ShlIntInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1735);
			recog.base.match_token(OP_SHL_INT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1736);
			recog.targetRegister()?;

			recog.base.set_state(1737);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1738);
			recog.leftRegister()?;

			recog.base.set_state(1739);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1740);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- shrIntInstruction ----------------
pub type ShrIntInstructionContextAll<'input> = ShrIntInstructionContext<'input>;


pub type ShrIntInstructionContext<'input> = BaseParserRuleContext<'input,ShrIntInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ShrIntInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ShrIntInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ShrIntInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_shrIntInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_shrIntInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ShrIntInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_shrIntInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_shrIntInstruction }
}
antlr_rust::tid!{ShrIntInstructionContextExt<'a>}

impl<'input> ShrIntInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ShrIntInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ShrIntInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ShrIntInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ShrIntInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SHR_INT
/// Returns `None` if there is no child corresponding to token OP_SHR_INT
fn OP_SHR_INT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SHR_INT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ShrIntInstructionContextAttrs<'input> for ShrIntInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn shrIntInstruction(&mut self,)
	-> Result<Rc<ShrIntInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ShrIntInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 432, RULE_shrIntInstruction);
        let mut _localctx: Rc<ShrIntInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1742);
			recog.base.match_token(OP_SHR_INT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1743);
			recog.targetRegister()?;

			recog.base.set_state(1744);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1745);
			recog.leftRegister()?;

			recog.base.set_state(1746);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1747);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ushrIntInstruction ----------------
pub type UshrIntInstructionContextAll<'input> = UshrIntInstructionContext<'input>;


pub type UshrIntInstructionContext<'input> = BaseParserRuleContext<'input,UshrIntInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct UshrIntInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for UshrIntInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for UshrIntInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ushrIntInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_ushrIntInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UshrIntInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ushrIntInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ushrIntInstruction }
}
antlr_rust::tid!{UshrIntInstructionContextExt<'a>}

impl<'input> UshrIntInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UshrIntInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UshrIntInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UshrIntInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<UshrIntInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_USHR_INT
/// Returns `None` if there is no child corresponding to token OP_USHR_INT
fn OP_USHR_INT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_USHR_INT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UshrIntInstructionContextAttrs<'input> for UshrIntInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ushrIntInstruction(&mut self,)
	-> Result<Rc<UshrIntInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UshrIntInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 434, RULE_ushrIntInstruction);
        let mut _localctx: Rc<UshrIntInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1749);
			recog.base.match_token(OP_USHR_INT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1750);
			recog.targetRegister()?;

			recog.base.set_state(1751);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1752);
			recog.leftRegister()?;

			recog.base.set_state(1753);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1754);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- rsubIntInstruction ----------------
pub type RsubIntInstructionContextAll<'input> = RsubIntInstructionContext<'input>;


pub type RsubIntInstructionContext<'input> = BaseParserRuleContext<'input,RsubIntInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct RsubIntInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for RsubIntInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for RsubIntInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_rsubIntInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_rsubIntInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RsubIntInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_rsubIntInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_rsubIntInstruction }
}
antlr_rust::tid!{RsubIntInstructionContextExt<'a>}

impl<'input> RsubIntInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RsubIntInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RsubIntInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RsubIntInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<RsubIntInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_RSUB_INT
/// Returns `None` if there is no child corresponding to token OP_RSUB_INT
fn OP_RSUB_INT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_RSUB_INT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RsubIntInstructionContextAttrs<'input> for RsubIntInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn rsubIntInstruction(&mut self,)
	-> Result<Rc<RsubIntInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RsubIntInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 436, RULE_rsubIntInstruction);
        let mut _localctx: Rc<RsubIntInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1756);
			recog.base.match_token(OP_RSUB_INT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1757);
			recog.targetRegister()?;

			recog.base.set_state(1758);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1759);
			recog.leftRegister()?;

			recog.base.set_state(1760);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1761);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- addLongInstruction ----------------
pub type AddLongInstructionContextAll<'input> = AddLongInstructionContext<'input>;


pub type AddLongInstructionContext<'input> = BaseParserRuleContext<'input,AddLongInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AddLongInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AddLongInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AddLongInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_addLongInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_addLongInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AddLongInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_addLongInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_addLongInstruction }
}
antlr_rust::tid!{AddLongInstructionContextExt<'a>}

impl<'input> AddLongInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AddLongInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AddLongInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AddLongInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AddLongInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_ADD_LONG
/// Returns `None` if there is no child corresponding to token OP_ADD_LONG
fn OP_ADD_LONG(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_ADD_LONG, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AddLongInstructionContextAttrs<'input> for AddLongInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn addLongInstruction(&mut self,)
	-> Result<Rc<AddLongInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AddLongInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 438, RULE_addLongInstruction);
        let mut _localctx: Rc<AddLongInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1763);
			recog.base.match_token(OP_ADD_LONG,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1764);
			recog.targetRegister()?;

			recog.base.set_state(1765);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1766);
			recog.leftRegister()?;

			recog.base.set_state(1767);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1768);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- subLongInstruction ----------------
pub type SubLongInstructionContextAll<'input> = SubLongInstructionContext<'input>;


pub type SubLongInstructionContext<'input> = BaseParserRuleContext<'input,SubLongInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SubLongInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SubLongInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SubLongInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_subLongInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_subLongInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SubLongInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_subLongInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_subLongInstruction }
}
antlr_rust::tid!{SubLongInstructionContextExt<'a>}

impl<'input> SubLongInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SubLongInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SubLongInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SubLongInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SubLongInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SUB_LONG
/// Returns `None` if there is no child corresponding to token OP_SUB_LONG
fn OP_SUB_LONG(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SUB_LONG, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SubLongInstructionContextAttrs<'input> for SubLongInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn subLongInstruction(&mut self,)
	-> Result<Rc<SubLongInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SubLongInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 440, RULE_subLongInstruction);
        let mut _localctx: Rc<SubLongInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1770);
			recog.base.match_token(OP_SUB_LONG,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1771);
			recog.targetRegister()?;

			recog.base.set_state(1772);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1773);
			recog.leftRegister()?;

			recog.base.set_state(1774);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1775);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- mulLongInstruction ----------------
pub type MulLongInstructionContextAll<'input> = MulLongInstructionContext<'input>;


pub type MulLongInstructionContext<'input> = BaseParserRuleContext<'input,MulLongInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MulLongInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MulLongInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MulLongInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_mulLongInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_mulLongInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MulLongInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_mulLongInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_mulLongInstruction }
}
antlr_rust::tid!{MulLongInstructionContextExt<'a>}

impl<'input> MulLongInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MulLongInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MulLongInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MulLongInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MulLongInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MUL_LONG
/// Returns `None` if there is no child corresponding to token OP_MUL_LONG
fn OP_MUL_LONG(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MUL_LONG, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MulLongInstructionContextAttrs<'input> for MulLongInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn mulLongInstruction(&mut self,)
	-> Result<Rc<MulLongInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MulLongInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 442, RULE_mulLongInstruction);
        let mut _localctx: Rc<MulLongInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1777);
			recog.base.match_token(OP_MUL_LONG,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1778);
			recog.targetRegister()?;

			recog.base.set_state(1779);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1780);
			recog.leftRegister()?;

			recog.base.set_state(1781);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1782);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- divLongInstruction ----------------
pub type DivLongInstructionContextAll<'input> = DivLongInstructionContext<'input>;


pub type DivLongInstructionContext<'input> = BaseParserRuleContext<'input,DivLongInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct DivLongInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for DivLongInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for DivLongInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_divLongInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_divLongInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DivLongInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_divLongInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_divLongInstruction }
}
antlr_rust::tid!{DivLongInstructionContextExt<'a>}

impl<'input> DivLongInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DivLongInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DivLongInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DivLongInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<DivLongInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_DIV_LONG
/// Returns `None` if there is no child corresponding to token OP_DIV_LONG
fn OP_DIV_LONG(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_DIV_LONG, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DivLongInstructionContextAttrs<'input> for DivLongInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn divLongInstruction(&mut self,)
	-> Result<Rc<DivLongInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DivLongInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 444, RULE_divLongInstruction);
        let mut _localctx: Rc<DivLongInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1784);
			recog.base.match_token(OP_DIV_LONG,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1785);
			recog.targetRegister()?;

			recog.base.set_state(1786);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1787);
			recog.leftRegister()?;

			recog.base.set_state(1788);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1789);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- remLongInstruction ----------------
pub type RemLongInstructionContextAll<'input> = RemLongInstructionContext<'input>;


pub type RemLongInstructionContext<'input> = BaseParserRuleContext<'input,RemLongInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct RemLongInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for RemLongInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for RemLongInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_remLongInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_remLongInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RemLongInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_remLongInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_remLongInstruction }
}
antlr_rust::tid!{RemLongInstructionContextExt<'a>}

impl<'input> RemLongInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RemLongInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RemLongInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RemLongInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<RemLongInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_REM_LONG
/// Returns `None` if there is no child corresponding to token OP_REM_LONG
fn OP_REM_LONG(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_REM_LONG, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RemLongInstructionContextAttrs<'input> for RemLongInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn remLongInstruction(&mut self,)
	-> Result<Rc<RemLongInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RemLongInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 446, RULE_remLongInstruction);
        let mut _localctx: Rc<RemLongInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1791);
			recog.base.match_token(OP_REM_LONG,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1792);
			recog.targetRegister()?;

			recog.base.set_state(1793);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1794);
			recog.leftRegister()?;

			recog.base.set_state(1795);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1796);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- andLongInstruction ----------------
pub type AndLongInstructionContextAll<'input> = AndLongInstructionContext<'input>;


pub type AndLongInstructionContext<'input> = BaseParserRuleContext<'input,AndLongInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AndLongInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AndLongInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AndLongInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_andLongInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_andLongInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AndLongInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_andLongInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_andLongInstruction }
}
antlr_rust::tid!{AndLongInstructionContextExt<'a>}

impl<'input> AndLongInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AndLongInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AndLongInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AndLongInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AndLongInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_AND_LONG
/// Returns `None` if there is no child corresponding to token OP_AND_LONG
fn OP_AND_LONG(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_AND_LONG, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AndLongInstructionContextAttrs<'input> for AndLongInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn andLongInstruction(&mut self,)
	-> Result<Rc<AndLongInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AndLongInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 448, RULE_andLongInstruction);
        let mut _localctx: Rc<AndLongInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1798);
			recog.base.match_token(OP_AND_LONG,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1799);
			recog.targetRegister()?;

			recog.base.set_state(1800);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1801);
			recog.leftRegister()?;

			recog.base.set_state(1802);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1803);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- orLongInstruction ----------------
pub type OrLongInstructionContextAll<'input> = OrLongInstructionContext<'input>;


pub type OrLongInstructionContext<'input> = BaseParserRuleContext<'input,OrLongInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct OrLongInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for OrLongInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for OrLongInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_orLongInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_orLongInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for OrLongInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_orLongInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_orLongInstruction }
}
antlr_rust::tid!{OrLongInstructionContextExt<'a>}

impl<'input> OrLongInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OrLongInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OrLongInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OrLongInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<OrLongInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_OR_LONG
/// Returns `None` if there is no child corresponding to token OP_OR_LONG
fn OP_OR_LONG(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_OR_LONG, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> OrLongInstructionContextAttrs<'input> for OrLongInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn orLongInstruction(&mut self,)
	-> Result<Rc<OrLongInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OrLongInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 450, RULE_orLongInstruction);
        let mut _localctx: Rc<OrLongInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1805);
			recog.base.match_token(OP_OR_LONG,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1806);
			recog.targetRegister()?;

			recog.base.set_state(1807);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1808);
			recog.leftRegister()?;

			recog.base.set_state(1809);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1810);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- xorLongInstruction ----------------
pub type XorLongInstructionContextAll<'input> = XorLongInstructionContext<'input>;


pub type XorLongInstructionContext<'input> = BaseParserRuleContext<'input,XorLongInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct XorLongInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for XorLongInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for XorLongInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_xorLongInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_xorLongInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for XorLongInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_xorLongInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_xorLongInstruction }
}
antlr_rust::tid!{XorLongInstructionContextExt<'a>}

impl<'input> XorLongInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<XorLongInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,XorLongInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait XorLongInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<XorLongInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_XOR_LONG
/// Returns `None` if there is no child corresponding to token OP_XOR_LONG
fn OP_XOR_LONG(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_XOR_LONG, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> XorLongInstructionContextAttrs<'input> for XorLongInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn xorLongInstruction(&mut self,)
	-> Result<Rc<XorLongInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = XorLongInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 452, RULE_xorLongInstruction);
        let mut _localctx: Rc<XorLongInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1812);
			recog.base.match_token(OP_XOR_LONG,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1813);
			recog.targetRegister()?;

			recog.base.set_state(1814);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1815);
			recog.leftRegister()?;

			recog.base.set_state(1816);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1817);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- shlLongInstruction ----------------
pub type ShlLongInstructionContextAll<'input> = ShlLongInstructionContext<'input>;


pub type ShlLongInstructionContext<'input> = BaseParserRuleContext<'input,ShlLongInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ShlLongInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ShlLongInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ShlLongInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_shlLongInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_shlLongInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ShlLongInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_shlLongInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_shlLongInstruction }
}
antlr_rust::tid!{ShlLongInstructionContextExt<'a>}

impl<'input> ShlLongInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ShlLongInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ShlLongInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ShlLongInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ShlLongInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SHL_LONG
/// Returns `None` if there is no child corresponding to token OP_SHL_LONG
fn OP_SHL_LONG(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SHL_LONG, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ShlLongInstructionContextAttrs<'input> for ShlLongInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn shlLongInstruction(&mut self,)
	-> Result<Rc<ShlLongInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ShlLongInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 454, RULE_shlLongInstruction);
        let mut _localctx: Rc<ShlLongInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1819);
			recog.base.match_token(OP_SHL_LONG,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1820);
			recog.targetRegister()?;

			recog.base.set_state(1821);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1822);
			recog.leftRegister()?;

			recog.base.set_state(1823);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1824);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- shrLongInstruction ----------------
pub type ShrLongInstructionContextAll<'input> = ShrLongInstructionContext<'input>;


pub type ShrLongInstructionContext<'input> = BaseParserRuleContext<'input,ShrLongInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ShrLongInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ShrLongInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ShrLongInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_shrLongInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_shrLongInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ShrLongInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_shrLongInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_shrLongInstruction }
}
antlr_rust::tid!{ShrLongInstructionContextExt<'a>}

impl<'input> ShrLongInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ShrLongInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ShrLongInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ShrLongInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ShrLongInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SHR_LONG
/// Returns `None` if there is no child corresponding to token OP_SHR_LONG
fn OP_SHR_LONG(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SHR_LONG, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ShrLongInstructionContextAttrs<'input> for ShrLongInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn shrLongInstruction(&mut self,)
	-> Result<Rc<ShrLongInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ShrLongInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 456, RULE_shrLongInstruction);
        let mut _localctx: Rc<ShrLongInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1826);
			recog.base.match_token(OP_SHR_LONG,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1827);
			recog.targetRegister()?;

			recog.base.set_state(1828);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1829);
			recog.leftRegister()?;

			recog.base.set_state(1830);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1831);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ushrLongInstruction ----------------
pub type UshrLongInstructionContextAll<'input> = UshrLongInstructionContext<'input>;


pub type UshrLongInstructionContext<'input> = BaseParserRuleContext<'input,UshrLongInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct UshrLongInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for UshrLongInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for UshrLongInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ushrLongInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_ushrLongInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UshrLongInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ushrLongInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ushrLongInstruction }
}
antlr_rust::tid!{UshrLongInstructionContextExt<'a>}

impl<'input> UshrLongInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UshrLongInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UshrLongInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UshrLongInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<UshrLongInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_USHR_LONG
/// Returns `None` if there is no child corresponding to token OP_USHR_LONG
fn OP_USHR_LONG(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_USHR_LONG, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UshrLongInstructionContextAttrs<'input> for UshrLongInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ushrLongInstruction(&mut self,)
	-> Result<Rc<UshrLongInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UshrLongInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 458, RULE_ushrLongInstruction);
        let mut _localctx: Rc<UshrLongInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1833);
			recog.base.match_token(OP_USHR_LONG,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1834);
			recog.targetRegister()?;

			recog.base.set_state(1835);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1836);
			recog.leftRegister()?;

			recog.base.set_state(1837);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1838);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- addFloatInstruction ----------------
pub type AddFloatInstructionContextAll<'input> = AddFloatInstructionContext<'input>;


pub type AddFloatInstructionContext<'input> = BaseParserRuleContext<'input,AddFloatInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AddFloatInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AddFloatInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AddFloatInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_addFloatInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_addFloatInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AddFloatInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_addFloatInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_addFloatInstruction }
}
antlr_rust::tid!{AddFloatInstructionContextExt<'a>}

impl<'input> AddFloatInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AddFloatInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AddFloatInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AddFloatInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AddFloatInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_ADD_FLOAT
/// Returns `None` if there is no child corresponding to token OP_ADD_FLOAT
fn OP_ADD_FLOAT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_ADD_FLOAT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AddFloatInstructionContextAttrs<'input> for AddFloatInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn addFloatInstruction(&mut self,)
	-> Result<Rc<AddFloatInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AddFloatInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 460, RULE_addFloatInstruction);
        let mut _localctx: Rc<AddFloatInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1840);
			recog.base.match_token(OP_ADD_FLOAT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1841);
			recog.targetRegister()?;

			recog.base.set_state(1842);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1843);
			recog.leftRegister()?;

			recog.base.set_state(1844);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1845);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- subFloatInstruction ----------------
pub type SubFloatInstructionContextAll<'input> = SubFloatInstructionContext<'input>;


pub type SubFloatInstructionContext<'input> = BaseParserRuleContext<'input,SubFloatInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SubFloatInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SubFloatInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SubFloatInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_subFloatInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_subFloatInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SubFloatInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_subFloatInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_subFloatInstruction }
}
antlr_rust::tid!{SubFloatInstructionContextExt<'a>}

impl<'input> SubFloatInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SubFloatInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SubFloatInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SubFloatInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SubFloatInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SUB_FLOAT
/// Returns `None` if there is no child corresponding to token OP_SUB_FLOAT
fn OP_SUB_FLOAT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SUB_FLOAT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SubFloatInstructionContextAttrs<'input> for SubFloatInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn subFloatInstruction(&mut self,)
	-> Result<Rc<SubFloatInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SubFloatInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 462, RULE_subFloatInstruction);
        let mut _localctx: Rc<SubFloatInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1847);
			recog.base.match_token(OP_SUB_FLOAT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1848);
			recog.targetRegister()?;

			recog.base.set_state(1849);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1850);
			recog.leftRegister()?;

			recog.base.set_state(1851);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1852);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- mulFloatInstruction ----------------
pub type MulFloatInstructionContextAll<'input> = MulFloatInstructionContext<'input>;


pub type MulFloatInstructionContext<'input> = BaseParserRuleContext<'input,MulFloatInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MulFloatInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MulFloatInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MulFloatInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_mulFloatInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_mulFloatInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MulFloatInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_mulFloatInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_mulFloatInstruction }
}
antlr_rust::tid!{MulFloatInstructionContextExt<'a>}

impl<'input> MulFloatInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MulFloatInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MulFloatInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MulFloatInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MulFloatInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MUL_FLOAT
/// Returns `None` if there is no child corresponding to token OP_MUL_FLOAT
fn OP_MUL_FLOAT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MUL_FLOAT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MulFloatInstructionContextAttrs<'input> for MulFloatInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn mulFloatInstruction(&mut self,)
	-> Result<Rc<MulFloatInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MulFloatInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 464, RULE_mulFloatInstruction);
        let mut _localctx: Rc<MulFloatInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1854);
			recog.base.match_token(OP_MUL_FLOAT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1855);
			recog.targetRegister()?;

			recog.base.set_state(1856);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1857);
			recog.leftRegister()?;

			recog.base.set_state(1858);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1859);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- divFloatInstruction ----------------
pub type DivFloatInstructionContextAll<'input> = DivFloatInstructionContext<'input>;


pub type DivFloatInstructionContext<'input> = BaseParserRuleContext<'input,DivFloatInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct DivFloatInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for DivFloatInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for DivFloatInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_divFloatInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_divFloatInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DivFloatInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_divFloatInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_divFloatInstruction }
}
antlr_rust::tid!{DivFloatInstructionContextExt<'a>}

impl<'input> DivFloatInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DivFloatInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DivFloatInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DivFloatInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<DivFloatInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_DIV_FLOAT
/// Returns `None` if there is no child corresponding to token OP_DIV_FLOAT
fn OP_DIV_FLOAT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_DIV_FLOAT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DivFloatInstructionContextAttrs<'input> for DivFloatInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn divFloatInstruction(&mut self,)
	-> Result<Rc<DivFloatInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DivFloatInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 466, RULE_divFloatInstruction);
        let mut _localctx: Rc<DivFloatInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1861);
			recog.base.match_token(OP_DIV_FLOAT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1862);
			recog.targetRegister()?;

			recog.base.set_state(1863);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1864);
			recog.leftRegister()?;

			recog.base.set_state(1865);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1866);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- remFloatInstruction ----------------
pub type RemFloatInstructionContextAll<'input> = RemFloatInstructionContext<'input>;


pub type RemFloatInstructionContext<'input> = BaseParserRuleContext<'input,RemFloatInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct RemFloatInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for RemFloatInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for RemFloatInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_remFloatInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_remFloatInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RemFloatInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_remFloatInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_remFloatInstruction }
}
antlr_rust::tid!{RemFloatInstructionContextExt<'a>}

impl<'input> RemFloatInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RemFloatInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RemFloatInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RemFloatInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<RemFloatInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_REM_FLOAT
/// Returns `None` if there is no child corresponding to token OP_REM_FLOAT
fn OP_REM_FLOAT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_REM_FLOAT, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RemFloatInstructionContextAttrs<'input> for RemFloatInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn remFloatInstruction(&mut self,)
	-> Result<Rc<RemFloatInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RemFloatInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 468, RULE_remFloatInstruction);
        let mut _localctx: Rc<RemFloatInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1868);
			recog.base.match_token(OP_REM_FLOAT,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1869);
			recog.targetRegister()?;

			recog.base.set_state(1870);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1871);
			recog.leftRegister()?;

			recog.base.set_state(1872);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1873);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- addDoubleInstruction ----------------
pub type AddDoubleInstructionContextAll<'input> = AddDoubleInstructionContext<'input>;


pub type AddDoubleInstructionContext<'input> = BaseParserRuleContext<'input,AddDoubleInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AddDoubleInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AddDoubleInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AddDoubleInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_addDoubleInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_addDoubleInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AddDoubleInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_addDoubleInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_addDoubleInstruction }
}
antlr_rust::tid!{AddDoubleInstructionContextExt<'a>}

impl<'input> AddDoubleInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AddDoubleInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AddDoubleInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AddDoubleInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AddDoubleInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_ADD_DOUBLE
/// Returns `None` if there is no child corresponding to token OP_ADD_DOUBLE
fn OP_ADD_DOUBLE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_ADD_DOUBLE, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AddDoubleInstructionContextAttrs<'input> for AddDoubleInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn addDoubleInstruction(&mut self,)
	-> Result<Rc<AddDoubleInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AddDoubleInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 470, RULE_addDoubleInstruction);
        let mut _localctx: Rc<AddDoubleInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1875);
			recog.base.match_token(OP_ADD_DOUBLE,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1876);
			recog.targetRegister()?;

			recog.base.set_state(1877);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1878);
			recog.leftRegister()?;

			recog.base.set_state(1879);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1880);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- subDoubleInstruction ----------------
pub type SubDoubleInstructionContextAll<'input> = SubDoubleInstructionContext<'input>;


pub type SubDoubleInstructionContext<'input> = BaseParserRuleContext<'input,SubDoubleInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SubDoubleInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SubDoubleInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SubDoubleInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_subDoubleInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_subDoubleInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SubDoubleInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_subDoubleInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_subDoubleInstruction }
}
antlr_rust::tid!{SubDoubleInstructionContextExt<'a>}

impl<'input> SubDoubleInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SubDoubleInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SubDoubleInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SubDoubleInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SubDoubleInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SUB_DOUBLE
/// Returns `None` if there is no child corresponding to token OP_SUB_DOUBLE
fn OP_SUB_DOUBLE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SUB_DOUBLE, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SubDoubleInstructionContextAttrs<'input> for SubDoubleInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn subDoubleInstruction(&mut self,)
	-> Result<Rc<SubDoubleInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SubDoubleInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 472, RULE_subDoubleInstruction);
        let mut _localctx: Rc<SubDoubleInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1882);
			recog.base.match_token(OP_SUB_DOUBLE,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1883);
			recog.targetRegister()?;

			recog.base.set_state(1884);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1885);
			recog.leftRegister()?;

			recog.base.set_state(1886);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1887);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- mulDoubleInstruction ----------------
pub type MulDoubleInstructionContextAll<'input> = MulDoubleInstructionContext<'input>;


pub type MulDoubleInstructionContext<'input> = BaseParserRuleContext<'input,MulDoubleInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MulDoubleInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MulDoubleInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MulDoubleInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_mulDoubleInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_mulDoubleInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MulDoubleInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_mulDoubleInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_mulDoubleInstruction }
}
antlr_rust::tid!{MulDoubleInstructionContextExt<'a>}

impl<'input> MulDoubleInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MulDoubleInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MulDoubleInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MulDoubleInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MulDoubleInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MUL_DOUBLE
/// Returns `None` if there is no child corresponding to token OP_MUL_DOUBLE
fn OP_MUL_DOUBLE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MUL_DOUBLE, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MulDoubleInstructionContextAttrs<'input> for MulDoubleInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn mulDoubleInstruction(&mut self,)
	-> Result<Rc<MulDoubleInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MulDoubleInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 474, RULE_mulDoubleInstruction);
        let mut _localctx: Rc<MulDoubleInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1889);
			recog.base.match_token(OP_MUL_DOUBLE,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1890);
			recog.targetRegister()?;

			recog.base.set_state(1891);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1892);
			recog.leftRegister()?;

			recog.base.set_state(1893);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1894);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- divDoubleInstruction ----------------
pub type DivDoubleInstructionContextAll<'input> = DivDoubleInstructionContext<'input>;


pub type DivDoubleInstructionContext<'input> = BaseParserRuleContext<'input,DivDoubleInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct DivDoubleInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for DivDoubleInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for DivDoubleInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_divDoubleInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_divDoubleInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DivDoubleInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_divDoubleInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_divDoubleInstruction }
}
antlr_rust::tid!{DivDoubleInstructionContextExt<'a>}

impl<'input> DivDoubleInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DivDoubleInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DivDoubleInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DivDoubleInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<DivDoubleInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_DIV_DOUBLE
/// Returns `None` if there is no child corresponding to token OP_DIV_DOUBLE
fn OP_DIV_DOUBLE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_DIV_DOUBLE, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DivDoubleInstructionContextAttrs<'input> for DivDoubleInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn divDoubleInstruction(&mut self,)
	-> Result<Rc<DivDoubleInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DivDoubleInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 476, RULE_divDoubleInstruction);
        let mut _localctx: Rc<DivDoubleInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1896);
			recog.base.match_token(OP_DIV_DOUBLE,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1897);
			recog.targetRegister()?;

			recog.base.set_state(1898);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1899);
			recog.leftRegister()?;

			recog.base.set_state(1900);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1901);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- remDoubleInstruction ----------------
pub type RemDoubleInstructionContextAll<'input> = RemDoubleInstructionContext<'input>;


pub type RemDoubleInstructionContext<'input> = BaseParserRuleContext<'input,RemDoubleInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct RemDoubleInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for RemDoubleInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for RemDoubleInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_remDoubleInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_remDoubleInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RemDoubleInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_remDoubleInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_remDoubleInstruction }
}
antlr_rust::tid!{RemDoubleInstructionContextExt<'a>}

impl<'input> RemDoubleInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RemDoubleInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RemDoubleInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RemDoubleInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<RemDoubleInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_REM_DOUBLE
/// Returns `None` if there is no child corresponding to token OP_REM_DOUBLE
fn OP_REM_DOUBLE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_REM_DOUBLE, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rightRegister(&self) -> Option<Rc<RightRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RemDoubleInstructionContextAttrs<'input> for RemDoubleInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn remDoubleInstruction(&mut self,)
	-> Result<Rc<RemDoubleInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RemDoubleInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 478, RULE_remDoubleInstruction);
        let mut _localctx: Rc<RemDoubleInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1903);
			recog.base.match_token(OP_REM_DOUBLE,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1904);
			recog.targetRegister()?;

			recog.base.set_state(1905);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1906);
			recog.leftRegister()?;

			recog.base.set_state(1907);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule rightRegister*/
			recog.base.set_state(1908);
			recog.rightRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- addIntLit16Instruction ----------------
pub type AddIntLit16InstructionContextAll<'input> = AddIntLit16InstructionContext<'input>;


pub type AddIntLit16InstructionContext<'input> = BaseParserRuleContext<'input,AddIntLit16InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AddIntLit16InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AddIntLit16InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AddIntLit16InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_addIntLit16Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_addIntLit16Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AddIntLit16InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_addIntLit16Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_addIntLit16Instruction }
}
antlr_rust::tid!{AddIntLit16InstructionContextExt<'a>}

impl<'input> AddIntLit16InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AddIntLit16InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AddIntLit16InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AddIntLit16InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AddIntLit16InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_ADD_INT_LIT16
/// Returns `None` if there is no child corresponding to token OP_ADD_INT_LIT16
fn OP_ADD_INT_LIT16(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_ADD_INT_LIT16, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AddIntLit16InstructionContextAttrs<'input> for AddIntLit16InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn addIntLit16Instruction(&mut self,)
	-> Result<Rc<AddIntLit16InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AddIntLit16InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 480, RULE_addIntLit16Instruction);
        let mut _localctx: Rc<AddIntLit16InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1910);
			recog.base.match_token(OP_ADD_INT_LIT16,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1911);
			recog.targetRegister()?;

			recog.base.set_state(1912);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1913);
			recog.leftRegister()?;

			recog.base.set_state(1914);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(1915);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- mulIntLit16Instruction ----------------
pub type MulIntLit16InstructionContextAll<'input> = MulIntLit16InstructionContext<'input>;


pub type MulIntLit16InstructionContext<'input> = BaseParserRuleContext<'input,MulIntLit16InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MulIntLit16InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MulIntLit16InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MulIntLit16InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_mulIntLit16Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_mulIntLit16Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MulIntLit16InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_mulIntLit16Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_mulIntLit16Instruction }
}
antlr_rust::tid!{MulIntLit16InstructionContextExt<'a>}

impl<'input> MulIntLit16InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MulIntLit16InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MulIntLit16InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MulIntLit16InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MulIntLit16InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MUL_INT_LIT16
/// Returns `None` if there is no child corresponding to token OP_MUL_INT_LIT16
fn OP_MUL_INT_LIT16(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MUL_INT_LIT16, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MulIntLit16InstructionContextAttrs<'input> for MulIntLit16InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn mulIntLit16Instruction(&mut self,)
	-> Result<Rc<MulIntLit16InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MulIntLit16InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 482, RULE_mulIntLit16Instruction);
        let mut _localctx: Rc<MulIntLit16InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1917);
			recog.base.match_token(OP_MUL_INT_LIT16,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1918);
			recog.targetRegister()?;

			recog.base.set_state(1919);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1920);
			recog.leftRegister()?;

			recog.base.set_state(1921);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(1922);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- divIntLit16Instruction ----------------
pub type DivIntLit16InstructionContextAll<'input> = DivIntLit16InstructionContext<'input>;


pub type DivIntLit16InstructionContext<'input> = BaseParserRuleContext<'input,DivIntLit16InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct DivIntLit16InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for DivIntLit16InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for DivIntLit16InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_divIntLit16Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_divIntLit16Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DivIntLit16InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_divIntLit16Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_divIntLit16Instruction }
}
antlr_rust::tid!{DivIntLit16InstructionContextExt<'a>}

impl<'input> DivIntLit16InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DivIntLit16InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DivIntLit16InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DivIntLit16InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<DivIntLit16InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_DIV_INT_LIT16
/// Returns `None` if there is no child corresponding to token OP_DIV_INT_LIT16
fn OP_DIV_INT_LIT16(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_DIV_INT_LIT16, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DivIntLit16InstructionContextAttrs<'input> for DivIntLit16InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn divIntLit16Instruction(&mut self,)
	-> Result<Rc<DivIntLit16InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DivIntLit16InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 484, RULE_divIntLit16Instruction);
        let mut _localctx: Rc<DivIntLit16InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1924);
			recog.base.match_token(OP_DIV_INT_LIT16,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1925);
			recog.targetRegister()?;

			recog.base.set_state(1926);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1927);
			recog.leftRegister()?;

			recog.base.set_state(1928);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(1929);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- remIntLit16Instruction ----------------
pub type RemIntLit16InstructionContextAll<'input> = RemIntLit16InstructionContext<'input>;


pub type RemIntLit16InstructionContext<'input> = BaseParserRuleContext<'input,RemIntLit16InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct RemIntLit16InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for RemIntLit16InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for RemIntLit16InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_remIntLit16Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_remIntLit16Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RemIntLit16InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_remIntLit16Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_remIntLit16Instruction }
}
antlr_rust::tid!{RemIntLit16InstructionContextExt<'a>}

impl<'input> RemIntLit16InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RemIntLit16InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RemIntLit16InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RemIntLit16InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<RemIntLit16InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_REM_INT_LIT16
/// Returns `None` if there is no child corresponding to token OP_REM_INT_LIT16
fn OP_REM_INT_LIT16(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_REM_INT_LIT16, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RemIntLit16InstructionContextAttrs<'input> for RemIntLit16InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn remIntLit16Instruction(&mut self,)
	-> Result<Rc<RemIntLit16InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RemIntLit16InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 486, RULE_remIntLit16Instruction);
        let mut _localctx: Rc<RemIntLit16InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1931);
			recog.base.match_token(OP_REM_INT_LIT16,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1932);
			recog.targetRegister()?;

			recog.base.set_state(1933);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1934);
			recog.leftRegister()?;

			recog.base.set_state(1935);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(1936);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- andIntLit16Instruction ----------------
pub type AndIntLit16InstructionContextAll<'input> = AndIntLit16InstructionContext<'input>;


pub type AndIntLit16InstructionContext<'input> = BaseParserRuleContext<'input,AndIntLit16InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AndIntLit16InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AndIntLit16InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AndIntLit16InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_andIntLit16Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_andIntLit16Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AndIntLit16InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_andIntLit16Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_andIntLit16Instruction }
}
antlr_rust::tid!{AndIntLit16InstructionContextExt<'a>}

impl<'input> AndIntLit16InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AndIntLit16InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AndIntLit16InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AndIntLit16InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AndIntLit16InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_AND_INT_LIT16
/// Returns `None` if there is no child corresponding to token OP_AND_INT_LIT16
fn OP_AND_INT_LIT16(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_AND_INT_LIT16, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AndIntLit16InstructionContextAttrs<'input> for AndIntLit16InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn andIntLit16Instruction(&mut self,)
	-> Result<Rc<AndIntLit16InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AndIntLit16InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 488, RULE_andIntLit16Instruction);
        let mut _localctx: Rc<AndIntLit16InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1938);
			recog.base.match_token(OP_AND_INT_LIT16,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1939);
			recog.targetRegister()?;

			recog.base.set_state(1940);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1941);
			recog.leftRegister()?;

			recog.base.set_state(1942);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(1943);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- orIntLit16Instruction ----------------
pub type OrIntLit16InstructionContextAll<'input> = OrIntLit16InstructionContext<'input>;


pub type OrIntLit16InstructionContext<'input> = BaseParserRuleContext<'input,OrIntLit16InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct OrIntLit16InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for OrIntLit16InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for OrIntLit16InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_orIntLit16Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_orIntLit16Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for OrIntLit16InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_orIntLit16Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_orIntLit16Instruction }
}
antlr_rust::tid!{OrIntLit16InstructionContextExt<'a>}

impl<'input> OrIntLit16InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OrIntLit16InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OrIntLit16InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OrIntLit16InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<OrIntLit16InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_OR_INT_LIT16
/// Returns `None` if there is no child corresponding to token OP_OR_INT_LIT16
fn OP_OR_INT_LIT16(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_OR_INT_LIT16, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> OrIntLit16InstructionContextAttrs<'input> for OrIntLit16InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn orIntLit16Instruction(&mut self,)
	-> Result<Rc<OrIntLit16InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OrIntLit16InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 490, RULE_orIntLit16Instruction);
        let mut _localctx: Rc<OrIntLit16InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1945);
			recog.base.match_token(OP_OR_INT_LIT16,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1946);
			recog.targetRegister()?;

			recog.base.set_state(1947);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1948);
			recog.leftRegister()?;

			recog.base.set_state(1949);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(1950);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- xorIntLit16Instruction ----------------
pub type XorIntLit16InstructionContextAll<'input> = XorIntLit16InstructionContext<'input>;


pub type XorIntLit16InstructionContext<'input> = BaseParserRuleContext<'input,XorIntLit16InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct XorIntLit16InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for XorIntLit16InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for XorIntLit16InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_xorIntLit16Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_xorIntLit16Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for XorIntLit16InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_xorIntLit16Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_xorIntLit16Instruction }
}
antlr_rust::tid!{XorIntLit16InstructionContextExt<'a>}

impl<'input> XorIntLit16InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<XorIntLit16InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,XorIntLit16InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait XorIntLit16InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<XorIntLit16InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_XOR_INT_LIT16
/// Returns `None` if there is no child corresponding to token OP_XOR_INT_LIT16
fn OP_XOR_INT_LIT16(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_XOR_INT_LIT16, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> XorIntLit16InstructionContextAttrs<'input> for XorIntLit16InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn xorIntLit16Instruction(&mut self,)
	-> Result<Rc<XorIntLit16InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = XorIntLit16InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 492, RULE_xorIntLit16Instruction);
        let mut _localctx: Rc<XorIntLit16InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1952);
			recog.base.match_token(OP_XOR_INT_LIT16,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1953);
			recog.targetRegister()?;

			recog.base.set_state(1954);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1955);
			recog.leftRegister()?;

			recog.base.set_state(1956);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(1957);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- addIntLit8Instruction ----------------
pub type AddIntLit8InstructionContextAll<'input> = AddIntLit8InstructionContext<'input>;


pub type AddIntLit8InstructionContext<'input> = BaseParserRuleContext<'input,AddIntLit8InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AddIntLit8InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AddIntLit8InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AddIntLit8InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_addIntLit8Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_addIntLit8Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AddIntLit8InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_addIntLit8Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_addIntLit8Instruction }
}
antlr_rust::tid!{AddIntLit8InstructionContextExt<'a>}

impl<'input> AddIntLit8InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AddIntLit8InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AddIntLit8InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AddIntLit8InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AddIntLit8InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_ADD_INT_LIT8
/// Returns `None` if there is no child corresponding to token OP_ADD_INT_LIT8
fn OP_ADD_INT_LIT8(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_ADD_INT_LIT8, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AddIntLit8InstructionContextAttrs<'input> for AddIntLit8InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn addIntLit8Instruction(&mut self,)
	-> Result<Rc<AddIntLit8InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AddIntLit8InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 494, RULE_addIntLit8Instruction);
        let mut _localctx: Rc<AddIntLit8InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1959);
			recog.base.match_token(OP_ADD_INT_LIT8,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1960);
			recog.targetRegister()?;

			recog.base.set_state(1961);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1962);
			recog.leftRegister()?;

			recog.base.set_state(1963);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(1964);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- rsubIntLit8Instruction ----------------
pub type RsubIntLit8InstructionContextAll<'input> = RsubIntLit8InstructionContext<'input>;


pub type RsubIntLit8InstructionContext<'input> = BaseParserRuleContext<'input,RsubIntLit8InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct RsubIntLit8InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for RsubIntLit8InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for RsubIntLit8InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_rsubIntLit8Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_rsubIntLit8Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RsubIntLit8InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_rsubIntLit8Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_rsubIntLit8Instruction }
}
antlr_rust::tid!{RsubIntLit8InstructionContextExt<'a>}

impl<'input> RsubIntLit8InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RsubIntLit8InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RsubIntLit8InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RsubIntLit8InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<RsubIntLit8InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_RSUB_INT_LIT8
/// Returns `None` if there is no child corresponding to token OP_RSUB_INT_LIT8
fn OP_RSUB_INT_LIT8(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_RSUB_INT_LIT8, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RsubIntLit8InstructionContextAttrs<'input> for RsubIntLit8InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn rsubIntLit8Instruction(&mut self,)
	-> Result<Rc<RsubIntLit8InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RsubIntLit8InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 496, RULE_rsubIntLit8Instruction);
        let mut _localctx: Rc<RsubIntLit8InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1966);
			recog.base.match_token(OP_RSUB_INT_LIT8,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1967);
			recog.targetRegister()?;

			recog.base.set_state(1968);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1969);
			recog.leftRegister()?;

			recog.base.set_state(1970);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(1971);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- mulIntLit8Instruction ----------------
pub type MulIntLit8InstructionContextAll<'input> = MulIntLit8InstructionContext<'input>;


pub type MulIntLit8InstructionContext<'input> = BaseParserRuleContext<'input,MulIntLit8InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct MulIntLit8InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MulIntLit8InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MulIntLit8InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_mulIntLit8Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_mulIntLit8Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MulIntLit8InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_mulIntLit8Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_mulIntLit8Instruction }
}
antlr_rust::tid!{MulIntLit8InstructionContextExt<'a>}

impl<'input> MulIntLit8InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MulIntLit8InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MulIntLit8InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MulIntLit8InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MulIntLit8InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_MUL_INT_LIT8
/// Returns `None` if there is no child corresponding to token OP_MUL_INT_LIT8
fn OP_MUL_INT_LIT8(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_MUL_INT_LIT8, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MulIntLit8InstructionContextAttrs<'input> for MulIntLit8InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn mulIntLit8Instruction(&mut self,)
	-> Result<Rc<MulIntLit8InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MulIntLit8InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 498, RULE_mulIntLit8Instruction);
        let mut _localctx: Rc<MulIntLit8InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1973);
			recog.base.match_token(OP_MUL_INT_LIT8,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1974);
			recog.targetRegister()?;

			recog.base.set_state(1975);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1976);
			recog.leftRegister()?;

			recog.base.set_state(1977);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(1978);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- divIntLit8Instruction ----------------
pub type DivIntLit8InstructionContextAll<'input> = DivIntLit8InstructionContext<'input>;


pub type DivIntLit8InstructionContext<'input> = BaseParserRuleContext<'input,DivIntLit8InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct DivIntLit8InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for DivIntLit8InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for DivIntLit8InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_divIntLit8Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_divIntLit8Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for DivIntLit8InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_divIntLit8Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_divIntLit8Instruction }
}
antlr_rust::tid!{DivIntLit8InstructionContextExt<'a>}

impl<'input> DivIntLit8InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DivIntLit8InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DivIntLit8InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DivIntLit8InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<DivIntLit8InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_DIV_INT_LIT8
/// Returns `None` if there is no child corresponding to token OP_DIV_INT_LIT8
fn OP_DIV_INT_LIT8(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_DIV_INT_LIT8, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DivIntLit8InstructionContextAttrs<'input> for DivIntLit8InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn divIntLit8Instruction(&mut self,)
	-> Result<Rc<DivIntLit8InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DivIntLit8InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 500, RULE_divIntLit8Instruction);
        let mut _localctx: Rc<DivIntLit8InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1980);
			recog.base.match_token(OP_DIV_INT_LIT8,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1981);
			recog.targetRegister()?;

			recog.base.set_state(1982);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1983);
			recog.leftRegister()?;

			recog.base.set_state(1984);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(1985);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- remIntLit8Instruction ----------------
pub type RemIntLit8InstructionContextAll<'input> = RemIntLit8InstructionContext<'input>;


pub type RemIntLit8InstructionContext<'input> = BaseParserRuleContext<'input,RemIntLit8InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct RemIntLit8InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for RemIntLit8InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for RemIntLit8InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_remIntLit8Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_remIntLit8Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RemIntLit8InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_remIntLit8Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_remIntLit8Instruction }
}
antlr_rust::tid!{RemIntLit8InstructionContextExt<'a>}

impl<'input> RemIntLit8InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RemIntLit8InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RemIntLit8InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RemIntLit8InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<RemIntLit8InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_REM_INT_LIT8
/// Returns `None` if there is no child corresponding to token OP_REM_INT_LIT8
fn OP_REM_INT_LIT8(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_REM_INT_LIT8, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RemIntLit8InstructionContextAttrs<'input> for RemIntLit8InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn remIntLit8Instruction(&mut self,)
	-> Result<Rc<RemIntLit8InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RemIntLit8InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 502, RULE_remIntLit8Instruction);
        let mut _localctx: Rc<RemIntLit8InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1987);
			recog.base.match_token(OP_REM_INT_LIT8,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1988);
			recog.targetRegister()?;

			recog.base.set_state(1989);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1990);
			recog.leftRegister()?;

			recog.base.set_state(1991);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(1992);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- andIntLit8Instruction ----------------
pub type AndIntLit8InstructionContextAll<'input> = AndIntLit8InstructionContext<'input>;


pub type AndIntLit8InstructionContext<'input> = BaseParserRuleContext<'input,AndIntLit8InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct AndIntLit8InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AndIntLit8InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AndIntLit8InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_andIntLit8Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_andIntLit8Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AndIntLit8InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_andIntLit8Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_andIntLit8Instruction }
}
antlr_rust::tid!{AndIntLit8InstructionContextExt<'a>}

impl<'input> AndIntLit8InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AndIntLit8InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AndIntLit8InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AndIntLit8InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AndIntLit8InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_AND_INT_LIT8
/// Returns `None` if there is no child corresponding to token OP_AND_INT_LIT8
fn OP_AND_INT_LIT8(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_AND_INT_LIT8, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AndIntLit8InstructionContextAttrs<'input> for AndIntLit8InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn andIntLit8Instruction(&mut self,)
	-> Result<Rc<AndIntLit8InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AndIntLit8InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 504, RULE_andIntLit8Instruction);
        let mut _localctx: Rc<AndIntLit8InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(1994);
			recog.base.match_token(OP_AND_INT_LIT8,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(1995);
			recog.targetRegister()?;

			recog.base.set_state(1996);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(1997);
			recog.leftRegister()?;

			recog.base.set_state(1998);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(1999);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- orIntLit8Instruction ----------------
pub type OrIntLit8InstructionContextAll<'input> = OrIntLit8InstructionContext<'input>;


pub type OrIntLit8InstructionContext<'input> = BaseParserRuleContext<'input,OrIntLit8InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct OrIntLit8InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for OrIntLit8InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for OrIntLit8InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_orIntLit8Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_orIntLit8Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for OrIntLit8InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_orIntLit8Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_orIntLit8Instruction }
}
antlr_rust::tid!{OrIntLit8InstructionContextExt<'a>}

impl<'input> OrIntLit8InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OrIntLit8InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OrIntLit8InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait OrIntLit8InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<OrIntLit8InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_OR_INT_LIT8
/// Returns `None` if there is no child corresponding to token OP_OR_INT_LIT8
fn OP_OR_INT_LIT8(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_OR_INT_LIT8, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> OrIntLit8InstructionContextAttrs<'input> for OrIntLit8InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn orIntLit8Instruction(&mut self,)
	-> Result<Rc<OrIntLit8InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OrIntLit8InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 506, RULE_orIntLit8Instruction);
        let mut _localctx: Rc<OrIntLit8InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2001);
			recog.base.match_token(OP_OR_INT_LIT8,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(2002);
			recog.targetRegister()?;

			recog.base.set_state(2003);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(2004);
			recog.leftRegister()?;

			recog.base.set_state(2005);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(2006);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- xorIntLit8Instruction ----------------
pub type XorIntLit8InstructionContextAll<'input> = XorIntLit8InstructionContext<'input>;


pub type XorIntLit8InstructionContext<'input> = BaseParserRuleContext<'input,XorIntLit8InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct XorIntLit8InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for XorIntLit8InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for XorIntLit8InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_xorIntLit8Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_xorIntLit8Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for XorIntLit8InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_xorIntLit8Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_xorIntLit8Instruction }
}
antlr_rust::tid!{XorIntLit8InstructionContextExt<'a>}

impl<'input> XorIntLit8InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<XorIntLit8InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,XorIntLit8InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait XorIntLit8InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<XorIntLit8InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_XOR_INT_LIT8
/// Returns `None` if there is no child corresponding to token OP_XOR_INT_LIT8
fn OP_XOR_INT_LIT8(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_XOR_INT_LIT8, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> XorIntLit8InstructionContextAttrs<'input> for XorIntLit8InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn xorIntLit8Instruction(&mut self,)
	-> Result<Rc<XorIntLit8InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = XorIntLit8InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 508, RULE_xorIntLit8Instruction);
        let mut _localctx: Rc<XorIntLit8InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2008);
			recog.base.match_token(OP_XOR_INT_LIT8,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(2009);
			recog.targetRegister()?;

			recog.base.set_state(2010);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(2011);
			recog.leftRegister()?;

			recog.base.set_state(2012);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(2013);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- shlIntLit8Instruction ----------------
pub type ShlIntLit8InstructionContextAll<'input> = ShlIntLit8InstructionContext<'input>;


pub type ShlIntLit8InstructionContext<'input> = BaseParserRuleContext<'input,ShlIntLit8InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ShlIntLit8InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ShlIntLit8InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ShlIntLit8InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_shlIntLit8Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_shlIntLit8Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ShlIntLit8InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_shlIntLit8Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_shlIntLit8Instruction }
}
antlr_rust::tid!{ShlIntLit8InstructionContextExt<'a>}

impl<'input> ShlIntLit8InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ShlIntLit8InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ShlIntLit8InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ShlIntLit8InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ShlIntLit8InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SHL_INT_LIT8
/// Returns `None` if there is no child corresponding to token OP_SHL_INT_LIT8
fn OP_SHL_INT_LIT8(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SHL_INT_LIT8, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ShlIntLit8InstructionContextAttrs<'input> for ShlIntLit8InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn shlIntLit8Instruction(&mut self,)
	-> Result<Rc<ShlIntLit8InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ShlIntLit8InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 510, RULE_shlIntLit8Instruction);
        let mut _localctx: Rc<ShlIntLit8InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2015);
			recog.base.match_token(OP_SHL_INT_LIT8,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(2016);
			recog.targetRegister()?;

			recog.base.set_state(2017);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(2018);
			recog.leftRegister()?;

			recog.base.set_state(2019);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(2020);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- shrIntLit8Instruction ----------------
pub type ShrIntLit8InstructionContextAll<'input> = ShrIntLit8InstructionContext<'input>;


pub type ShrIntLit8InstructionContext<'input> = BaseParserRuleContext<'input,ShrIntLit8InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ShrIntLit8InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ShrIntLit8InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ShrIntLit8InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_shrIntLit8Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_shrIntLit8Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ShrIntLit8InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_shrIntLit8Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_shrIntLit8Instruction }
}
antlr_rust::tid!{ShrIntLit8InstructionContextExt<'a>}

impl<'input> ShrIntLit8InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ShrIntLit8InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ShrIntLit8InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ShrIntLit8InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ShrIntLit8InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SHR_INT_LIT8
/// Returns `None` if there is no child corresponding to token OP_SHR_INT_LIT8
fn OP_SHR_INT_LIT8(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SHR_INT_LIT8, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ShrIntLit8InstructionContextAttrs<'input> for ShrIntLit8InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn shrIntLit8Instruction(&mut self,)
	-> Result<Rc<ShrIntLit8InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ShrIntLit8InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 512, RULE_shrIntLit8Instruction);
        let mut _localctx: Rc<ShrIntLit8InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2022);
			recog.base.match_token(OP_SHR_INT_LIT8,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(2023);
			recog.targetRegister()?;

			recog.base.set_state(2024);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(2025);
			recog.leftRegister()?;

			recog.base.set_state(2026);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(2027);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ushrIntLit8Instruction ----------------
pub type UshrIntLit8InstructionContextAll<'input> = UshrIntLit8InstructionContext<'input>;


pub type UshrIntLit8InstructionContext<'input> = BaseParserRuleContext<'input,UshrIntLit8InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct UshrIntLit8InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for UshrIntLit8InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for UshrIntLit8InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ushrIntLit8Instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_ushrIntLit8Instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for UshrIntLit8InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ushrIntLit8Instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ushrIntLit8Instruction }
}
antlr_rust::tid!{UshrIntLit8InstructionContextExt<'a>}

impl<'input> UshrIntLit8InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UshrIntLit8InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UshrIntLit8InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UshrIntLit8InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<UshrIntLit8InstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_USHR_INT_LIT8
/// Returns `None` if there is no child corresponding to token OP_USHR_INT_LIT8
fn OP_USHR_INT_LIT8(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_USHR_INT_LIT8, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn leftRegister(&self) -> Option<Rc<LeftRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> UshrIntLit8InstructionContextAttrs<'input> for UshrIntLit8InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ushrIntLit8Instruction(&mut self,)
	-> Result<Rc<UshrIntLit8InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UshrIntLit8InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 514, RULE_ushrIntLit8Instruction);
        let mut _localctx: Rc<UshrIntLit8InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2029);
			recog.base.match_token(OP_USHR_INT_LIT8,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(2030);
			recog.targetRegister()?;

			recog.base.set_state(2031);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule leftRegister*/
			recog.base.set_state(2032);
			recog.leftRegister()?;

			recog.base.set_state(2033);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(2034);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- newInstanceType ----------------
pub type NewInstanceTypeContextAll<'input> = NewInstanceTypeContext<'input>;


pub type NewInstanceTypeContext<'input> = BaseParserRuleContext<'input,NewInstanceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct NewInstanceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for NewInstanceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for NewInstanceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_newInstanceType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_newInstanceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NewInstanceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_newInstanceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_newInstanceType }
}
antlr_rust::tid!{NewInstanceTypeContextExt<'a>}

impl<'input> NewInstanceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NewInstanceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NewInstanceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NewInstanceTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<NewInstanceTypeContextExt<'input>>{

fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NewInstanceTypeContextAttrs<'input> for NewInstanceTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn newInstanceType(&mut self,)
	-> Result<Rc<NewInstanceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NewInstanceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 516, RULE_newInstanceType);
        let mut _localctx: Rc<NewInstanceTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule referenceType*/
			recog.base.set_state(2036);
			recog.referenceType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- newInstanceInstruction ----------------
pub type NewInstanceInstructionContextAll<'input> = NewInstanceInstructionContext<'input>;


pub type NewInstanceInstructionContext<'input> = BaseParserRuleContext<'input,NewInstanceInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct NewInstanceInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for NewInstanceInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for NewInstanceInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_newInstanceInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_newInstanceInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NewInstanceInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_newInstanceInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_newInstanceInstruction }
}
antlr_rust::tid!{NewInstanceInstructionContextExt<'a>}

impl<'input> NewInstanceInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NewInstanceInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NewInstanceInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NewInstanceInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<NewInstanceInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_NEW_INSTANCE
/// Returns `None` if there is no child corresponding to token OP_NEW_INSTANCE
fn OP_NEW_INSTANCE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_NEW_INSTANCE, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn newInstanceType(&self) -> Option<Rc<NewInstanceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NewInstanceInstructionContextAttrs<'input> for NewInstanceInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn newInstanceInstruction(&mut self,)
	-> Result<Rc<NewInstanceInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NewInstanceInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 518, RULE_newInstanceInstruction);
        let mut _localctx: Rc<NewInstanceInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2038);
			recog.base.match_token(OP_NEW_INSTANCE,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(2039);
			recog.targetRegister()?;

			recog.base.set_state(2040);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule newInstanceType*/
			recog.base.set_state(2041);
			recog.newInstanceType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- checkCastType ----------------
pub type CheckCastTypeContextAll<'input> = CheckCastTypeContext<'input>;


pub type CheckCastTypeContext<'input> = BaseParserRuleContext<'input,CheckCastTypeContextExt<'input>>;

#[derive(Clone)]
pub struct CheckCastTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for CheckCastTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for CheckCastTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_checkCastType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_checkCastType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CheckCastTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_checkCastType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_checkCastType }
}
antlr_rust::tid!{CheckCastTypeContextExt<'a>}

impl<'input> CheckCastTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CheckCastTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CheckCastTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CheckCastTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<CheckCastTypeContextExt<'input>>{

fn referenceOrArrayType(&self) -> Option<Rc<ReferenceOrArrayTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CheckCastTypeContextAttrs<'input> for CheckCastTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn checkCastType(&mut self,)
	-> Result<Rc<CheckCastTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CheckCastTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 520, RULE_checkCastType);
        let mut _localctx: Rc<CheckCastTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule referenceOrArrayType*/
			recog.base.set_state(2043);
			recog.referenceOrArrayType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- checkCastInstruction ----------------
pub type CheckCastInstructionContextAll<'input> = CheckCastInstructionContext<'input>;


pub type CheckCastInstructionContext<'input> = BaseParserRuleContext<'input,CheckCastInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct CheckCastInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for CheckCastInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for CheckCastInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_checkCastInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_checkCastInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CheckCastInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_checkCastInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_checkCastInstruction }
}
antlr_rust::tid!{CheckCastInstructionContextExt<'a>}

impl<'input> CheckCastInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CheckCastInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CheckCastInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CheckCastInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<CheckCastInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_CHECK_CAST
/// Returns `None` if there is no child corresponding to token OP_CHECK_CAST
fn OP_CHECK_CAST(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_CHECK_CAST, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn checkCastType(&self) -> Option<Rc<CheckCastTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CheckCastInstructionContextAttrs<'input> for CheckCastInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn checkCastInstruction(&mut self,)
	-> Result<Rc<CheckCastInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CheckCastInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 522, RULE_checkCastInstruction);
        let mut _localctx: Rc<CheckCastInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2045);
			recog.base.match_token(OP_CHECK_CAST,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(2046);
			recog.targetRegister()?;

			recog.base.set_state(2047);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule checkCastType*/
			recog.base.set_state(2048);
			recog.checkCastType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayLengthInstruction ----------------
pub type ArrayLengthInstructionContextAll<'input> = ArrayLengthInstructionContext<'input>;


pub type ArrayLengthInstructionContext<'input> = BaseParserRuleContext<'input,ArrayLengthInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayLengthInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ArrayLengthInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ArrayLengthInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayLengthInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_arrayLengthInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ArrayLengthInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayLengthInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayLengthInstruction }
}
antlr_rust::tid!{ArrayLengthInstructionContextExt<'a>}

impl<'input> ArrayLengthInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayLengthInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayLengthInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayLengthInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ArrayLengthInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_ARRAY_LENGTH
/// Returns `None` if there is no child corresponding to token OP_ARRAY_LENGTH
fn OP_ARRAY_LENGTH(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_ARRAY_LENGTH, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn arrayRegister(&self) -> Option<Rc<ArrayRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ArrayLengthInstructionContextAttrs<'input> for ArrayLengthInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayLengthInstruction(&mut self,)
	-> Result<Rc<ArrayLengthInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayLengthInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 524, RULE_arrayLengthInstruction);
        let mut _localctx: Rc<ArrayLengthInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2050);
			recog.base.match_token(OP_ARRAY_LENGTH,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(2051);
			recog.targetRegister()?;

			recog.base.set_state(2052);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule arrayRegister*/
			recog.base.set_state(2053);
			recog.arrayRegister()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayElementType ----------------
pub type ArrayElementTypeContextAll<'input> = ArrayElementTypeContext<'input>;


pub type ArrayElementTypeContext<'input> = BaseParserRuleContext<'input,ArrayElementTypeContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayElementTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ArrayElementTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ArrayElementTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayElementType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_arrayElementType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ArrayElementTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayElementType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayElementType }
}
antlr_rust::tid!{ArrayElementTypeContextExt<'a>}

impl<'input> ArrayElementTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayElementTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayElementTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayElementTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ArrayElementTypeContextExt<'input>>{

fn nonVoidType(&self) -> Option<Rc<NonVoidTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ArrayElementTypeContextAttrs<'input> for ArrayElementTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayElementType(&mut self,)
	-> Result<Rc<ArrayElementTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayElementTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 526, RULE_arrayElementType);
        let mut _localctx: Rc<ArrayElementTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule nonVoidType*/
			recog.base.set_state(2055);
			recog.nonVoidType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayElementRegisterRange ----------------
pub type ArrayElementRegisterRangeContextAll<'input> = ArrayElementRegisterRangeContext<'input>;


pub type ArrayElementRegisterRangeContext<'input> = BaseParserRuleContext<'input,ArrayElementRegisterRangeContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayElementRegisterRangeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ArrayElementRegisterRangeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ArrayElementRegisterRangeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayElementRegisterRange(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_arrayElementRegisterRange(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ArrayElementRegisterRangeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayElementRegisterRange }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayElementRegisterRange }
}
antlr_rust::tid!{ArrayElementRegisterRangeContextExt<'a>}

impl<'input> ArrayElementRegisterRangeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayElementRegisterRangeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayElementRegisterRangeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayElementRegisterRangeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ArrayElementRegisterRangeContextExt<'input>>{

fn registerRange(&self) -> Option<Rc<RegisterRangeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ArrayElementRegisterRangeContextAttrs<'input> for ArrayElementRegisterRangeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayElementRegisterRange(&mut self,)
	-> Result<Rc<ArrayElementRegisterRangeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayElementRegisterRangeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 528, RULE_arrayElementRegisterRange);
        let mut _localctx: Rc<ArrayElementRegisterRangeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule registerRange*/
			recog.base.set_state(2057);
			recog.registerRange()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayElementRegisters ----------------
pub type ArrayElementRegistersContextAll<'input> = ArrayElementRegistersContext<'input>;


pub type ArrayElementRegistersContext<'input> = BaseParserRuleContext<'input,ArrayElementRegistersContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayElementRegistersContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ArrayElementRegistersContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ArrayElementRegistersContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayElementRegisters(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_arrayElementRegisters(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ArrayElementRegistersContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayElementRegisters }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayElementRegisters }
}
antlr_rust::tid!{ArrayElementRegistersContextExt<'a>}

impl<'input> ArrayElementRegistersContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayElementRegistersContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayElementRegistersContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayElementRegistersContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ArrayElementRegistersContextExt<'input>>{

fn registerList(&self) -> Option<Rc<RegisterListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ArrayElementRegistersContextAttrs<'input> for ArrayElementRegistersContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayElementRegisters(&mut self,)
	-> Result<Rc<ArrayElementRegistersContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayElementRegistersContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 530, RULE_arrayElementRegisters);
        let mut _localctx: Rc<ArrayElementRegistersContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule registerList*/
			recog.base.set_state(2059);
			recog.registerList()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- filledNewArrayRangeInstruction ----------------
pub type FilledNewArrayRangeInstructionContextAll<'input> = FilledNewArrayRangeInstructionContext<'input>;


pub type FilledNewArrayRangeInstructionContext<'input> = BaseParserRuleContext<'input,FilledNewArrayRangeInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct FilledNewArrayRangeInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for FilledNewArrayRangeInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for FilledNewArrayRangeInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_filledNewArrayRangeInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_filledNewArrayRangeInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FilledNewArrayRangeInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_filledNewArrayRangeInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_filledNewArrayRangeInstruction }
}
antlr_rust::tid!{FilledNewArrayRangeInstructionContextExt<'a>}

impl<'input> FilledNewArrayRangeInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FilledNewArrayRangeInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FilledNewArrayRangeInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FilledNewArrayRangeInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<FilledNewArrayRangeInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_FILLED_NEW_ARRAY_RANGE
/// Returns `None` if there is no child corresponding to token OP_FILLED_NEW_ARRAY_RANGE
fn OP_FILLED_NEW_ARRAY_RANGE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_FILLED_NEW_ARRAY_RANGE, 0)
}
fn arrayElementRegisterRange(&self) -> Option<Rc<ArrayElementRegisterRangeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn arrayElementType(&self) -> Option<Rc<ArrayElementTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FilledNewArrayRangeInstructionContextAttrs<'input> for FilledNewArrayRangeInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn filledNewArrayRangeInstruction(&mut self,)
	-> Result<Rc<FilledNewArrayRangeInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FilledNewArrayRangeInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 532, RULE_filledNewArrayRangeInstruction);
        let mut _localctx: Rc<FilledNewArrayRangeInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2061);
			recog.base.match_token(OP_FILLED_NEW_ARRAY_RANGE,&mut recog.err_handler)?;

			/*InvokeRule arrayElementRegisterRange*/
			recog.base.set_state(2062);
			recog.arrayElementRegisterRange()?;

			recog.base.set_state(2063);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule arrayElementType*/
			recog.base.set_state(2064);
			recog.arrayElementType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- filledNewArrayInstruction ----------------
pub type FilledNewArrayInstructionContextAll<'input> = FilledNewArrayInstructionContext<'input>;


pub type FilledNewArrayInstructionContext<'input> = BaseParserRuleContext<'input,FilledNewArrayInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct FilledNewArrayInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for FilledNewArrayInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for FilledNewArrayInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_filledNewArrayInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_filledNewArrayInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FilledNewArrayInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_filledNewArrayInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_filledNewArrayInstruction }
}
antlr_rust::tid!{FilledNewArrayInstructionContextExt<'a>}

impl<'input> FilledNewArrayInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FilledNewArrayInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FilledNewArrayInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FilledNewArrayInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<FilledNewArrayInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_FILLED_NEW_ARRAY
/// Returns `None` if there is no child corresponding to token OP_FILLED_NEW_ARRAY
fn OP_FILLED_NEW_ARRAY(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_FILLED_NEW_ARRAY, 0)
}
fn arrayElementRegisters(&self) -> Option<Rc<ArrayElementRegistersContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn arrayElementType(&self) -> Option<Rc<ArrayElementTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FilledNewArrayInstructionContextAttrs<'input> for FilledNewArrayInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn filledNewArrayInstruction(&mut self,)
	-> Result<Rc<FilledNewArrayInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FilledNewArrayInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 534, RULE_filledNewArrayInstruction);
        let mut _localctx: Rc<FilledNewArrayInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2066);
			recog.base.match_token(OP_FILLED_NEW_ARRAY,&mut recog.err_handler)?;

			/*InvokeRule arrayElementRegisters*/
			recog.base.set_state(2067);
			recog.arrayElementRegisters()?;

			recog.base.set_state(2068);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule arrayElementType*/
			recog.base.set_state(2069);
			recog.arrayElementType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- filledArrayDataLabel ----------------
pub type FilledArrayDataLabelContextAll<'input> = FilledArrayDataLabelContext<'input>;


pub type FilledArrayDataLabelContext<'input> = BaseParserRuleContext<'input,FilledArrayDataLabelContextExt<'input>>;

#[derive(Clone)]
pub struct FilledArrayDataLabelContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for FilledArrayDataLabelContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for FilledArrayDataLabelContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_filledArrayDataLabel(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_filledArrayDataLabel(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FilledArrayDataLabelContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_filledArrayDataLabel }
	//fn type_rule_index() -> usize where Self: Sized { RULE_filledArrayDataLabel }
}
antlr_rust::tid!{FilledArrayDataLabelContextExt<'a>}

impl<'input> FilledArrayDataLabelContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FilledArrayDataLabelContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FilledArrayDataLabelContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FilledArrayDataLabelContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<FilledArrayDataLabelContextExt<'input>>{

fn label(&self) -> Option<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FilledArrayDataLabelContextAttrs<'input> for FilledArrayDataLabelContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn filledArrayDataLabel(&mut self,)
	-> Result<Rc<FilledArrayDataLabelContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FilledArrayDataLabelContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 536, RULE_filledArrayDataLabel);
        let mut _localctx: Rc<FilledArrayDataLabelContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule label*/
			recog.base.set_state(2071);
			recog.label()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fillArrayDataInstruction ----------------
pub type FillArrayDataInstructionContextAll<'input> = FillArrayDataInstructionContext<'input>;


pub type FillArrayDataInstructionContext<'input> = BaseParserRuleContext<'input,FillArrayDataInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct FillArrayDataInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for FillArrayDataInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for FillArrayDataInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_fillArrayDataInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_fillArrayDataInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FillArrayDataInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fillArrayDataInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fillArrayDataInstruction }
}
antlr_rust::tid!{FillArrayDataInstructionContextExt<'a>}

impl<'input> FillArrayDataInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FillArrayDataInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FillArrayDataInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FillArrayDataInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<FillArrayDataInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_FILL_ARRAY_DATA
/// Returns `None` if there is no child corresponding to token OP_FILL_ARRAY_DATA
fn OP_FILL_ARRAY_DATA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_FILL_ARRAY_DATA, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn filledArrayDataLabel(&self) -> Option<Rc<FilledArrayDataLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FillArrayDataInstructionContextAttrs<'input> for FillArrayDataInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fillArrayDataInstruction(&mut self,)
	-> Result<Rc<FillArrayDataInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FillArrayDataInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 538, RULE_fillArrayDataInstruction);
        let mut _localctx: Rc<FillArrayDataInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2073);
			recog.base.match_token(OP_FILL_ARRAY_DATA,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(2074);
			recog.targetRegister()?;

			recog.base.set_state(2075);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule filledArrayDataLabel*/
			recog.base.set_state(2076);
			recog.filledArrayDataLabel()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- checkInstanceType ----------------
pub type CheckInstanceTypeContextAll<'input> = CheckInstanceTypeContext<'input>;


pub type CheckInstanceTypeContext<'input> = BaseParserRuleContext<'input,CheckInstanceTypeContextExt<'input>>;

#[derive(Clone)]
pub struct CheckInstanceTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for CheckInstanceTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for CheckInstanceTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_checkInstanceType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_checkInstanceType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CheckInstanceTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_checkInstanceType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_checkInstanceType }
}
antlr_rust::tid!{CheckInstanceTypeContextExt<'a>}

impl<'input> CheckInstanceTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CheckInstanceTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CheckInstanceTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CheckInstanceTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<CheckInstanceTypeContextExt<'input>>{

fn nonVoidType(&self) -> Option<Rc<NonVoidTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CheckInstanceTypeContextAttrs<'input> for CheckInstanceTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn checkInstanceType(&mut self,)
	-> Result<Rc<CheckInstanceTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CheckInstanceTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 540, RULE_checkInstanceType);
        let mut _localctx: Rc<CheckInstanceTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule nonVoidType*/
			recog.base.set_state(2078);
			recog.nonVoidType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- instanceOfInstruction ----------------
pub type InstanceOfInstructionContextAll<'input> = InstanceOfInstructionContext<'input>;


pub type InstanceOfInstructionContext<'input> = BaseParserRuleContext<'input,InstanceOfInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct InstanceOfInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InstanceOfInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InstanceOfInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_instanceOfInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_instanceOfInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InstanceOfInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_instanceOfInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_instanceOfInstruction }
}
antlr_rust::tid!{InstanceOfInstructionContextExt<'a>}

impl<'input> InstanceOfInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InstanceOfInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InstanceOfInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InstanceOfInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InstanceOfInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INSTANCE_OF
/// Returns `None` if there is no child corresponding to token OP_INSTANCE_OF
fn OP_INSTANCE_OF(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INSTANCE_OF, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn instanceRegister(&self) -> Option<Rc<InstanceRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn checkInstanceType(&self) -> Option<Rc<CheckInstanceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InstanceOfInstructionContextAttrs<'input> for InstanceOfInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn instanceOfInstruction(&mut self,)
	-> Result<Rc<InstanceOfInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InstanceOfInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 542, RULE_instanceOfInstruction);
        let mut _localctx: Rc<InstanceOfInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2080);
			recog.base.match_token(OP_INSTANCE_OF,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(2081);
			recog.targetRegister()?;

			recog.base.set_state(2082);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule instanceRegister*/
			recog.base.set_state(2083);
			recog.instanceRegister()?;

			recog.base.set_state(2084);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule checkInstanceType*/
			recog.base.set_state(2085);
			recog.checkInstanceType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arraySizeRegister ----------------
pub type ArraySizeRegisterContextAll<'input> = ArraySizeRegisterContext<'input>;


pub type ArraySizeRegisterContext<'input> = BaseParserRuleContext<'input,ArraySizeRegisterContextExt<'input>>;

#[derive(Clone)]
pub struct ArraySizeRegisterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ArraySizeRegisterContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ArraySizeRegisterContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arraySizeRegister(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_arraySizeRegister(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ArraySizeRegisterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arraySizeRegister }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arraySizeRegister }
}
antlr_rust::tid!{ArraySizeRegisterContextExt<'a>}

impl<'input> ArraySizeRegisterContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArraySizeRegisterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArraySizeRegisterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArraySizeRegisterContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ArraySizeRegisterContextExt<'input>>{

fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ArraySizeRegisterContextAttrs<'input> for ArraySizeRegisterContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arraySizeRegister(&mut self,)
	-> Result<Rc<ArraySizeRegisterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArraySizeRegisterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 544, RULE_arraySizeRegister);
        let mut _localctx: Rc<ArraySizeRegisterContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule registerIdentifier*/
			recog.base.set_state(2087);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- newArrayInstruction ----------------
pub type NewArrayInstructionContextAll<'input> = NewArrayInstructionContext<'input>;


pub type NewArrayInstructionContext<'input> = BaseParserRuleContext<'input,NewArrayInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct NewArrayInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for NewArrayInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for NewArrayInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_newArrayInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_newArrayInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for NewArrayInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_newArrayInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_newArrayInstruction }
}
antlr_rust::tid!{NewArrayInstructionContextExt<'a>}

impl<'input> NewArrayInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NewArrayInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NewArrayInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NewArrayInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<NewArrayInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_NEW_ARRAY
/// Returns `None` if there is no child corresponding to token OP_NEW_ARRAY
fn OP_NEW_ARRAY(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_NEW_ARRAY, 0)
}
fn targetRegister(&self) -> Option<Rc<TargetRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn arraySizeRegister(&self) -> Option<Rc<ArraySizeRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayElementType(&self) -> Option<Rc<ArrayElementTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NewArrayInstructionContextAttrs<'input> for NewArrayInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn newArrayInstruction(&mut self,)
	-> Result<Rc<NewArrayInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NewArrayInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 546, RULE_newArrayInstruction);
        let mut _localctx: Rc<NewArrayInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2089);
			recog.base.match_token(OP_NEW_ARRAY,&mut recog.err_handler)?;

			/*InvokeRule targetRegister*/
			recog.base.set_state(2090);
			recog.targetRegister()?;

			recog.base.set_state(2091);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule arraySizeRegister*/
			recog.base.set_state(2092);
			recog.arraySizeRegister()?;

			recog.base.set_state(2093);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule arrayElementType*/
			recog.base.set_state(2094);
			recog.arrayElementType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- packedSwitchRegister ----------------
pub type PackedSwitchRegisterContextAll<'input> = PackedSwitchRegisterContext<'input>;


pub type PackedSwitchRegisterContext<'input> = BaseParserRuleContext<'input,PackedSwitchRegisterContextExt<'input>>;

#[derive(Clone)]
pub struct PackedSwitchRegisterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for PackedSwitchRegisterContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for PackedSwitchRegisterContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_packedSwitchRegister(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_packedSwitchRegister(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PackedSwitchRegisterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_packedSwitchRegister }
	//fn type_rule_index() -> usize where Self: Sized { RULE_packedSwitchRegister }
}
antlr_rust::tid!{PackedSwitchRegisterContextExt<'a>}

impl<'input> PackedSwitchRegisterContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PackedSwitchRegisterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PackedSwitchRegisterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PackedSwitchRegisterContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<PackedSwitchRegisterContextExt<'input>>{

fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PackedSwitchRegisterContextAttrs<'input> for PackedSwitchRegisterContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn packedSwitchRegister(&mut self,)
	-> Result<Rc<PackedSwitchRegisterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PackedSwitchRegisterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 548, RULE_packedSwitchRegister);
        let mut _localctx: Rc<PackedSwitchRegisterContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule registerIdentifier*/
			recog.base.set_state(2096);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- packedSwitchLabel ----------------
pub type PackedSwitchLabelContextAll<'input> = PackedSwitchLabelContext<'input>;


pub type PackedSwitchLabelContext<'input> = BaseParserRuleContext<'input,PackedSwitchLabelContextExt<'input>>;

#[derive(Clone)]
pub struct PackedSwitchLabelContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for PackedSwitchLabelContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for PackedSwitchLabelContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_packedSwitchLabel(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_packedSwitchLabel(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PackedSwitchLabelContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_packedSwitchLabel }
	//fn type_rule_index() -> usize where Self: Sized { RULE_packedSwitchLabel }
}
antlr_rust::tid!{PackedSwitchLabelContextExt<'a>}

impl<'input> PackedSwitchLabelContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PackedSwitchLabelContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PackedSwitchLabelContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PackedSwitchLabelContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<PackedSwitchLabelContextExt<'input>>{

fn label(&self) -> Option<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PackedSwitchLabelContextAttrs<'input> for PackedSwitchLabelContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn packedSwitchLabel(&mut self,)
	-> Result<Rc<PackedSwitchLabelContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PackedSwitchLabelContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 550, RULE_packedSwitchLabel);
        let mut _localctx: Rc<PackedSwitchLabelContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule label*/
			recog.base.set_state(2098);
			recog.label()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sparseSwitchRegister ----------------
pub type SparseSwitchRegisterContextAll<'input> = SparseSwitchRegisterContext<'input>;


pub type SparseSwitchRegisterContext<'input> = BaseParserRuleContext<'input,SparseSwitchRegisterContextExt<'input>>;

#[derive(Clone)]
pub struct SparseSwitchRegisterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SparseSwitchRegisterContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SparseSwitchRegisterContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sparseSwitchRegister(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sparseSwitchRegister(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SparseSwitchRegisterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sparseSwitchRegister }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sparseSwitchRegister }
}
antlr_rust::tid!{SparseSwitchRegisterContextExt<'a>}

impl<'input> SparseSwitchRegisterContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SparseSwitchRegisterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SparseSwitchRegisterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SparseSwitchRegisterContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SparseSwitchRegisterContextExt<'input>>{

fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SparseSwitchRegisterContextAttrs<'input> for SparseSwitchRegisterContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sparseSwitchRegister(&mut self,)
	-> Result<Rc<SparseSwitchRegisterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SparseSwitchRegisterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 552, RULE_sparseSwitchRegister);
        let mut _localctx: Rc<SparseSwitchRegisterContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule registerIdentifier*/
			recog.base.set_state(2100);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sparseSwitchLabel ----------------
pub type SparseSwitchLabelContextAll<'input> = SparseSwitchLabelContext<'input>;


pub type SparseSwitchLabelContext<'input> = BaseParserRuleContext<'input,SparseSwitchLabelContextExt<'input>>;

#[derive(Clone)]
pub struct SparseSwitchLabelContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SparseSwitchLabelContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SparseSwitchLabelContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sparseSwitchLabel(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sparseSwitchLabel(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SparseSwitchLabelContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sparseSwitchLabel }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sparseSwitchLabel }
}
antlr_rust::tid!{SparseSwitchLabelContextExt<'a>}

impl<'input> SparseSwitchLabelContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SparseSwitchLabelContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SparseSwitchLabelContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SparseSwitchLabelContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SparseSwitchLabelContextExt<'input>>{

fn label(&self) -> Option<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SparseSwitchLabelContextAttrs<'input> for SparseSwitchLabelContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sparseSwitchLabel(&mut self,)
	-> Result<Rc<SparseSwitchLabelContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SparseSwitchLabelContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 554, RULE_sparseSwitchLabel);
        let mut _localctx: Rc<SparseSwitchLabelContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule label*/
			recog.base.set_state(2102);
			recog.label()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- packedSwitchInstruction ----------------
pub type PackedSwitchInstructionContextAll<'input> = PackedSwitchInstructionContext<'input>;


pub type PackedSwitchInstructionContext<'input> = BaseParserRuleContext<'input,PackedSwitchInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct PackedSwitchInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for PackedSwitchInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for PackedSwitchInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_packedSwitchInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_packedSwitchInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PackedSwitchInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_packedSwitchInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_packedSwitchInstruction }
}
antlr_rust::tid!{PackedSwitchInstructionContextExt<'a>}

impl<'input> PackedSwitchInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PackedSwitchInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PackedSwitchInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PackedSwitchInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<PackedSwitchInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_PACKED_SWITCH
/// Returns `None` if there is no child corresponding to token OP_PACKED_SWITCH
fn OP_PACKED_SWITCH(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_PACKED_SWITCH, 0)
}
fn packedSwitchRegister(&self) -> Option<Rc<PackedSwitchRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn packedSwitchLabel(&self) -> Option<Rc<PackedSwitchLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PackedSwitchInstructionContextAttrs<'input> for PackedSwitchInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn packedSwitchInstruction(&mut self,)
	-> Result<Rc<PackedSwitchInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PackedSwitchInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 556, RULE_packedSwitchInstruction);
        let mut _localctx: Rc<PackedSwitchInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2104);
			recog.base.match_token(OP_PACKED_SWITCH,&mut recog.err_handler)?;

			/*InvokeRule packedSwitchRegister*/
			recog.base.set_state(2105);
			recog.packedSwitchRegister()?;

			recog.base.set_state(2106);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule packedSwitchLabel*/
			recog.base.set_state(2107);
			recog.packedSwitchLabel()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sparseSwitchInstruction ----------------
pub type SparseSwitchInstructionContextAll<'input> = SparseSwitchInstructionContext<'input>;


pub type SparseSwitchInstructionContext<'input> = BaseParserRuleContext<'input,SparseSwitchInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct SparseSwitchInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SparseSwitchInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SparseSwitchInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sparseSwitchInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sparseSwitchInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SparseSwitchInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sparseSwitchInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sparseSwitchInstruction }
}
antlr_rust::tid!{SparseSwitchInstructionContextExt<'a>}

impl<'input> SparseSwitchInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SparseSwitchInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SparseSwitchInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SparseSwitchInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SparseSwitchInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_SPARSE_SWITCH
/// Returns `None` if there is no child corresponding to token OP_SPARSE_SWITCH
fn OP_SPARSE_SWITCH(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_SPARSE_SWITCH, 0)
}
fn sparseSwitchRegister(&self) -> Option<Rc<SparseSwitchRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn sparseSwitchLabel(&self) -> Option<Rc<SparseSwitchLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SparseSwitchInstructionContextAttrs<'input> for SparseSwitchInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sparseSwitchInstruction(&mut self,)
	-> Result<Rc<SparseSwitchInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SparseSwitchInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 558, RULE_sparseSwitchInstruction);
        let mut _localctx: Rc<SparseSwitchInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2109);
			recog.base.match_token(OP_SPARSE_SWITCH,&mut recog.err_handler)?;

			/*InvokeRule sparseSwitchRegister*/
			recog.base.set_state(2110);
			recog.sparseSwitchRegister()?;

			recog.base.set_state(2111);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule sparseSwitchLabel*/
			recog.base.set_state(2112);
			recog.sparseSwitchLabel()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- invokePolymorphicInstruction ----------------
pub type InvokePolymorphicInstructionContextAll<'input> = InvokePolymorphicInstructionContext<'input>;


pub type InvokePolymorphicInstructionContext<'input> = BaseParserRuleContext<'input,InvokePolymorphicInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct InvokePolymorphicInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InvokePolymorphicInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InvokePolymorphicInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_invokePolymorphicInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_invokePolymorphicInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InvokePolymorphicInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_invokePolymorphicInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_invokePolymorphicInstruction }
}
antlr_rust::tid!{InvokePolymorphicInstructionContextExt<'a>}

impl<'input> InvokePolymorphicInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InvokePolymorphicInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InvokePolymorphicInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InvokePolymorphicInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InvokePolymorphicInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INVOKE_POLYMORPHIC
/// Returns `None` if there is no child corresponding to token OP_INVOKE_POLYMORPHIC
fn OP_INVOKE_POLYMORPHIC(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INVOKE_POLYMORPHIC, 0)
}

}

impl<'input> InvokePolymorphicInstructionContextAttrs<'input> for InvokePolymorphicInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn invokePolymorphicInstruction(&mut self,)
	-> Result<Rc<InvokePolymorphicInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InvokePolymorphicInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 560, RULE_invokePolymorphicInstruction);
        let mut _localctx: Rc<InvokePolymorphicInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2114);
			recog.base.match_token(OP_INVOKE_POLYMORPHIC,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- invokePolymorphicRangeInstruction ----------------
pub type InvokePolymorphicRangeInstructionContextAll<'input> = InvokePolymorphicRangeInstructionContext<'input>;


pub type InvokePolymorphicRangeInstructionContext<'input> = BaseParserRuleContext<'input,InvokePolymorphicRangeInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct InvokePolymorphicRangeInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InvokePolymorphicRangeInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InvokePolymorphicRangeInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_invokePolymorphicRangeInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_invokePolymorphicRangeInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InvokePolymorphicRangeInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_invokePolymorphicRangeInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_invokePolymorphicRangeInstruction }
}
antlr_rust::tid!{InvokePolymorphicRangeInstructionContextExt<'a>}

impl<'input> InvokePolymorphicRangeInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InvokePolymorphicRangeInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InvokePolymorphicRangeInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InvokePolymorphicRangeInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InvokePolymorphicRangeInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INVOKE_POLYMORPHIC_RANGE
/// Returns `None` if there is no child corresponding to token OP_INVOKE_POLYMORPHIC_RANGE
fn OP_INVOKE_POLYMORPHIC_RANGE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INVOKE_POLYMORPHIC_RANGE, 0)
}

}

impl<'input> InvokePolymorphicRangeInstructionContextAttrs<'input> for InvokePolymorphicRangeInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn invokePolymorphicRangeInstruction(&mut self,)
	-> Result<Rc<InvokePolymorphicRangeInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InvokePolymorphicRangeInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 562, RULE_invokePolymorphicRangeInstruction);
        let mut _localctx: Rc<InvokePolymorphicRangeInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2116);
			recog.base.match_token(OP_INVOKE_POLYMORPHIC_RANGE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- invokeCustomInstruction ----------------
pub type InvokeCustomInstructionContextAll<'input> = InvokeCustomInstructionContext<'input>;


pub type InvokeCustomInstructionContext<'input> = BaseParserRuleContext<'input,InvokeCustomInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct InvokeCustomInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InvokeCustomInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InvokeCustomInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_invokeCustomInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_invokeCustomInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InvokeCustomInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_invokeCustomInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_invokeCustomInstruction }
}
antlr_rust::tid!{InvokeCustomInstructionContextExt<'a>}

impl<'input> InvokeCustomInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InvokeCustomInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InvokeCustomInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InvokeCustomInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InvokeCustomInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INVOKE_CUSTOM
/// Returns `None` if there is no child corresponding to token OP_INVOKE_CUSTOM
fn OP_INVOKE_CUSTOM(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INVOKE_CUSTOM, 0)
}

}

impl<'input> InvokeCustomInstructionContextAttrs<'input> for InvokeCustomInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn invokeCustomInstruction(&mut self,)
	-> Result<Rc<InvokeCustomInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InvokeCustomInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 564, RULE_invokeCustomInstruction);
        let mut _localctx: Rc<InvokeCustomInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2118);
			recog.base.match_token(OP_INVOKE_CUSTOM,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- invokeCustomRangeInstruction ----------------
pub type InvokeCustomRangeInstructionContextAll<'input> = InvokeCustomRangeInstructionContext<'input>;


pub type InvokeCustomRangeInstructionContext<'input> = BaseParserRuleContext<'input,InvokeCustomRangeInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct InvokeCustomRangeInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InvokeCustomRangeInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InvokeCustomRangeInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_invokeCustomRangeInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_invokeCustomRangeInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InvokeCustomRangeInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_invokeCustomRangeInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_invokeCustomRangeInstruction }
}
antlr_rust::tid!{InvokeCustomRangeInstructionContextExt<'a>}

impl<'input> InvokeCustomRangeInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InvokeCustomRangeInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InvokeCustomRangeInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InvokeCustomRangeInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InvokeCustomRangeInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_INVOKE_CUSTOM_RANGE
/// Returns `None` if there is no child corresponding to token OP_INVOKE_CUSTOM_RANGE
fn OP_INVOKE_CUSTOM_RANGE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_INVOKE_CUSTOM_RANGE, 0)
}

}

impl<'input> InvokeCustomRangeInstructionContextAttrs<'input> for InvokeCustomRangeInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn invokeCustomRangeInstruction(&mut self,)
	-> Result<Rc<InvokeCustomRangeInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InvokeCustomRangeInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 566, RULE_invokeCustomRangeInstruction);
        let mut _localctx: Rc<InvokeCustomRangeInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2120);
			recog.base.match_token(OP_INVOKE_CUSTOM_RANGE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- invokeConstMethodHandleInstruction ----------------
pub type InvokeConstMethodHandleInstructionContextAll<'input> = InvokeConstMethodHandleInstructionContext<'input>;


pub type InvokeConstMethodHandleInstructionContext<'input> = BaseParserRuleContext<'input,InvokeConstMethodHandleInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct InvokeConstMethodHandleInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InvokeConstMethodHandleInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InvokeConstMethodHandleInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_invokeConstMethodHandleInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_invokeConstMethodHandleInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InvokeConstMethodHandleInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_invokeConstMethodHandleInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_invokeConstMethodHandleInstruction }
}
antlr_rust::tid!{InvokeConstMethodHandleInstructionContextExt<'a>}

impl<'input> InvokeConstMethodHandleInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InvokeConstMethodHandleInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InvokeConstMethodHandleInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InvokeConstMethodHandleInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InvokeConstMethodHandleInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_CONST_METHOD_HANDLE
/// Returns `None` if there is no child corresponding to token OP_CONST_METHOD_HANDLE
fn OP_CONST_METHOD_HANDLE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_CONST_METHOD_HANDLE, 0)
}

}

impl<'input> InvokeConstMethodHandleInstructionContextAttrs<'input> for InvokeConstMethodHandleInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn invokeConstMethodHandleInstruction(&mut self,)
	-> Result<Rc<InvokeConstMethodHandleInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InvokeConstMethodHandleInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 568, RULE_invokeConstMethodHandleInstruction);
        let mut _localctx: Rc<InvokeConstMethodHandleInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2122);
			recog.base.match_token(OP_CONST_METHOD_HANDLE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- invokeConstMethodTypeInstruction ----------------
pub type InvokeConstMethodTypeInstructionContextAll<'input> = InvokeConstMethodTypeInstructionContext<'input>;


pub type InvokeConstMethodTypeInstructionContext<'input> = BaseParserRuleContext<'input,InvokeConstMethodTypeInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct InvokeConstMethodTypeInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InvokeConstMethodTypeInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InvokeConstMethodTypeInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_invokeConstMethodTypeInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_invokeConstMethodTypeInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InvokeConstMethodTypeInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_invokeConstMethodTypeInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_invokeConstMethodTypeInstruction }
}
antlr_rust::tid!{InvokeConstMethodTypeInstructionContextExt<'a>}

impl<'input> InvokeConstMethodTypeInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InvokeConstMethodTypeInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InvokeConstMethodTypeInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InvokeConstMethodTypeInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InvokeConstMethodTypeInstructionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OP_CONST_METHOD_TYPE
/// Returns `None` if there is no child corresponding to token OP_CONST_METHOD_TYPE
fn OP_CONST_METHOD_TYPE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(OP_CONST_METHOD_TYPE, 0)
}

}

impl<'input> InvokeConstMethodTypeInstructionContextAttrs<'input> for InvokeConstMethodTypeInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn invokeConstMethodTypeInstruction(&mut self,)
	-> Result<Rc<InvokeConstMethodTypeInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InvokeConstMethodTypeInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 570, RULE_invokeConstMethodTypeInstruction);
        let mut _localctx: Rc<InvokeConstMethodTypeInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2124);
			recog.base.match_token(OP_CONST_METHOD_TYPE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- binaryInstruction ----------------
pub type BinaryInstructionContextAll<'input> = BinaryInstructionContext<'input>;


pub type BinaryInstructionContext<'input> = BaseParserRuleContext<'input,BinaryInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct BinaryInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for BinaryInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for BinaryInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_binaryInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_binaryInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for BinaryInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_binaryInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_binaryInstruction }
}
antlr_rust::tid!{BinaryInstructionContextExt<'a>}

impl<'input> BinaryInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BinaryInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BinaryInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BinaryInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<BinaryInstructionContextExt<'input>>{

fn filledNewArrayRangeInstruction(&self) -> Option<Rc<FilledNewArrayRangeInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn filledNewArrayInstruction(&self) -> Option<Rc<FilledNewArrayInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn fillArrayDataInstruction(&self) -> Option<Rc<FillArrayDataInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayLengthInstruction(&self) -> Option<Rc<ArrayLengthInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn packedSwitchInstruction(&self) -> Option<Rc<PackedSwitchInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sparseSwitchInstruction(&self) -> Option<Rc<SparseSwitchInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn newInstanceInstruction(&self) -> Option<Rc<NewInstanceInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn checkCastInstruction(&self) -> Option<Rc<CheckCastInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn moveInstruction(&self) -> Option<Rc<MoveInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn moveFrom16Instruction(&self) -> Option<Rc<MoveFrom16InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn move16Instruction(&self) -> Option<Rc<Move16InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn moveWideInstruction(&self) -> Option<Rc<MoveWideInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn moveWideFrom16Instruction(&self) -> Option<Rc<MoveWideFrom16InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn moveWide16Instruction(&self) -> Option<Rc<MoveWide16InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn moveObjectInstruction(&self) -> Option<Rc<MoveObjectInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn moveObjectFrom16Instruction(&self) -> Option<Rc<MoveObjectFrom16InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn moveObject16Instruction(&self) -> Option<Rc<MoveObject16InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constInstruction(&self) -> Option<Rc<ConstInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn const4Instruction(&self) -> Option<Rc<Const4InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn const16Instruction(&self) -> Option<Rc<Const16InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constHigh16Instruction(&self) -> Option<Rc<ConstHigh16InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constWide16Instruction(&self) -> Option<Rc<ConstWide16InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constWide32Instruction(&self) -> Option<Rc<ConstWide32InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constWideInstruction(&self) -> Option<Rc<ConstWideInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constWideHigh16Instruction(&self) -> Option<Rc<ConstWideHigh16InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constString(&self) -> Option<Rc<ConstStringContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constStringJumbo(&self) -> Option<Rc<ConstStringJumboContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn constClass(&self) -> Option<Rc<ConstClassContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sGetInstruction(&self) -> Option<Rc<SGetInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sGetWideInstruction(&self) -> Option<Rc<SGetWideInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sGetObjectInstruction(&self) -> Option<Rc<SGetObjectInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sGetBooleanInstruction(&self) -> Option<Rc<SGetBooleanInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sGetByteInstruction(&self) -> Option<Rc<SGetByteInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sGetCharInstruction(&self) -> Option<Rc<SGetCharInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sGetShortInstruction(&self) -> Option<Rc<SGetShortInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sPutInstruction(&self) -> Option<Rc<SPutInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sPutWideInstruction(&self) -> Option<Rc<SPutWideInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sPutObjectInstruction(&self) -> Option<Rc<SPutObjectInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sPutBooleanInstruction(&self) -> Option<Rc<SPutBooleanInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sPutByteInstruction(&self) -> Option<Rc<SPutByteInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sPutCharInstruction(&self) -> Option<Rc<SPutCharInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sPutShortInstruction(&self) -> Option<Rc<SPutShortInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn invokeVirtualInstruction(&self) -> Option<Rc<InvokeVirtualInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn invokeSuperInstruction(&self) -> Option<Rc<InvokeSuperInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn invokeDirectInstruction(&self) -> Option<Rc<InvokeDirectInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn invokeStaticInstruction(&self) -> Option<Rc<InvokeStaticInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn invokeInterfaceInstruction(&self) -> Option<Rc<InvokeInterfaceInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn invokeVirtualRangeInstruction(&self) -> Option<Rc<InvokeVirtualRangeInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn invokeSuperRangeInstruction(&self) -> Option<Rc<InvokeSuperRangeInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn invokeDirectRangeInstruction(&self) -> Option<Rc<InvokeDirectRangeInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn invokeStaticRangeInstruction(&self) -> Option<Rc<InvokeStaticRangeInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn invokeInterfaceRangeInstruction(&self) -> Option<Rc<InvokeInterfaceRangeInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn intToLongInstruction(&self) -> Option<Rc<IntToLongInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn intToFloatInstruction(&self) -> Option<Rc<IntToFloatInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn intToDoubleInstruction(&self) -> Option<Rc<IntToDoubleInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn longToIntInstruction(&self) -> Option<Rc<LongToIntInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn longToFloatInstruction(&self) -> Option<Rc<LongToFloatInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn longToDoubleInstruction(&self) -> Option<Rc<LongToDoubleInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn floatToIntInstruction(&self) -> Option<Rc<FloatToIntInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn floatToLongInstruction(&self) -> Option<Rc<FloatToLongInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn floatToDoubleInstruction(&self) -> Option<Rc<FloatToDoubleInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn doubleToIntInstruction(&self) -> Option<Rc<DoubleToIntInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn doubleToLongInstruction(&self) -> Option<Rc<DoubleToLongInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn doubleToFloatInstruction(&self) -> Option<Rc<DoubleToFloatInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn intToByteInstruction(&self) -> Option<Rc<IntToByteInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn intToCharInstruction(&self) -> Option<Rc<IntToCharInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn intToShortInstruction(&self) -> Option<Rc<IntToShortInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifEqzInstruction(&self) -> Option<Rc<IfEqzInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifNezInstruction(&self) -> Option<Rc<IfNezInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifLtzInstruction(&self) -> Option<Rc<IfLtzInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifGezInstruction(&self) -> Option<Rc<IfGezInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifGtzInstruction(&self) -> Option<Rc<IfGtzInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifLezInstruction(&self) -> Option<Rc<IfLezInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn negIntInstruction(&self) -> Option<Rc<NegIntInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn notIntInstruction(&self) -> Option<Rc<NotIntInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn negLongInstruction(&self) -> Option<Rc<NegLongInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn notLongInstruction(&self) -> Option<Rc<NotLongInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn negFloatInstruction(&self) -> Option<Rc<NegFloatInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn negDoubleInstruction(&self) -> Option<Rc<NegDoubleInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifEqInstruction(&self) -> Option<Rc<IfEqInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifNeInstruction(&self) -> Option<Rc<IfNeInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifLtInstruction(&self) -> Option<Rc<IfLtInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifGeInstruction(&self) -> Option<Rc<IfGeInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifGtInstruction(&self) -> Option<Rc<IfGtInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ifLeInstruction(&self) -> Option<Rc<IfLeInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn addInt2addrInstruction(&self) -> Option<Rc<AddInt2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn subInt2addrInstruction(&self) -> Option<Rc<SubInt2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn mulInt2addrInstruction(&self) -> Option<Rc<MulInt2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn divInt2addrInstruction(&self) -> Option<Rc<DivInt2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn remInt2addrInstruction(&self) -> Option<Rc<RemInt2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn andInt2addrInstruction(&self) -> Option<Rc<AndInt2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn orInt2addrInstruction(&self) -> Option<Rc<OrInt2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn xorInt2addrInstruction(&self) -> Option<Rc<XorInt2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn shlInt2addrInstruction(&self) -> Option<Rc<ShlInt2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn shrInt2addrInstruction(&self) -> Option<Rc<ShrInt2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ushrInt2addrInstruction(&self) -> Option<Rc<UshrInt2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn addLong2addrInstruction(&self) -> Option<Rc<AddLong2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn subLong2addrInstruction(&self) -> Option<Rc<SubLong2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn mulLong2addrInstruction(&self) -> Option<Rc<MulLong2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn divLong2addrInstruction(&self) -> Option<Rc<DivLong2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn remLong2addrInstruction(&self) -> Option<Rc<RemLong2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn andLong2addrInstruction(&self) -> Option<Rc<AndLong2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn orLong2addrInstruction(&self) -> Option<Rc<OrLong2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn xorLong2addrInstruction(&self) -> Option<Rc<XorLong2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn shlLong2addrInstruction(&self) -> Option<Rc<ShlLong2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn shrLong2addrInstruction(&self) -> Option<Rc<ShrLong2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ushrLong2addrInstruction(&self) -> Option<Rc<UshrLong2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn addFloat2addrInstruction(&self) -> Option<Rc<AddFloat2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn subFloat2addrInstruction(&self) -> Option<Rc<SubFloat2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn mulFloat2addrInstruction(&self) -> Option<Rc<MulFloat2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn divFloat2addrInstruction(&self) -> Option<Rc<DivFloat2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn remFloat2addrInstruction(&self) -> Option<Rc<RemFloat2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn addDouble2addrInstruction(&self) -> Option<Rc<AddDouble2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn subDouble2addrInstruction(&self) -> Option<Rc<SubDouble2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn mulDouble2addrInstruction(&self) -> Option<Rc<MulDouble2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn divDouble2addrInstruction(&self) -> Option<Rc<DivDouble2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn remDouble2addrInstruction(&self) -> Option<Rc<RemDouble2addrInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn cmplFloatInstruction(&self) -> Option<Rc<CmplFloatInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn cmpgFloatInstruction(&self) -> Option<Rc<CmpgFloatInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn cmplDoubleInstruction(&self) -> Option<Rc<CmplDoubleInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn cmpgDoubleInstruction(&self) -> Option<Rc<CmpgDoubleInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn cmpLongInstruction(&self) -> Option<Rc<CmpLongInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> BinaryInstructionContextAttrs<'input> for BinaryInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn binaryInstruction(&mut self,)
	-> Result<Rc<BinaryInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BinaryInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 572, RULE_binaryInstruction);
        let mut _localctx: Rc<BinaryInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2248);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 OP_FILLED_NEW_ARRAY_RANGE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule filledNewArrayRangeInstruction*/
					recog.base.set_state(2126);
					recog.filledNewArrayRangeInstruction()?;

					}
				}

			 OP_FILLED_NEW_ARRAY 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule filledNewArrayInstruction*/
					recog.base.set_state(2127);
					recog.filledNewArrayInstruction()?;

					}
				}

			 OP_FILL_ARRAY_DATA 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule fillArrayDataInstruction*/
					recog.base.set_state(2128);
					recog.fillArrayDataInstruction()?;

					}
				}

			 OP_ARRAY_LENGTH 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule arrayLengthInstruction*/
					recog.base.set_state(2129);
					recog.arrayLengthInstruction()?;

					}
				}

			 OP_PACKED_SWITCH 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule packedSwitchInstruction*/
					recog.base.set_state(2130);
					recog.packedSwitchInstruction()?;

					}
				}

			 OP_SPARSE_SWITCH 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule sparseSwitchInstruction*/
					recog.base.set_state(2131);
					recog.sparseSwitchInstruction()?;

					}
				}

			 OP_NEW_INSTANCE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule newInstanceInstruction*/
					recog.base.set_state(2132);
					recog.newInstanceInstruction()?;

					}
				}

			 OP_CHECK_CAST 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule checkCastInstruction*/
					recog.base.set_state(2133);
					recog.checkCastInstruction()?;

					}
				}

			 OP_MOVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule moveInstruction*/
					recog.base.set_state(2134);
					recog.moveInstruction()?;

					}
				}

			 OP_MOVE_FROM16 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					/*InvokeRule moveFrom16Instruction*/
					recog.base.set_state(2135);
					recog.moveFrom16Instruction()?;

					}
				}

			 OP_MOVE_16 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					/*InvokeRule move16Instruction*/
					recog.base.set_state(2136);
					recog.move16Instruction()?;

					}
				}

			 OP_MOVE_WIDE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 12);
					recog.base.enter_outer_alt(None, 12);
					{
					/*InvokeRule moveWideInstruction*/
					recog.base.set_state(2137);
					recog.moveWideInstruction()?;

					}
				}

			 OP_MOVE_WIDE_FROM16 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 13);
					recog.base.enter_outer_alt(None, 13);
					{
					/*InvokeRule moveWideFrom16Instruction*/
					recog.base.set_state(2138);
					recog.moveWideFrom16Instruction()?;

					}
				}

			 OP_MOVE_WIDE_16 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 14);
					recog.base.enter_outer_alt(None, 14);
					{
					/*InvokeRule moveWide16Instruction*/
					recog.base.set_state(2139);
					recog.moveWide16Instruction()?;

					}
				}

			 OP_MOVE_OBJECT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 15);
					recog.base.enter_outer_alt(None, 15);
					{
					/*InvokeRule moveObjectInstruction*/
					recog.base.set_state(2140);
					recog.moveObjectInstruction()?;

					}
				}

			 OP_MOVE_OBJECT_FROM16 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 16);
					recog.base.enter_outer_alt(None, 16);
					{
					/*InvokeRule moveObjectFrom16Instruction*/
					recog.base.set_state(2141);
					recog.moveObjectFrom16Instruction()?;

					}
				}

			 OP_MOVE_OBJECT_16 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 17);
					recog.base.enter_outer_alt(None, 17);
					{
					/*InvokeRule moveObject16Instruction*/
					recog.base.set_state(2142);
					recog.moveObject16Instruction()?;

					}
				}

			 OP_CONST 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 18);
					recog.base.enter_outer_alt(None, 18);
					{
					/*InvokeRule constInstruction*/
					recog.base.set_state(2143);
					recog.constInstruction()?;

					}
				}

			 OP_CONST_4 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 19);
					recog.base.enter_outer_alt(None, 19);
					{
					/*InvokeRule const4Instruction*/
					recog.base.set_state(2144);
					recog.const4Instruction()?;

					}
				}

			 OP_CONST_16 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 20);
					recog.base.enter_outer_alt(None, 20);
					{
					/*InvokeRule const16Instruction*/
					recog.base.set_state(2145);
					recog.const16Instruction()?;

					}
				}

			 OP_CONST_HIGH16 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 21);
					recog.base.enter_outer_alt(None, 21);
					{
					/*InvokeRule constHigh16Instruction*/
					recog.base.set_state(2146);
					recog.constHigh16Instruction()?;

					}
				}

			 OP_CONST_WIDE_16 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 22);
					recog.base.enter_outer_alt(None, 22);
					{
					/*InvokeRule constWide16Instruction*/
					recog.base.set_state(2147);
					recog.constWide16Instruction()?;

					}
				}

			 OP_CONST_WIDE_32 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 23);
					recog.base.enter_outer_alt(None, 23);
					{
					/*InvokeRule constWide32Instruction*/
					recog.base.set_state(2148);
					recog.constWide32Instruction()?;

					}
				}

			 OP_CONST_WIDE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 24);
					recog.base.enter_outer_alt(None, 24);
					{
					/*InvokeRule constWideInstruction*/
					recog.base.set_state(2149);
					recog.constWideInstruction()?;

					}
				}

			 OP_CONST_WIDE_HIGH16 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 25);
					recog.base.enter_outer_alt(None, 25);
					{
					/*InvokeRule constWideHigh16Instruction*/
					recog.base.set_state(2150);
					recog.constWideHigh16Instruction()?;

					}
				}

			 OP_CONST_STRING 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 26);
					recog.base.enter_outer_alt(None, 26);
					{
					/*InvokeRule constString*/
					recog.base.set_state(2151);
					recog.constString()?;

					}
				}

			 OP_CONST_STRING_JUMBO 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 27);
					recog.base.enter_outer_alt(None, 27);
					{
					/*InvokeRule constStringJumbo*/
					recog.base.set_state(2152);
					recog.constStringJumbo()?;

					}
				}

			 OP_CONST_CLASS 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 28);
					recog.base.enter_outer_alt(None, 28);
					{
					/*InvokeRule constClass*/
					recog.base.set_state(2153);
					recog.constClass()?;

					}
				}

			 OP_SGET 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 29);
					recog.base.enter_outer_alt(None, 29);
					{
					/*InvokeRule sGetInstruction*/
					recog.base.set_state(2154);
					recog.sGetInstruction()?;

					}
				}

			 OP_SGET_WIDE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 30);
					recog.base.enter_outer_alt(None, 30);
					{
					/*InvokeRule sGetWideInstruction*/
					recog.base.set_state(2155);
					recog.sGetWideInstruction()?;

					}
				}

			 OP_SGET_OBJECT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 31);
					recog.base.enter_outer_alt(None, 31);
					{
					/*InvokeRule sGetObjectInstruction*/
					recog.base.set_state(2156);
					recog.sGetObjectInstruction()?;

					}
				}

			 OP_SGET_BOOLEAN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 32);
					recog.base.enter_outer_alt(None, 32);
					{
					/*InvokeRule sGetBooleanInstruction*/
					recog.base.set_state(2157);
					recog.sGetBooleanInstruction()?;

					}
				}

			 OP_SGET_BYTE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 33);
					recog.base.enter_outer_alt(None, 33);
					{
					/*InvokeRule sGetByteInstruction*/
					recog.base.set_state(2158);
					recog.sGetByteInstruction()?;

					}
				}

			 OP_SGET_CHAR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 34);
					recog.base.enter_outer_alt(None, 34);
					{
					/*InvokeRule sGetCharInstruction*/
					recog.base.set_state(2159);
					recog.sGetCharInstruction()?;

					}
				}

			 OP_SGET_SHORT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 35);
					recog.base.enter_outer_alt(None, 35);
					{
					/*InvokeRule sGetShortInstruction*/
					recog.base.set_state(2160);
					recog.sGetShortInstruction()?;

					}
				}

			 OP_SPUT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 36);
					recog.base.enter_outer_alt(None, 36);
					{
					/*InvokeRule sPutInstruction*/
					recog.base.set_state(2161);
					recog.sPutInstruction()?;

					}
				}

			 OP_SPUT_WIDE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 37);
					recog.base.enter_outer_alt(None, 37);
					{
					/*InvokeRule sPutWideInstruction*/
					recog.base.set_state(2162);
					recog.sPutWideInstruction()?;

					}
				}

			 OP_SPUT_OBJECT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 38);
					recog.base.enter_outer_alt(None, 38);
					{
					/*InvokeRule sPutObjectInstruction*/
					recog.base.set_state(2163);
					recog.sPutObjectInstruction()?;

					}
				}

			 OP_SPUT_BOOLEAN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 39);
					recog.base.enter_outer_alt(None, 39);
					{
					/*InvokeRule sPutBooleanInstruction*/
					recog.base.set_state(2164);
					recog.sPutBooleanInstruction()?;

					}
				}

			 OP_SPUT_BYTE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 40);
					recog.base.enter_outer_alt(None, 40);
					{
					/*InvokeRule sPutByteInstruction*/
					recog.base.set_state(2165);
					recog.sPutByteInstruction()?;

					}
				}

			 OP_SPUT_CHAR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 41);
					recog.base.enter_outer_alt(None, 41);
					{
					/*InvokeRule sPutCharInstruction*/
					recog.base.set_state(2166);
					recog.sPutCharInstruction()?;

					}
				}

			 OP_SPUT_SHORT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 42);
					recog.base.enter_outer_alt(None, 42);
					{
					/*InvokeRule sPutShortInstruction*/
					recog.base.set_state(2167);
					recog.sPutShortInstruction()?;

					}
				}

			 OP_INVOKE_VIRTUAL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 43);
					recog.base.enter_outer_alt(None, 43);
					{
					/*InvokeRule invokeVirtualInstruction*/
					recog.base.set_state(2168);
					recog.invokeVirtualInstruction()?;

					}
				}

			 OP_INVOKE_SUPER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 44);
					recog.base.enter_outer_alt(None, 44);
					{
					/*InvokeRule invokeSuperInstruction*/
					recog.base.set_state(2169);
					recog.invokeSuperInstruction()?;

					}
				}

			 OP_INVOKE_DIRECT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 45);
					recog.base.enter_outer_alt(None, 45);
					{
					/*InvokeRule invokeDirectInstruction*/
					recog.base.set_state(2170);
					recog.invokeDirectInstruction()?;

					}
				}

			 OP_INVOKE_STATIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 46);
					recog.base.enter_outer_alt(None, 46);
					{
					/*InvokeRule invokeStaticInstruction*/
					recog.base.set_state(2171);
					recog.invokeStaticInstruction()?;

					}
				}

			 OP_INVOKE_INTERFACE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 47);
					recog.base.enter_outer_alt(None, 47);
					{
					/*InvokeRule invokeInterfaceInstruction*/
					recog.base.set_state(2172);
					recog.invokeInterfaceInstruction()?;

					}
				}

			 OP_INVOKE_VIRTUAL_RANGE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 48);
					recog.base.enter_outer_alt(None, 48);
					{
					/*InvokeRule invokeVirtualRangeInstruction*/
					recog.base.set_state(2173);
					recog.invokeVirtualRangeInstruction()?;

					}
				}

			 OP_INVOKE_SUPER_RANGE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 49);
					recog.base.enter_outer_alt(None, 49);
					{
					/*InvokeRule invokeSuperRangeInstruction*/
					recog.base.set_state(2174);
					recog.invokeSuperRangeInstruction()?;

					}
				}

			 OP_INVOKE_DIRECT_RANGE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 50);
					recog.base.enter_outer_alt(None, 50);
					{
					/*InvokeRule invokeDirectRangeInstruction*/
					recog.base.set_state(2175);
					recog.invokeDirectRangeInstruction()?;

					}
				}

			 OP_INVOKE_STATIC_RANGE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 51);
					recog.base.enter_outer_alt(None, 51);
					{
					/*InvokeRule invokeStaticRangeInstruction*/
					recog.base.set_state(2176);
					recog.invokeStaticRangeInstruction()?;

					}
				}

			 OP_INVOKE_INTERFACE_RANGE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 52);
					recog.base.enter_outer_alt(None, 52);
					{
					/*InvokeRule invokeInterfaceRangeInstruction*/
					recog.base.set_state(2177);
					recog.invokeInterfaceRangeInstruction()?;

					}
				}

			 OP_INT_TO_LONG 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 53);
					recog.base.enter_outer_alt(None, 53);
					{
					/*InvokeRule intToLongInstruction*/
					recog.base.set_state(2178);
					recog.intToLongInstruction()?;

					}
				}

			 OP_INT_TO_FLOAT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 54);
					recog.base.enter_outer_alt(None, 54);
					{
					/*InvokeRule intToFloatInstruction*/
					recog.base.set_state(2179);
					recog.intToFloatInstruction()?;

					}
				}

			 OP_INT_TO_DOUBLE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 55);
					recog.base.enter_outer_alt(None, 55);
					{
					/*InvokeRule intToDoubleInstruction*/
					recog.base.set_state(2180);
					recog.intToDoubleInstruction()?;

					}
				}

			 OP_LONG_TO_INT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 56);
					recog.base.enter_outer_alt(None, 56);
					{
					/*InvokeRule longToIntInstruction*/
					recog.base.set_state(2181);
					recog.longToIntInstruction()?;

					}
				}

			 OP_LONG_TO_FLOAT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 57);
					recog.base.enter_outer_alt(None, 57);
					{
					/*InvokeRule longToFloatInstruction*/
					recog.base.set_state(2182);
					recog.longToFloatInstruction()?;

					}
				}

			 OP_LONG_TO_DOUBLE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 58);
					recog.base.enter_outer_alt(None, 58);
					{
					/*InvokeRule longToDoubleInstruction*/
					recog.base.set_state(2183);
					recog.longToDoubleInstruction()?;

					}
				}

			 OP_FLOAT_TO_INT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 59);
					recog.base.enter_outer_alt(None, 59);
					{
					/*InvokeRule floatToIntInstruction*/
					recog.base.set_state(2184);
					recog.floatToIntInstruction()?;

					}
				}

			 OP_FLOAT_TO_LONG 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 60);
					recog.base.enter_outer_alt(None, 60);
					{
					/*InvokeRule floatToLongInstruction*/
					recog.base.set_state(2185);
					recog.floatToLongInstruction()?;

					}
				}

			 OP_FLOAT_TO_DOUBLE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 61);
					recog.base.enter_outer_alt(None, 61);
					{
					/*InvokeRule floatToDoubleInstruction*/
					recog.base.set_state(2186);
					recog.floatToDoubleInstruction()?;

					}
				}

			 OP_DOUBLE_TO_INT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 62);
					recog.base.enter_outer_alt(None, 62);
					{
					/*InvokeRule doubleToIntInstruction*/
					recog.base.set_state(2187);
					recog.doubleToIntInstruction()?;

					}
				}

			 OP_DOUBLE_TO_LONG 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 63);
					recog.base.enter_outer_alt(None, 63);
					{
					/*InvokeRule doubleToLongInstruction*/
					recog.base.set_state(2188);
					recog.doubleToLongInstruction()?;

					}
				}

			 OP_DOUBLE_TO_FLOAT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 64);
					recog.base.enter_outer_alt(None, 64);
					{
					/*InvokeRule doubleToFloatInstruction*/
					recog.base.set_state(2189);
					recog.doubleToFloatInstruction()?;

					}
				}

			 OP_INT_TO_BYTE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 65);
					recog.base.enter_outer_alt(None, 65);
					{
					/*InvokeRule intToByteInstruction*/
					recog.base.set_state(2190);
					recog.intToByteInstruction()?;

					}
				}

			 OP_INT_TO_CHAR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 66);
					recog.base.enter_outer_alt(None, 66);
					{
					/*InvokeRule intToCharInstruction*/
					recog.base.set_state(2191);
					recog.intToCharInstruction()?;

					}
				}

			 OP_INT_TO_SHORT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 67);
					recog.base.enter_outer_alt(None, 67);
					{
					/*InvokeRule intToShortInstruction*/
					recog.base.set_state(2192);
					recog.intToShortInstruction()?;

					}
				}

			 OP_IF_EQZ 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 68);
					recog.base.enter_outer_alt(None, 68);
					{
					/*InvokeRule ifEqzInstruction*/
					recog.base.set_state(2193);
					recog.ifEqzInstruction()?;

					}
				}

			 OP_IF_NEZ 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 69);
					recog.base.enter_outer_alt(None, 69);
					{
					/*InvokeRule ifNezInstruction*/
					recog.base.set_state(2194);
					recog.ifNezInstruction()?;

					}
				}

			 OP_IF_LTZ 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 70);
					recog.base.enter_outer_alt(None, 70);
					{
					/*InvokeRule ifLtzInstruction*/
					recog.base.set_state(2195);
					recog.ifLtzInstruction()?;

					}
				}

			 OP_IF_GEZ 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 71);
					recog.base.enter_outer_alt(None, 71);
					{
					/*InvokeRule ifGezInstruction*/
					recog.base.set_state(2196);
					recog.ifGezInstruction()?;

					}
				}

			 OP_IF_GTZ 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 72);
					recog.base.enter_outer_alt(None, 72);
					{
					/*InvokeRule ifGtzInstruction*/
					recog.base.set_state(2197);
					recog.ifGtzInstruction()?;

					}
				}

			 OP_IF_LEZ 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 73);
					recog.base.enter_outer_alt(None, 73);
					{
					/*InvokeRule ifLezInstruction*/
					recog.base.set_state(2198);
					recog.ifLezInstruction()?;

					}
				}

			 OP_NEG_INT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 74);
					recog.base.enter_outer_alt(None, 74);
					{
					/*InvokeRule negIntInstruction*/
					recog.base.set_state(2199);
					recog.negIntInstruction()?;

					}
				}

			 OP_NOT_INT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 75);
					recog.base.enter_outer_alt(None, 75);
					{
					/*InvokeRule notIntInstruction*/
					recog.base.set_state(2200);
					recog.notIntInstruction()?;

					}
				}

			 OP_NEG_LONG 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 76);
					recog.base.enter_outer_alt(None, 76);
					{
					/*InvokeRule negLongInstruction*/
					recog.base.set_state(2201);
					recog.negLongInstruction()?;

					}
				}

			 OP_NOT_LONG 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 77);
					recog.base.enter_outer_alt(None, 77);
					{
					/*InvokeRule notLongInstruction*/
					recog.base.set_state(2202);
					recog.notLongInstruction()?;

					}
				}

			 OP_NEG_FLOAT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 78);
					recog.base.enter_outer_alt(None, 78);
					{
					/*InvokeRule negFloatInstruction*/
					recog.base.set_state(2203);
					recog.negFloatInstruction()?;

					}
				}

			 OP_NEG_DOUBLE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 79);
					recog.base.enter_outer_alt(None, 79);
					{
					/*InvokeRule negDoubleInstruction*/
					recog.base.set_state(2204);
					recog.negDoubleInstruction()?;

					}
				}

			 OP_IF_EQ 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 80);
					recog.base.enter_outer_alt(None, 80);
					{
					/*InvokeRule ifEqInstruction*/
					recog.base.set_state(2205);
					recog.ifEqInstruction()?;

					}
				}

			 OP_IF_NE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 81);
					recog.base.enter_outer_alt(None, 81);
					{
					/*InvokeRule ifNeInstruction*/
					recog.base.set_state(2206);
					recog.ifNeInstruction()?;

					}
				}

			 OP_IF_LT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 82);
					recog.base.enter_outer_alt(None, 82);
					{
					/*InvokeRule ifLtInstruction*/
					recog.base.set_state(2207);
					recog.ifLtInstruction()?;

					}
				}

			 OP_IF_GE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 83);
					recog.base.enter_outer_alt(None, 83);
					{
					/*InvokeRule ifGeInstruction*/
					recog.base.set_state(2208);
					recog.ifGeInstruction()?;

					}
				}

			 OP_IF_GT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 84);
					recog.base.enter_outer_alt(None, 84);
					{
					/*InvokeRule ifGtInstruction*/
					recog.base.set_state(2209);
					recog.ifGtInstruction()?;

					}
				}

			 OP_IF_LE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 85);
					recog.base.enter_outer_alt(None, 85);
					{
					/*InvokeRule ifLeInstruction*/
					recog.base.set_state(2210);
					recog.ifLeInstruction()?;

					}
				}

			 OP_ADD_INT_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 86);
					recog.base.enter_outer_alt(None, 86);
					{
					/*InvokeRule addInt2addrInstruction*/
					recog.base.set_state(2211);
					recog.addInt2addrInstruction()?;

					}
				}

			 OP_SUB_INT_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 87);
					recog.base.enter_outer_alt(None, 87);
					{
					/*InvokeRule subInt2addrInstruction*/
					recog.base.set_state(2212);
					recog.subInt2addrInstruction()?;

					}
				}

			 OP_MUL_INT_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 88);
					recog.base.enter_outer_alt(None, 88);
					{
					/*InvokeRule mulInt2addrInstruction*/
					recog.base.set_state(2213);
					recog.mulInt2addrInstruction()?;

					}
				}

			 OP_DIV_INT_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 89);
					recog.base.enter_outer_alt(None, 89);
					{
					/*InvokeRule divInt2addrInstruction*/
					recog.base.set_state(2214);
					recog.divInt2addrInstruction()?;

					}
				}

			 OP_REM_INT_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 90);
					recog.base.enter_outer_alt(None, 90);
					{
					/*InvokeRule remInt2addrInstruction*/
					recog.base.set_state(2215);
					recog.remInt2addrInstruction()?;

					}
				}

			 OP_AND_INT_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 91);
					recog.base.enter_outer_alt(None, 91);
					{
					/*InvokeRule andInt2addrInstruction*/
					recog.base.set_state(2216);
					recog.andInt2addrInstruction()?;

					}
				}

			 OP_OR_INT_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 92);
					recog.base.enter_outer_alt(None, 92);
					{
					/*InvokeRule orInt2addrInstruction*/
					recog.base.set_state(2217);
					recog.orInt2addrInstruction()?;

					}
				}

			 OP_XOR_INT_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 93);
					recog.base.enter_outer_alt(None, 93);
					{
					/*InvokeRule xorInt2addrInstruction*/
					recog.base.set_state(2218);
					recog.xorInt2addrInstruction()?;

					}
				}

			 OP_SHL_INT_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 94);
					recog.base.enter_outer_alt(None, 94);
					{
					/*InvokeRule shlInt2addrInstruction*/
					recog.base.set_state(2219);
					recog.shlInt2addrInstruction()?;

					}
				}

			 OP_SHR_INT_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 95);
					recog.base.enter_outer_alt(None, 95);
					{
					/*InvokeRule shrInt2addrInstruction*/
					recog.base.set_state(2220);
					recog.shrInt2addrInstruction()?;

					}
				}

			 OP_USHR_INT_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 96);
					recog.base.enter_outer_alt(None, 96);
					{
					/*InvokeRule ushrInt2addrInstruction*/
					recog.base.set_state(2221);
					recog.ushrInt2addrInstruction()?;

					}
				}

			 OP_ADD_LONG_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 97);
					recog.base.enter_outer_alt(None, 97);
					{
					/*InvokeRule addLong2addrInstruction*/
					recog.base.set_state(2222);
					recog.addLong2addrInstruction()?;

					}
				}

			 OP_SUB_LONG_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 98);
					recog.base.enter_outer_alt(None, 98);
					{
					/*InvokeRule subLong2addrInstruction*/
					recog.base.set_state(2223);
					recog.subLong2addrInstruction()?;

					}
				}

			 OP_MUL_LONG_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 99);
					recog.base.enter_outer_alt(None, 99);
					{
					/*InvokeRule mulLong2addrInstruction*/
					recog.base.set_state(2224);
					recog.mulLong2addrInstruction()?;

					}
				}

			 OP_DIV_LONG_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 100);
					recog.base.enter_outer_alt(None, 100);
					{
					/*InvokeRule divLong2addrInstruction*/
					recog.base.set_state(2225);
					recog.divLong2addrInstruction()?;

					}
				}

			 OP_REM_LONG_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 101);
					recog.base.enter_outer_alt(None, 101);
					{
					/*InvokeRule remLong2addrInstruction*/
					recog.base.set_state(2226);
					recog.remLong2addrInstruction()?;

					}
				}

			 OP_AND_LONG_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 102);
					recog.base.enter_outer_alt(None, 102);
					{
					/*InvokeRule andLong2addrInstruction*/
					recog.base.set_state(2227);
					recog.andLong2addrInstruction()?;

					}
				}

			 OP_OR_LONG_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 103);
					recog.base.enter_outer_alt(None, 103);
					{
					/*InvokeRule orLong2addrInstruction*/
					recog.base.set_state(2228);
					recog.orLong2addrInstruction()?;

					}
				}

			 OP_XOR_LONG_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 104);
					recog.base.enter_outer_alt(None, 104);
					{
					/*InvokeRule xorLong2addrInstruction*/
					recog.base.set_state(2229);
					recog.xorLong2addrInstruction()?;

					}
				}

			 OP_SHL_LONG_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 105);
					recog.base.enter_outer_alt(None, 105);
					{
					/*InvokeRule shlLong2addrInstruction*/
					recog.base.set_state(2230);
					recog.shlLong2addrInstruction()?;

					}
				}

			 OP_SHR_LONG_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 106);
					recog.base.enter_outer_alt(None, 106);
					{
					/*InvokeRule shrLong2addrInstruction*/
					recog.base.set_state(2231);
					recog.shrLong2addrInstruction()?;

					}
				}

			 OP_USHR_LONG_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 107);
					recog.base.enter_outer_alt(None, 107);
					{
					/*InvokeRule ushrLong2addrInstruction*/
					recog.base.set_state(2232);
					recog.ushrLong2addrInstruction()?;

					}
				}

			 OP_ADD_FLOAT_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 108);
					recog.base.enter_outer_alt(None, 108);
					{
					/*InvokeRule addFloat2addrInstruction*/
					recog.base.set_state(2233);
					recog.addFloat2addrInstruction()?;

					}
				}

			 OP_SUB_FLOAT_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 109);
					recog.base.enter_outer_alt(None, 109);
					{
					/*InvokeRule subFloat2addrInstruction*/
					recog.base.set_state(2234);
					recog.subFloat2addrInstruction()?;

					}
				}

			 OP_MUL_FLOAT_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 110);
					recog.base.enter_outer_alt(None, 110);
					{
					/*InvokeRule mulFloat2addrInstruction*/
					recog.base.set_state(2235);
					recog.mulFloat2addrInstruction()?;

					}
				}

			 OP_DIV_FLOAT_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 111);
					recog.base.enter_outer_alt(None, 111);
					{
					/*InvokeRule divFloat2addrInstruction*/
					recog.base.set_state(2236);
					recog.divFloat2addrInstruction()?;

					}
				}

			 OP_REM_FLOAT_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 112);
					recog.base.enter_outer_alt(None, 112);
					{
					/*InvokeRule remFloat2addrInstruction*/
					recog.base.set_state(2237);
					recog.remFloat2addrInstruction()?;

					}
				}

			 OP_ADD_DOUBLE_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 113);
					recog.base.enter_outer_alt(None, 113);
					{
					/*InvokeRule addDouble2addrInstruction*/
					recog.base.set_state(2238);
					recog.addDouble2addrInstruction()?;

					}
				}

			 OP_SUB_DOUBLE_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 114);
					recog.base.enter_outer_alt(None, 114);
					{
					/*InvokeRule subDouble2addrInstruction*/
					recog.base.set_state(2239);
					recog.subDouble2addrInstruction()?;

					}
				}

			 OP_MUL_DOUBLE_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 115);
					recog.base.enter_outer_alt(None, 115);
					{
					/*InvokeRule mulDouble2addrInstruction*/
					recog.base.set_state(2240);
					recog.mulDouble2addrInstruction()?;

					}
				}

			 OP_DIV_DOUBLE_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 116);
					recog.base.enter_outer_alt(None, 116);
					{
					/*InvokeRule divDouble2addrInstruction*/
					recog.base.set_state(2241);
					recog.divDouble2addrInstruction()?;

					}
				}

			 OP_REM_DOUBLE_2ADDR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 117);
					recog.base.enter_outer_alt(None, 117);
					{
					/*InvokeRule remDouble2addrInstruction*/
					recog.base.set_state(2242);
					recog.remDouble2addrInstruction()?;

					}
				}

			 OP_CMPL_FLOAT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 118);
					recog.base.enter_outer_alt(None, 118);
					{
					/*InvokeRule cmplFloatInstruction*/
					recog.base.set_state(2243);
					recog.cmplFloatInstruction()?;

					}
				}

			 OP_CMPG_FLOAT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 119);
					recog.base.enter_outer_alt(None, 119);
					{
					/*InvokeRule cmpgFloatInstruction*/
					recog.base.set_state(2244);
					recog.cmpgFloatInstruction()?;

					}
				}

			 OP_CMPL_DOUBLE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 120);
					recog.base.enter_outer_alt(None, 120);
					{
					/*InvokeRule cmplDoubleInstruction*/
					recog.base.set_state(2245);
					recog.cmplDoubleInstruction()?;

					}
				}

			 OP_CMPG_DOUBLE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 121);
					recog.base.enter_outer_alt(None, 121);
					{
					/*InvokeRule cmpgDoubleInstruction*/
					recog.base.set_state(2246);
					recog.cmpgDoubleInstruction()?;

					}
				}

			 OP_CMP_LONG 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 122);
					recog.base.enter_outer_alt(None, 122);
					{
					/*InvokeRule cmpLongInstruction*/
					recog.base.set_state(2247);
					recog.cmpLongInstruction()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- ternaryInstruction ----------------
pub type TernaryInstructionContextAll<'input> = TernaryInstructionContext<'input>;


pub type TernaryInstructionContext<'input> = BaseParserRuleContext<'input,TernaryInstructionContextExt<'input>>;

#[derive(Clone)]
pub struct TernaryInstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for TernaryInstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for TernaryInstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_ternaryInstruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_ternaryInstruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for TernaryInstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_ternaryInstruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_ternaryInstruction }
}
antlr_rust::tid!{TernaryInstructionContextExt<'a>}

impl<'input> TernaryInstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TernaryInstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TernaryInstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TernaryInstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<TernaryInstructionContextExt<'input>>{

fn invokePolymorphicInstruction(&self) -> Option<Rc<InvokePolymorphicInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn invokePolymorphicRangeInstruction(&self) -> Option<Rc<InvokePolymorphicRangeInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn invokeCustomInstruction(&self) -> Option<Rc<InvokeCustomInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn invokeCustomRangeInstruction(&self) -> Option<Rc<InvokeCustomRangeInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn invokeConstMethodHandleInstruction(&self) -> Option<Rc<InvokeConstMethodHandleInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn invokeConstMethodTypeInstruction(&self) -> Option<Rc<InvokeConstMethodTypeInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn instanceOfInstruction(&self) -> Option<Rc<InstanceOfInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn newArrayInstruction(&self) -> Option<Rc<NewArrayInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn agetInstruction(&self) -> Option<Rc<AgetInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn agetWideInstruction(&self) -> Option<Rc<AgetWideInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn agetObjectInstruction(&self) -> Option<Rc<AgetObjectInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn agetBooleanInstruction(&self) -> Option<Rc<AgetBooleanInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn agetByteInstruction(&self) -> Option<Rc<AgetByteInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn agetCharInstruction(&self) -> Option<Rc<AgetCharInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn agetShortInstruction(&self) -> Option<Rc<AgetShortInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn aputInstruction(&self) -> Option<Rc<AputInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn aputWideInstruction(&self) -> Option<Rc<AputWideInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn aputObjectInstruction(&self) -> Option<Rc<AputObjectInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn aputBooleanInstruction(&self) -> Option<Rc<AputBooleanInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn aputByteInstruction(&self) -> Option<Rc<AputByteInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn aputCharInstruction(&self) -> Option<Rc<AputCharInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn aputShortInstruction(&self) -> Option<Rc<AputShortInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn igetInstruction(&self) -> Option<Rc<IgetInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn igetWideInstruction(&self) -> Option<Rc<IgetWideInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn igetObjectInstruction(&self) -> Option<Rc<IgetObjectInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn igetBooleanInstruction(&self) -> Option<Rc<IgetBooleanInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn igetByteInstruction(&self) -> Option<Rc<IgetByteInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn igetCharInstruction(&self) -> Option<Rc<IgetCharInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn igetShortInstruction(&self) -> Option<Rc<IgetShortInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn iputInstruction(&self) -> Option<Rc<IputInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn iputWideInstruction(&self) -> Option<Rc<IputWideInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn iputObjectInstruction(&self) -> Option<Rc<IputObjectInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn iputBooleanInstruction(&self) -> Option<Rc<IputBooleanInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn iputByteInstruction(&self) -> Option<Rc<IputByteInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn iputCharInstruction(&self) -> Option<Rc<IputCharInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn iputShortInstruction(&self) -> Option<Rc<IputShortInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn addIntInstruction(&self) -> Option<Rc<AddIntInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn subIntInstruction(&self) -> Option<Rc<SubIntInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn mulIntInstruction(&self) -> Option<Rc<MulIntInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn divIntInstruction(&self) -> Option<Rc<DivIntInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn remIntInstruction(&self) -> Option<Rc<RemIntInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn andIntInstruction(&self) -> Option<Rc<AndIntInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn orIntInstruction(&self) -> Option<Rc<OrIntInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn xorIntInstruction(&self) -> Option<Rc<XorIntInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn shlIntInstruction(&self) -> Option<Rc<ShlIntInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn shrIntInstruction(&self) -> Option<Rc<ShrIntInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ushrIntInstruction(&self) -> Option<Rc<UshrIntInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rsubIntInstruction(&self) -> Option<Rc<RsubIntInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn addLongInstruction(&self) -> Option<Rc<AddLongInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn subLongInstruction(&self) -> Option<Rc<SubLongInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn mulLongInstruction(&self) -> Option<Rc<MulLongInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn divLongInstruction(&self) -> Option<Rc<DivLongInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn remLongInstruction(&self) -> Option<Rc<RemLongInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn andLongInstruction(&self) -> Option<Rc<AndLongInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn orLongInstruction(&self) -> Option<Rc<OrLongInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn xorLongInstruction(&self) -> Option<Rc<XorLongInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn shlLongInstruction(&self) -> Option<Rc<ShlLongInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn shrLongInstruction(&self) -> Option<Rc<ShrLongInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ushrLongInstruction(&self) -> Option<Rc<UshrLongInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn addFloatInstruction(&self) -> Option<Rc<AddFloatInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn subFloatInstruction(&self) -> Option<Rc<SubFloatInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn mulFloatInstruction(&self) -> Option<Rc<MulFloatInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn divFloatInstruction(&self) -> Option<Rc<DivFloatInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn remFloatInstruction(&self) -> Option<Rc<RemFloatInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn addDoubleInstruction(&self) -> Option<Rc<AddDoubleInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn subDoubleInstruction(&self) -> Option<Rc<SubDoubleInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn mulDoubleInstruction(&self) -> Option<Rc<MulDoubleInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn divDoubleInstruction(&self) -> Option<Rc<DivDoubleInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn remDoubleInstruction(&self) -> Option<Rc<RemDoubleInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn addIntLit16Instruction(&self) -> Option<Rc<AddIntLit16InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn mulIntLit16Instruction(&self) -> Option<Rc<MulIntLit16InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn divIntLit16Instruction(&self) -> Option<Rc<DivIntLit16InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn remIntLit16Instruction(&self) -> Option<Rc<RemIntLit16InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn andIntLit16Instruction(&self) -> Option<Rc<AndIntLit16InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn orIntLit16Instruction(&self) -> Option<Rc<OrIntLit16InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn xorIntLit16Instruction(&self) -> Option<Rc<XorIntLit16InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn addIntLit8Instruction(&self) -> Option<Rc<AddIntLit8InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rsubIntLit8Instruction(&self) -> Option<Rc<RsubIntLit8InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn mulIntLit8Instruction(&self) -> Option<Rc<MulIntLit8InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn divIntLit8Instruction(&self) -> Option<Rc<DivIntLit8InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn remIntLit8Instruction(&self) -> Option<Rc<RemIntLit8InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn andIntLit8Instruction(&self) -> Option<Rc<AndIntLit8InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn orIntLit8Instruction(&self) -> Option<Rc<OrIntLit8InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn xorIntLit8Instruction(&self) -> Option<Rc<XorIntLit8InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn shlIntLit8Instruction(&self) -> Option<Rc<ShlIntLit8InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn shrIntLit8Instruction(&self) -> Option<Rc<ShrIntLit8InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn ushrIntLit8Instruction(&self) -> Option<Rc<UshrIntLit8InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TernaryInstructionContextAttrs<'input> for TernaryInstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn ternaryInstruction(&mut self,)
	-> Result<Rc<TernaryInstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TernaryInstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 574, RULE_ternaryInstruction);
        let mut _localctx: Rc<TernaryInstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2337);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 OP_INVOKE_POLYMORPHIC 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule invokePolymorphicInstruction*/
					recog.base.set_state(2250);
					recog.invokePolymorphicInstruction()?;

					}
				}

			 OP_INVOKE_POLYMORPHIC_RANGE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule invokePolymorphicRangeInstruction*/
					recog.base.set_state(2251);
					recog.invokePolymorphicRangeInstruction()?;

					}
				}

			 OP_INVOKE_CUSTOM 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule invokeCustomInstruction*/
					recog.base.set_state(2252);
					recog.invokeCustomInstruction()?;

					}
				}

			 OP_INVOKE_CUSTOM_RANGE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule invokeCustomRangeInstruction*/
					recog.base.set_state(2253);
					recog.invokeCustomRangeInstruction()?;

					}
				}

			 OP_CONST_METHOD_HANDLE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule invokeConstMethodHandleInstruction*/
					recog.base.set_state(2254);
					recog.invokeConstMethodHandleInstruction()?;

					}
				}

			 OP_CONST_METHOD_TYPE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule invokeConstMethodTypeInstruction*/
					recog.base.set_state(2255);
					recog.invokeConstMethodTypeInstruction()?;

					}
				}

			 OP_INSTANCE_OF 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule instanceOfInstruction*/
					recog.base.set_state(2256);
					recog.instanceOfInstruction()?;

					}
				}

			 OP_NEW_ARRAY 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule newArrayInstruction*/
					recog.base.set_state(2257);
					recog.newArrayInstruction()?;

					}
				}

			 OP_AGET 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule agetInstruction*/
					recog.base.set_state(2258);
					recog.agetInstruction()?;

					}
				}

			 OP_AGET_WIDE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					/*InvokeRule agetWideInstruction*/
					recog.base.set_state(2259);
					recog.agetWideInstruction()?;

					}
				}

			 OP_AGET_OBJECT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					/*InvokeRule agetObjectInstruction*/
					recog.base.set_state(2260);
					recog.agetObjectInstruction()?;

					}
				}

			 OP_AGET_BOOLEAN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 12);
					recog.base.enter_outer_alt(None, 12);
					{
					/*InvokeRule agetBooleanInstruction*/
					recog.base.set_state(2261);
					recog.agetBooleanInstruction()?;

					}
				}

			 OP_AGET_BYTE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 13);
					recog.base.enter_outer_alt(None, 13);
					{
					/*InvokeRule agetByteInstruction*/
					recog.base.set_state(2262);
					recog.agetByteInstruction()?;

					}
				}

			 OP_AGET_CHAR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 14);
					recog.base.enter_outer_alt(None, 14);
					{
					/*InvokeRule agetCharInstruction*/
					recog.base.set_state(2263);
					recog.agetCharInstruction()?;

					}
				}

			 OP_AGET_SHORT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 15);
					recog.base.enter_outer_alt(None, 15);
					{
					/*InvokeRule agetShortInstruction*/
					recog.base.set_state(2264);
					recog.agetShortInstruction()?;

					}
				}

			 OP_APUT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 16);
					recog.base.enter_outer_alt(None, 16);
					{
					/*InvokeRule aputInstruction*/
					recog.base.set_state(2265);
					recog.aputInstruction()?;

					}
				}

			 OP_APUT_WIDE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 17);
					recog.base.enter_outer_alt(None, 17);
					{
					/*InvokeRule aputWideInstruction*/
					recog.base.set_state(2266);
					recog.aputWideInstruction()?;

					}
				}

			 OP_APUT_OBJECT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 18);
					recog.base.enter_outer_alt(None, 18);
					{
					/*InvokeRule aputObjectInstruction*/
					recog.base.set_state(2267);
					recog.aputObjectInstruction()?;

					}
				}

			 OP_APUT_BOOLEAN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 19);
					recog.base.enter_outer_alt(None, 19);
					{
					/*InvokeRule aputBooleanInstruction*/
					recog.base.set_state(2268);
					recog.aputBooleanInstruction()?;

					}
				}

			 OP_APUT_BYTE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 20);
					recog.base.enter_outer_alt(None, 20);
					{
					/*InvokeRule aputByteInstruction*/
					recog.base.set_state(2269);
					recog.aputByteInstruction()?;

					}
				}

			 OP_APUT_CHAR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 21);
					recog.base.enter_outer_alt(None, 21);
					{
					/*InvokeRule aputCharInstruction*/
					recog.base.set_state(2270);
					recog.aputCharInstruction()?;

					}
				}

			 OP_APUT_SHORT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 22);
					recog.base.enter_outer_alt(None, 22);
					{
					/*InvokeRule aputShortInstruction*/
					recog.base.set_state(2271);
					recog.aputShortInstruction()?;

					}
				}

			 OP_IGET 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 23);
					recog.base.enter_outer_alt(None, 23);
					{
					/*InvokeRule igetInstruction*/
					recog.base.set_state(2272);
					recog.igetInstruction()?;

					}
				}

			 OP_IGET_WIDE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 24);
					recog.base.enter_outer_alt(None, 24);
					{
					/*InvokeRule igetWideInstruction*/
					recog.base.set_state(2273);
					recog.igetWideInstruction()?;

					}
				}

			 OP_IGET_OBJECT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 25);
					recog.base.enter_outer_alt(None, 25);
					{
					/*InvokeRule igetObjectInstruction*/
					recog.base.set_state(2274);
					recog.igetObjectInstruction()?;

					}
				}

			 OP_IGET_BOOLEAN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 26);
					recog.base.enter_outer_alt(None, 26);
					{
					/*InvokeRule igetBooleanInstruction*/
					recog.base.set_state(2275);
					recog.igetBooleanInstruction()?;

					}
				}

			 OP_IGET_BYTE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 27);
					recog.base.enter_outer_alt(None, 27);
					{
					/*InvokeRule igetByteInstruction*/
					recog.base.set_state(2276);
					recog.igetByteInstruction()?;

					}
				}

			 OP_IGET_CHAR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 28);
					recog.base.enter_outer_alt(None, 28);
					{
					/*InvokeRule igetCharInstruction*/
					recog.base.set_state(2277);
					recog.igetCharInstruction()?;

					}
				}

			 OP_IGET_SHORT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 29);
					recog.base.enter_outer_alt(None, 29);
					{
					/*InvokeRule igetShortInstruction*/
					recog.base.set_state(2278);
					recog.igetShortInstruction()?;

					}
				}

			 OP_IPUT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 30);
					recog.base.enter_outer_alt(None, 30);
					{
					/*InvokeRule iputInstruction*/
					recog.base.set_state(2279);
					recog.iputInstruction()?;

					}
				}

			 OP_IPUT_WIDE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 31);
					recog.base.enter_outer_alt(None, 31);
					{
					/*InvokeRule iputWideInstruction*/
					recog.base.set_state(2280);
					recog.iputWideInstruction()?;

					}
				}

			 OP_IPUT_OBJECT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 32);
					recog.base.enter_outer_alt(None, 32);
					{
					/*InvokeRule iputObjectInstruction*/
					recog.base.set_state(2281);
					recog.iputObjectInstruction()?;

					}
				}

			 OP_IPUT_BOOLEAN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 33);
					recog.base.enter_outer_alt(None, 33);
					{
					/*InvokeRule iputBooleanInstruction*/
					recog.base.set_state(2282);
					recog.iputBooleanInstruction()?;

					}
				}

			 OP_IPUT_BYTE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 34);
					recog.base.enter_outer_alt(None, 34);
					{
					/*InvokeRule iputByteInstruction*/
					recog.base.set_state(2283);
					recog.iputByteInstruction()?;

					}
				}

			 OP_IPUT_CHAR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 35);
					recog.base.enter_outer_alt(None, 35);
					{
					/*InvokeRule iputCharInstruction*/
					recog.base.set_state(2284);
					recog.iputCharInstruction()?;

					}
				}

			 OP_IPUT_SHORT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 36);
					recog.base.enter_outer_alt(None, 36);
					{
					/*InvokeRule iputShortInstruction*/
					recog.base.set_state(2285);
					recog.iputShortInstruction()?;

					}
				}

			 OP_ADD_INT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 37);
					recog.base.enter_outer_alt(None, 37);
					{
					/*InvokeRule addIntInstruction*/
					recog.base.set_state(2286);
					recog.addIntInstruction()?;

					}
				}

			 OP_SUB_INT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 38);
					recog.base.enter_outer_alt(None, 38);
					{
					/*InvokeRule subIntInstruction*/
					recog.base.set_state(2287);
					recog.subIntInstruction()?;

					}
				}

			 OP_MUL_INT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 39);
					recog.base.enter_outer_alt(None, 39);
					{
					/*InvokeRule mulIntInstruction*/
					recog.base.set_state(2288);
					recog.mulIntInstruction()?;

					}
				}

			 OP_DIV_INT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 40);
					recog.base.enter_outer_alt(None, 40);
					{
					/*InvokeRule divIntInstruction*/
					recog.base.set_state(2289);
					recog.divIntInstruction()?;

					}
				}

			 OP_REM_INT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 41);
					recog.base.enter_outer_alt(None, 41);
					{
					/*InvokeRule remIntInstruction*/
					recog.base.set_state(2290);
					recog.remIntInstruction()?;

					}
				}

			 OP_AND_INT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 42);
					recog.base.enter_outer_alt(None, 42);
					{
					/*InvokeRule andIntInstruction*/
					recog.base.set_state(2291);
					recog.andIntInstruction()?;

					}
				}

			 OP_OR_INT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 43);
					recog.base.enter_outer_alt(None, 43);
					{
					/*InvokeRule orIntInstruction*/
					recog.base.set_state(2292);
					recog.orIntInstruction()?;

					}
				}

			 OP_XOR_INT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 44);
					recog.base.enter_outer_alt(None, 44);
					{
					/*InvokeRule xorIntInstruction*/
					recog.base.set_state(2293);
					recog.xorIntInstruction()?;

					}
				}

			 OP_SHL_INT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 45);
					recog.base.enter_outer_alt(None, 45);
					{
					/*InvokeRule shlIntInstruction*/
					recog.base.set_state(2294);
					recog.shlIntInstruction()?;

					}
				}

			 OP_SHR_INT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 46);
					recog.base.enter_outer_alt(None, 46);
					{
					/*InvokeRule shrIntInstruction*/
					recog.base.set_state(2295);
					recog.shrIntInstruction()?;

					}
				}

			 OP_USHR_INT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 47);
					recog.base.enter_outer_alt(None, 47);
					{
					/*InvokeRule ushrIntInstruction*/
					recog.base.set_state(2296);
					recog.ushrIntInstruction()?;

					}
				}

			 OP_RSUB_INT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 48);
					recog.base.enter_outer_alt(None, 48);
					{
					/*InvokeRule rsubIntInstruction*/
					recog.base.set_state(2297);
					recog.rsubIntInstruction()?;

					}
				}

			 OP_ADD_LONG 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 49);
					recog.base.enter_outer_alt(None, 49);
					{
					/*InvokeRule addLongInstruction*/
					recog.base.set_state(2298);
					recog.addLongInstruction()?;

					}
				}

			 OP_SUB_LONG 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 50);
					recog.base.enter_outer_alt(None, 50);
					{
					/*InvokeRule subLongInstruction*/
					recog.base.set_state(2299);
					recog.subLongInstruction()?;

					}
				}

			 OP_MUL_LONG 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 51);
					recog.base.enter_outer_alt(None, 51);
					{
					/*InvokeRule mulLongInstruction*/
					recog.base.set_state(2300);
					recog.mulLongInstruction()?;

					}
				}

			 OP_DIV_LONG 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 52);
					recog.base.enter_outer_alt(None, 52);
					{
					/*InvokeRule divLongInstruction*/
					recog.base.set_state(2301);
					recog.divLongInstruction()?;

					}
				}

			 OP_REM_LONG 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 53);
					recog.base.enter_outer_alt(None, 53);
					{
					/*InvokeRule remLongInstruction*/
					recog.base.set_state(2302);
					recog.remLongInstruction()?;

					}
				}

			 OP_AND_LONG 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 54);
					recog.base.enter_outer_alt(None, 54);
					{
					/*InvokeRule andLongInstruction*/
					recog.base.set_state(2303);
					recog.andLongInstruction()?;

					}
				}

			 OP_OR_LONG 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 55);
					recog.base.enter_outer_alt(None, 55);
					{
					/*InvokeRule orLongInstruction*/
					recog.base.set_state(2304);
					recog.orLongInstruction()?;

					}
				}

			 OP_XOR_LONG 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 56);
					recog.base.enter_outer_alt(None, 56);
					{
					/*InvokeRule xorLongInstruction*/
					recog.base.set_state(2305);
					recog.xorLongInstruction()?;

					}
				}

			 OP_SHL_LONG 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 57);
					recog.base.enter_outer_alt(None, 57);
					{
					/*InvokeRule shlLongInstruction*/
					recog.base.set_state(2306);
					recog.shlLongInstruction()?;

					}
				}

			 OP_SHR_LONG 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 58);
					recog.base.enter_outer_alt(None, 58);
					{
					/*InvokeRule shrLongInstruction*/
					recog.base.set_state(2307);
					recog.shrLongInstruction()?;

					}
				}

			 OP_USHR_LONG 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 59);
					recog.base.enter_outer_alt(None, 59);
					{
					/*InvokeRule ushrLongInstruction*/
					recog.base.set_state(2308);
					recog.ushrLongInstruction()?;

					}
				}

			 OP_ADD_FLOAT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 60);
					recog.base.enter_outer_alt(None, 60);
					{
					/*InvokeRule addFloatInstruction*/
					recog.base.set_state(2309);
					recog.addFloatInstruction()?;

					}
				}

			 OP_SUB_FLOAT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 61);
					recog.base.enter_outer_alt(None, 61);
					{
					/*InvokeRule subFloatInstruction*/
					recog.base.set_state(2310);
					recog.subFloatInstruction()?;

					}
				}

			 OP_MUL_FLOAT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 62);
					recog.base.enter_outer_alt(None, 62);
					{
					/*InvokeRule mulFloatInstruction*/
					recog.base.set_state(2311);
					recog.mulFloatInstruction()?;

					}
				}

			 OP_DIV_FLOAT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 63);
					recog.base.enter_outer_alt(None, 63);
					{
					/*InvokeRule divFloatInstruction*/
					recog.base.set_state(2312);
					recog.divFloatInstruction()?;

					}
				}

			 OP_REM_FLOAT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 64);
					recog.base.enter_outer_alt(None, 64);
					{
					/*InvokeRule remFloatInstruction*/
					recog.base.set_state(2313);
					recog.remFloatInstruction()?;

					}
				}

			 OP_ADD_DOUBLE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 65);
					recog.base.enter_outer_alt(None, 65);
					{
					/*InvokeRule addDoubleInstruction*/
					recog.base.set_state(2314);
					recog.addDoubleInstruction()?;

					}
				}

			 OP_SUB_DOUBLE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 66);
					recog.base.enter_outer_alt(None, 66);
					{
					/*InvokeRule subDoubleInstruction*/
					recog.base.set_state(2315);
					recog.subDoubleInstruction()?;

					}
				}

			 OP_MUL_DOUBLE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 67);
					recog.base.enter_outer_alt(None, 67);
					{
					/*InvokeRule mulDoubleInstruction*/
					recog.base.set_state(2316);
					recog.mulDoubleInstruction()?;

					}
				}

			 OP_DIV_DOUBLE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 68);
					recog.base.enter_outer_alt(None, 68);
					{
					/*InvokeRule divDoubleInstruction*/
					recog.base.set_state(2317);
					recog.divDoubleInstruction()?;

					}
				}

			 OP_REM_DOUBLE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 69);
					recog.base.enter_outer_alt(None, 69);
					{
					/*InvokeRule remDoubleInstruction*/
					recog.base.set_state(2318);
					recog.remDoubleInstruction()?;

					}
				}

			 OP_ADD_INT_LIT16 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 70);
					recog.base.enter_outer_alt(None, 70);
					{
					/*InvokeRule addIntLit16Instruction*/
					recog.base.set_state(2319);
					recog.addIntLit16Instruction()?;

					}
				}

			 OP_MUL_INT_LIT16 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 71);
					recog.base.enter_outer_alt(None, 71);
					{
					/*InvokeRule mulIntLit16Instruction*/
					recog.base.set_state(2320);
					recog.mulIntLit16Instruction()?;

					}
				}

			 OP_DIV_INT_LIT16 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 72);
					recog.base.enter_outer_alt(None, 72);
					{
					/*InvokeRule divIntLit16Instruction*/
					recog.base.set_state(2321);
					recog.divIntLit16Instruction()?;

					}
				}

			 OP_REM_INT_LIT16 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 73);
					recog.base.enter_outer_alt(None, 73);
					{
					/*InvokeRule remIntLit16Instruction*/
					recog.base.set_state(2322);
					recog.remIntLit16Instruction()?;

					}
				}

			 OP_AND_INT_LIT16 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 74);
					recog.base.enter_outer_alt(None, 74);
					{
					/*InvokeRule andIntLit16Instruction*/
					recog.base.set_state(2323);
					recog.andIntLit16Instruction()?;

					}
				}

			 OP_OR_INT_LIT16 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 75);
					recog.base.enter_outer_alt(None, 75);
					{
					/*InvokeRule orIntLit16Instruction*/
					recog.base.set_state(2324);
					recog.orIntLit16Instruction()?;

					}
				}

			 OP_XOR_INT_LIT16 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 76);
					recog.base.enter_outer_alt(None, 76);
					{
					/*InvokeRule xorIntLit16Instruction*/
					recog.base.set_state(2325);
					recog.xorIntLit16Instruction()?;

					}
				}

			 OP_ADD_INT_LIT8 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 77);
					recog.base.enter_outer_alt(None, 77);
					{
					/*InvokeRule addIntLit8Instruction*/
					recog.base.set_state(2326);
					recog.addIntLit8Instruction()?;

					}
				}

			 OP_RSUB_INT_LIT8 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 78);
					recog.base.enter_outer_alt(None, 78);
					{
					/*InvokeRule rsubIntLit8Instruction*/
					recog.base.set_state(2327);
					recog.rsubIntLit8Instruction()?;

					}
				}

			 OP_MUL_INT_LIT8 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 79);
					recog.base.enter_outer_alt(None, 79);
					{
					/*InvokeRule mulIntLit8Instruction*/
					recog.base.set_state(2328);
					recog.mulIntLit8Instruction()?;

					}
				}

			 OP_DIV_INT_LIT8 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 80);
					recog.base.enter_outer_alt(None, 80);
					{
					/*InvokeRule divIntLit8Instruction*/
					recog.base.set_state(2329);
					recog.divIntLit8Instruction()?;

					}
				}

			 OP_REM_INT_LIT8 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 81);
					recog.base.enter_outer_alt(None, 81);
					{
					/*InvokeRule remIntLit8Instruction*/
					recog.base.set_state(2330);
					recog.remIntLit8Instruction()?;

					}
				}

			 OP_AND_INT_LIT8 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 82);
					recog.base.enter_outer_alt(None, 82);
					{
					/*InvokeRule andIntLit8Instruction*/
					recog.base.set_state(2331);
					recog.andIntLit8Instruction()?;

					}
				}

			 OP_OR_INT_LIT8 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 83);
					recog.base.enter_outer_alt(None, 83);
					{
					/*InvokeRule orIntLit8Instruction*/
					recog.base.set_state(2332);
					recog.orIntLit8Instruction()?;

					}
				}

			 OP_XOR_INT_LIT8 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 84);
					recog.base.enter_outer_alt(None, 84);
					{
					/*InvokeRule xorIntLit8Instruction*/
					recog.base.set_state(2333);
					recog.xorIntLit8Instruction()?;

					}
				}

			 OP_SHL_INT_LIT8 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 85);
					recog.base.enter_outer_alt(None, 85);
					{
					/*InvokeRule shlIntLit8Instruction*/
					recog.base.set_state(2334);
					recog.shlIntLit8Instruction()?;

					}
				}

			 OP_SHR_INT_LIT8 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 86);
					recog.base.enter_outer_alt(None, 86);
					{
					/*InvokeRule shrIntLit8Instruction*/
					recog.base.set_state(2335);
					recog.shrIntLit8Instruction()?;

					}
				}

			 OP_USHR_INT_LIT8 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 87);
					recog.base.enter_outer_alt(None, 87);
					{
					/*InvokeRule ushrIntLit8Instruction*/
					recog.base.set_state(2336);
					recog.ushrIntLit8Instruction()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- instruction ----------------
pub type InstructionContextAll<'input> = InstructionContext<'input>;


pub type InstructionContext<'input> = BaseParserRuleContext<'input,InstructionContextExt<'input>>;

#[derive(Clone)]
pub struct InstructionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for InstructionContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for InstructionContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_instruction(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_instruction(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for InstructionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_instruction }
	//fn type_rule_index() -> usize where Self: Sized { RULE_instruction }
}
antlr_rust::tid!{InstructionContextExt<'a>}

impl<'input> InstructionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InstructionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InstructionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InstructionContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<InstructionContextExt<'input>>{

fn ternaryInstruction(&self) -> Option<Rc<TernaryInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn binaryInstruction(&self) -> Option<Rc<BinaryInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn returnVoidInstruction(&self) -> Option<Rc<ReturnVoidInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn nopInstruction(&self) -> Option<Rc<NopInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn gotoInstruction(&self) -> Option<Rc<GotoInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn goto16Instruction(&self) -> Option<Rc<Goto16InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn goto32Instruction(&self) -> Option<Rc<Goto32InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn moveResultInstruction(&self) -> Option<Rc<MoveResultInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn moveResultWideInstruction(&self) -> Option<Rc<MoveResultWideInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn moveResultObjectInstruction(&self) -> Option<Rc<MoveResultObjectInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn moveExceptionInstruction(&self) -> Option<Rc<MoveExceptionInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn returnInstruction(&self) -> Option<Rc<ReturnInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn returnWideInstruction(&self) -> Option<Rc<ReturnWideInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn returnObjectInstruction(&self) -> Option<Rc<ReturnObjectInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn monitorEnterInstruction(&self) -> Option<Rc<MonitorEnterInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn monitorExitInstruction(&self) -> Option<Rc<MonitorExitInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn throwInstruction(&self) -> Option<Rc<ThrowInstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> InstructionContextAttrs<'input> for InstructionContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn instruction(&mut self,)
	-> Result<Rc<InstructionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InstructionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 576, RULE_instruction);
        let mut _localctx: Rc<InstructionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2356);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 OP_INSTANCE_OF | OP_NEW_ARRAY | OP_AGET | OP_AGET_WIDE | OP_AGET_OBJECT |
			 OP_AGET_BOOLEAN | OP_AGET_BYTE | OP_AGET_CHAR | OP_AGET_SHORT | OP_APUT |
			 OP_APUT_WIDE | OP_APUT_OBJECT | OP_APUT_BOOLEAN | OP_APUT_BYTE | OP_APUT_CHAR |
			 OP_APUT_SHORT | OP_IGET | OP_IGET_WIDE | OP_IGET_OBJECT | OP_IGET_BOOLEAN |
			 OP_IGET_BYTE | OP_IGET_CHAR | OP_IGET_SHORT | OP_IPUT | OP_IPUT_WIDE |
			 OP_IPUT_OBJECT | OP_IPUT_BOOLEAN | OP_IPUT_BYTE | OP_IPUT_CHAR | OP_IPUT_SHORT |
			 OP_ADD_INT | OP_SUB_INT | OP_MUL_INT | OP_DIV_INT | OP_REM_INT | OP_AND_INT |
			 OP_OR_INT | OP_XOR_INT | OP_SHL_INT | OP_SHR_INT | OP_USHR_INT | OP_ADD_LONG |
			 OP_SUB_LONG | OP_MUL_LONG | OP_DIV_LONG | OP_REM_LONG | OP_AND_LONG |
			 OP_OR_LONG | OP_XOR_LONG | OP_SHL_LONG | OP_SHR_LONG | OP_USHR_LONG |
			 OP_ADD_FLOAT | OP_SUB_FLOAT | OP_MUL_FLOAT | OP_DIV_FLOAT | OP_REM_FLOAT |
			 OP_ADD_DOUBLE | OP_SUB_DOUBLE | OP_MUL_DOUBLE | OP_DIV_DOUBLE | OP_REM_DOUBLE |
			 OP_ADD_INT_LIT16 | OP_RSUB_INT | OP_MUL_INT_LIT16 | OP_DIV_INT_LIT16 |
			 OP_REM_INT_LIT16 | OP_AND_INT_LIT16 | OP_OR_INT_LIT16 | OP_XOR_INT_LIT16 |
			 OP_ADD_INT_LIT8 | OP_RSUB_INT_LIT8 | OP_MUL_INT_LIT8 | OP_DIV_INT_LIT8 |
			 OP_REM_INT_LIT8 | OP_AND_INT_LIT8 | OP_OR_INT_LIT8 | OP_XOR_INT_LIT8 |
			 OP_SHL_INT_LIT8 | OP_SHR_INT_LIT8 | OP_USHR_INT_LIT8 | OP_INVOKE_POLYMORPHIC |
			 OP_INVOKE_POLYMORPHIC_RANGE | OP_INVOKE_CUSTOM | OP_INVOKE_CUSTOM_RANGE |
			 OP_CONST_METHOD_HANDLE | OP_CONST_METHOD_TYPE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule ternaryInstruction*/
					recog.base.set_state(2339);
					recog.ternaryInstruction()?;

					}
				}

			 OP_MOVE | OP_MOVE_FROM16 | OP_MOVE_16 | OP_MOVE_WIDE | OP_MOVE_WIDE_FROM16 |
			 OP_MOVE_WIDE_16 | OP_MOVE_OBJECT | OP_MOVE_OBJECT_FROM16 | OP_MOVE_OBJECT_16 |
			 OP_CONST_4 | OP_CONST_16 | OP_CONST | OP_CONST_HIGH16 | OP_CONST_WIDE_16 |
			 OP_CONST_WIDE_32 | OP_CONST_WIDE | OP_CONST_WIDE_HIGH16 | OP_CONST_STRING |
			 OP_CONST_STRING_JUMBO | OP_CONST_CLASS | OP_CHECK_CAST | OP_ARRAY_LENGTH |
			 OP_NEW_INSTANCE | OP_FILLED_NEW_ARRAY | OP_FILLED_NEW_ARRAY_RANGE | OP_FILL_ARRAY_DATA |
			 OP_CMPL_FLOAT | OP_CMPG_FLOAT | OP_CMPL_DOUBLE | OP_CMPG_DOUBLE | OP_CMP_LONG |
			 OP_IF_EQ | OP_IF_NE | OP_IF_LT | OP_IF_GE | OP_IF_GT | OP_IF_LE | OP_IF_EQZ |
			 OP_IF_NEZ | OP_IF_LTZ | OP_IF_GEZ | OP_IF_GTZ | OP_IF_LEZ | OP_SGET |
			 OP_SGET_WIDE | OP_SGET_OBJECT | OP_SGET_BOOLEAN | OP_SGET_BYTE | OP_SGET_CHAR |
			 OP_SGET_SHORT | OP_SPUT | OP_SPUT_WIDE | OP_SPUT_OBJECT | OP_SPUT_BOOLEAN |
			 OP_SPUT_BYTE | OP_SPUT_CHAR | OP_SPUT_SHORT | OP_INVOKE_VIRTUAL | OP_INVOKE_SUPER |
			 OP_INVOKE_DIRECT | OP_INVOKE_STATIC | OP_INVOKE_INTERFACE | OP_INVOKE_VIRTUAL_RANGE |
			 OP_INVOKE_SUPER_RANGE | OP_INVOKE_DIRECT_RANGE | OP_INVOKE_STATIC_RANGE |
			 OP_INVOKE_INTERFACE_RANGE | OP_NEG_INT | OP_NOT_INT | OP_NEG_LONG | OP_NOT_LONG |
			 OP_NEG_FLOAT | OP_NEG_DOUBLE | OP_INT_TO_LONG | OP_INT_TO_FLOAT | OP_INT_TO_DOUBLE |
			 OP_LONG_TO_INT | OP_LONG_TO_FLOAT | OP_LONG_TO_DOUBLE | OP_FLOAT_TO_INT |
			 OP_FLOAT_TO_LONG | OP_FLOAT_TO_DOUBLE | OP_DOUBLE_TO_INT | OP_DOUBLE_TO_LONG |
			 OP_DOUBLE_TO_FLOAT | OP_INT_TO_BYTE | OP_INT_TO_CHAR | OP_INT_TO_SHORT |
			 OP_ADD_INT_2ADDR | OP_SUB_INT_2ADDR | OP_MUL_INT_2ADDR | OP_DIV_INT_2ADDR |
			 OP_REM_INT_2ADDR | OP_AND_INT_2ADDR | OP_OR_INT_2ADDR | OP_XOR_INT_2ADDR |
			 OP_SHL_INT_2ADDR | OP_SHR_INT_2ADDR | OP_USHR_INT_2ADDR | OP_ADD_LONG_2ADDR |
			 OP_SUB_LONG_2ADDR | OP_MUL_LONG_2ADDR | OP_DIV_LONG_2ADDR | OP_REM_LONG_2ADDR |
			 OP_AND_LONG_2ADDR | OP_OR_LONG_2ADDR | OP_XOR_LONG_2ADDR | OP_SHL_LONG_2ADDR |
			 OP_SHR_LONG_2ADDR | OP_USHR_LONG_2ADDR | OP_ADD_FLOAT_2ADDR | OP_SUB_FLOAT_2ADDR |
			 OP_MUL_FLOAT_2ADDR | OP_DIV_FLOAT_2ADDR | OP_REM_FLOAT_2ADDR | OP_ADD_DOUBLE_2ADDR |
			 OP_SUB_DOUBLE_2ADDR | OP_MUL_DOUBLE_2ADDR | OP_DIV_DOUBLE_2ADDR | OP_REM_DOUBLE_2ADDR |
			 OP_PACKED_SWITCH | OP_SPARSE_SWITCH 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule binaryInstruction*/
					recog.base.set_state(2340);
					recog.binaryInstruction()?;

					}
				}

			 OP_RETURN_VOID 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule returnVoidInstruction*/
					recog.base.set_state(2341);
					recog.returnVoidInstruction()?;

					}
				}

			 OP_NOP 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule nopInstruction*/
					recog.base.set_state(2342);
					recog.nopInstruction()?;

					}
				}

			 OP_GOTO 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule gotoInstruction*/
					recog.base.set_state(2343);
					recog.gotoInstruction()?;

					}
				}

			 OP_GOTO_16 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule goto16Instruction*/
					recog.base.set_state(2344);
					recog.goto16Instruction()?;

					}
				}

			 OP_GOTO_32 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule goto32Instruction*/
					recog.base.set_state(2345);
					recog.goto32Instruction()?;

					}
				}

			 OP_MOVE_RESULT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule moveResultInstruction*/
					recog.base.set_state(2346);
					recog.moveResultInstruction()?;

					}
				}

			 OP_MOVE_RESULT_WIDE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule moveResultWideInstruction*/
					recog.base.set_state(2347);
					recog.moveResultWideInstruction()?;

					}
				}

			 OP_MOVE_RESULT_OBJECT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					/*InvokeRule moveResultObjectInstruction*/
					recog.base.set_state(2348);
					recog.moveResultObjectInstruction()?;

					}
				}

			 OP_MOVE_EXCEPTION 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					/*InvokeRule moveExceptionInstruction*/
					recog.base.set_state(2349);
					recog.moveExceptionInstruction()?;

					}
				}

			 OP_RETURN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 12);
					recog.base.enter_outer_alt(None, 12);
					{
					/*InvokeRule returnInstruction*/
					recog.base.set_state(2350);
					recog.returnInstruction()?;

					}
				}

			 OP_RETURN_WIDE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 13);
					recog.base.enter_outer_alt(None, 13);
					{
					/*InvokeRule returnWideInstruction*/
					recog.base.set_state(2351);
					recog.returnWideInstruction()?;

					}
				}

			 OP_RETURN_OBJECT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 14);
					recog.base.enter_outer_alt(None, 14);
					{
					/*InvokeRule returnObjectInstruction*/
					recog.base.set_state(2352);
					recog.returnObjectInstruction()?;

					}
				}

			 OP_MONITOR_ENTER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 15);
					recog.base.enter_outer_alt(None, 15);
					{
					/*InvokeRule monitorEnterInstruction*/
					recog.base.set_state(2353);
					recog.monitorEnterInstruction()?;

					}
				}

			 OP_MONITOR_EXIT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 16);
					recog.base.enter_outer_alt(None, 16);
					{
					/*InvokeRule monitorExitInstruction*/
					recog.base.set_state(2354);
					recog.monitorExitInstruction()?;

					}
				}

			 OP_THROW 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 17);
					recog.base.enter_outer_alt(None, 17);
					{
					/*InvokeRule throwInstruction*/
					recog.base.set_state(2355);
					recog.throwInstruction()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodInvocationTarget ----------------
pub type MethodInvocationTargetContextAll<'input> = MethodInvocationTargetContext<'input>;


pub type MethodInvocationTargetContext<'input> = BaseParserRuleContext<'input,MethodInvocationTargetContextExt<'input>>;

#[derive(Clone)]
pub struct MethodInvocationTargetContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MethodInvocationTargetContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MethodInvocationTargetContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodInvocationTarget(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_methodInvocationTarget(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodInvocationTargetContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodInvocationTarget }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodInvocationTarget }
}
antlr_rust::tid!{MethodInvocationTargetContextExt<'a>}

impl<'input> MethodInvocationTargetContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodInvocationTargetContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodInvocationTargetContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodInvocationTargetContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MethodInvocationTargetContextExt<'input>>{

fn referenceOrArrayType(&self) -> Option<Rc<ReferenceOrArrayTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ARROW
/// Returns `None` if there is no child corresponding to token ARROW
fn ARROW(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(ARROW, 0)
}
fn methodSignature(&self) -> Option<Rc<MethodSignatureContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MethodInvocationTargetContextAttrs<'input> for MethodInvocationTargetContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodInvocationTarget(&mut self,)
	-> Result<Rc<MethodInvocationTargetContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodInvocationTargetContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 578, RULE_methodInvocationTarget);
        let mut _localctx: Rc<MethodInvocationTargetContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule referenceOrArrayType*/
			recog.base.set_state(2358);
			recog.referenceOrArrayType()?;

			recog.base.set_state(2359);
			recog.base.match_token(ARROW,&mut recog.err_handler)?;

			/*InvokeRule methodSignature*/
			recog.base.set_state(2360);
			recog.methodSignature()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fieldInvocationTarget ----------------
pub type FieldInvocationTargetContextAll<'input> = FieldInvocationTargetContext<'input>;


pub type FieldInvocationTargetContext<'input> = BaseParserRuleContext<'input,FieldInvocationTargetContextExt<'input>>;

#[derive(Clone)]
pub struct FieldInvocationTargetContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for FieldInvocationTargetContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for FieldInvocationTargetContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_fieldInvocationTarget(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_fieldInvocationTarget(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FieldInvocationTargetContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fieldInvocationTarget }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fieldInvocationTarget }
}
antlr_rust::tid!{FieldInvocationTargetContextExt<'a>}

impl<'input> FieldInvocationTargetContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FieldInvocationTargetContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FieldInvocationTargetContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FieldInvocationTargetContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<FieldInvocationTargetContextExt<'input>>{

fn referenceOrArrayType(&self) -> Option<Rc<ReferenceOrArrayTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ARROW
/// Returns `None` if there is no child corresponding to token ARROW
fn ARROW(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(ARROW, 0)
}
fn fieldNameAndType(&self) -> Option<Rc<FieldNameAndTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FieldInvocationTargetContextAttrs<'input> for FieldInvocationTargetContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fieldInvocationTarget(&mut self,)
	-> Result<Rc<FieldInvocationTargetContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FieldInvocationTargetContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 580, RULE_fieldInvocationTarget);
        let mut _localctx: Rc<FieldInvocationTargetContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule referenceOrArrayType*/
			recog.base.set_state(2362);
			recog.referenceOrArrayType()?;

			recog.base.set_state(2363);
			recog.base.match_token(ARROW,&mut recog.err_handler)?;

			/*InvokeRule fieldNameAndType*/
			recog.base.set_state(2364);
			recog.fieldNameAndType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fieldName ----------------
pub type FieldNameContextAll<'input> = FieldNameContext<'input>;


pub type FieldNameContext<'input> = BaseParserRuleContext<'input,FieldNameContextExt<'input>>;

#[derive(Clone)]
pub struct FieldNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for FieldNameContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for FieldNameContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_fieldName(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_fieldName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FieldNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fieldName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fieldName }
}
antlr_rust::tid!{FieldNameContextExt<'a>}

impl<'input> FieldNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FieldNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FieldNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FieldNameContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<FieldNameContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FieldNameContextAttrs<'input> for FieldNameContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fieldName(&mut self,)
	-> Result<Rc<FieldNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FieldNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 582, RULE_fieldName);
        let mut _localctx: Rc<FieldNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(2366);
			recog.identifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fieldType ----------------
pub type FieldTypeContextAll<'input> = FieldTypeContext<'input>;


pub type FieldTypeContext<'input> = BaseParserRuleContext<'input,FieldTypeContextExt<'input>>;

#[derive(Clone)]
pub struct FieldTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for FieldTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for FieldTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_fieldType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_fieldType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FieldTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fieldType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fieldType }
}
antlr_rust::tid!{FieldTypeContextExt<'a>}

impl<'input> FieldTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FieldTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FieldTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FieldTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<FieldTypeContextExt<'input>>{

fn anyType(&self) -> Option<Rc<AnyTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FieldTypeContextAttrs<'input> for FieldTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fieldType(&mut self,)
	-> Result<Rc<FieldTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FieldTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 584, RULE_fieldType);
        let mut _localctx: Rc<FieldTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule anyType*/
			recog.base.set_state(2368);
			recog.anyType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fieldNameAndType ----------------
pub type FieldNameAndTypeContextAll<'input> = FieldNameAndTypeContext<'input>;


pub type FieldNameAndTypeContext<'input> = BaseParserRuleContext<'input,FieldNameAndTypeContextExt<'input>>;

#[derive(Clone)]
pub struct FieldNameAndTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for FieldNameAndTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for FieldNameAndTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_fieldNameAndType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_fieldNameAndType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FieldNameAndTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fieldNameAndType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fieldNameAndType }
}
antlr_rust::tid!{FieldNameAndTypeContextExt<'a>}

impl<'input> FieldNameAndTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FieldNameAndTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FieldNameAndTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FieldNameAndTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<FieldNameAndTypeContextExt<'input>>{

fn fieldName(&self) -> Option<Rc<FieldNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn fieldType(&self) -> Option<Rc<FieldTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FieldNameAndTypeContextAttrs<'input> for FieldNameAndTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fieldNameAndType(&mut self,)
	-> Result<Rc<FieldNameAndTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FieldNameAndTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 586, RULE_fieldNameAndType);
        let mut _localctx: Rc<FieldNameAndTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule fieldName*/
			recog.base.set_state(2370);
			recog.fieldName()?;

			recog.base.set_state(2371);
			recog.base.match_token(COLON,&mut recog.err_handler)?;

			/*InvokeRule fieldType*/
			recog.base.set_state(2372);
			recog.fieldType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fieldDirective ----------------
pub type FieldDirectiveContextAll<'input> = FieldDirectiveContext<'input>;


pub type FieldDirectiveContext<'input> = BaseParserRuleContext<'input,FieldDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct FieldDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for FieldDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for FieldDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_fieldDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_fieldDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for FieldDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fieldDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fieldDirective }
}
antlr_rust::tid!{FieldDirectiveContextExt<'a>}

impl<'input> FieldDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FieldDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FieldDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FieldDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<FieldDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FIELD_DIRECTIVE
/// Returns `None` if there is no child corresponding to token FIELD_DIRECTIVE
fn FIELD_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(FIELD_DIRECTIVE, 0)
}
fn fieldNameAndType(&self) -> Option<Rc<FieldNameAndTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn fieldModifier_all(&self) ->  Vec<Rc<FieldModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn fieldModifier(&self, i: usize) -> Option<Rc<FieldModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token ASSIGN
/// Returns `None` if there is no child corresponding to token ASSIGN
fn ASSIGN(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(ASSIGN, 0)
}
fn assignableValue(&self) -> Option<Rc<AssignableValueContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FieldDirectiveContextAttrs<'input> for FieldDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fieldDirective(&mut self,)
	-> Result<Rc<FieldDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FieldDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 588, RULE_fieldDirective);
        let mut _localctx: Rc<FieldDirectiveContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2374);
			recog.base.match_token(FIELD_DIRECTIVE,&mut recog.err_handler)?;

			recog.base.set_state(2378);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(15,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule fieldModifier*/
					recog.base.set_state(2375);
					recog.fieldModifier()?;

					}
					} 
				}
				recog.base.set_state(2380);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(15,&mut recog.base)?;
			}
			/*InvokeRule fieldNameAndType*/
			recog.base.set_state(2381);
			recog.fieldNameAndType()?;

			recog.base.set_state(2384);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==ASSIGN {
				{
				recog.base.set_state(2382);
				recog.base.match_token(ASSIGN,&mut recog.err_handler)?;

				/*InvokeRule assignableValue*/
				recog.base.set_state(2383);
				recog.assignableValue()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- className ----------------
pub type ClassNameContextAll<'input> = ClassNameContext<'input>;


pub type ClassNameContext<'input> = BaseParserRuleContext<'input,ClassNameContextExt<'input>>;

#[derive(Clone)]
pub struct ClassNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ClassNameContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ClassNameContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_className(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_className(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_className }
	//fn type_rule_index() -> usize where Self: Sized { RULE_className }
}
antlr_rust::tid!{ClassNameContextExt<'a>}

impl<'input> ClassNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassNameContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ClassNameContextExt<'input>>{

fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ClassNameContextAttrs<'input> for ClassNameContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn className(&mut self,)
	-> Result<Rc<ClassNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 590, RULE_className);
        let mut _localctx: Rc<ClassNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule referenceType*/
			recog.base.set_state(2386);
			recog.referenceType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- classDirective ----------------
pub type ClassDirectiveContextAll<'input> = ClassDirectiveContext<'input>;


pub type ClassDirectiveContext<'input> = BaseParserRuleContext<'input,ClassDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct ClassDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ClassDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ClassDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_classDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_classDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ClassDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_classDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_classDirective }
}
antlr_rust::tid!{ClassDirectiveContextExt<'a>}

impl<'input> ClassDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ClassDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ClassDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ClassDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ClassDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CLASS_DIRECTIVE
/// Returns `None` if there is no child corresponding to token CLASS_DIRECTIVE
fn CLASS_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(CLASS_DIRECTIVE, 0)
}
fn className(&self) -> Option<Rc<ClassNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn classModifier_all(&self) ->  Vec<Rc<ClassModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn classModifier(&self, i: usize) -> Option<Rc<ClassModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ClassDirectiveContextAttrs<'input> for ClassDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn classDirective(&mut self,)
	-> Result<Rc<ClassDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ClassDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 592, RULE_classDirective);
        let mut _localctx: Rc<ClassDirectiveContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2388);
			recog.base.match_token(CLASS_DIRECTIVE,&mut recog.err_handler)?;

			recog.base.set_state(2392);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while ((((_la - 52)) & !0x3f) == 0 && ((1usize << (_la - 52)) & ((1usize << (PUBLIC - 52)) | (1usize << (PRIVATE - 52)) | (1usize << (PROTECTED - 52)) | (1usize << (FINAL - 52)) | (1usize << (ANNOTATION - 52)) | (1usize << (STATIC - 52)) | (1usize << (SYNTHETIC - 52)) | (1usize << (ABSTRACT - 52)) | (1usize << (ENUM - 52)) | (1usize << (INTERFACE - 52)))) != 0) {
				{
				{
				/*InvokeRule classModifier*/
				recog.base.set_state(2389);
				recog.classModifier()?;

				}
				}
				recog.base.set_state(2394);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			/*InvokeRule className*/
			recog.base.set_state(2395);
			recog.className()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- superName ----------------
pub type SuperNameContextAll<'input> = SuperNameContext<'input>;


pub type SuperNameContext<'input> = BaseParserRuleContext<'input,SuperNameContextExt<'input>>;

#[derive(Clone)]
pub struct SuperNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SuperNameContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SuperNameContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_superName(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_superName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SuperNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_superName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_superName }
}
antlr_rust::tid!{SuperNameContextExt<'a>}

impl<'input> SuperNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SuperNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SuperNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SuperNameContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SuperNameContextExt<'input>>{

fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SuperNameContextAttrs<'input> for SuperNameContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn superName(&mut self,)
	-> Result<Rc<SuperNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SuperNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 594, RULE_superName);
        let mut _localctx: Rc<SuperNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule referenceType*/
			recog.base.set_state(2397);
			recog.referenceType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- superDirective ----------------
pub type SuperDirectiveContextAll<'input> = SuperDirectiveContext<'input>;


pub type SuperDirectiveContext<'input> = BaseParserRuleContext<'input,SuperDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct SuperDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SuperDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SuperDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_superDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_superDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SuperDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_superDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_superDirective }
}
antlr_rust::tid!{SuperDirectiveContextExt<'a>}

impl<'input> SuperDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SuperDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SuperDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SuperDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SuperDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SUPER_DIRECTIVE
/// Returns `None` if there is no child corresponding to token SUPER_DIRECTIVE
fn SUPER_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(SUPER_DIRECTIVE, 0)
}
fn superName(&self) -> Option<Rc<SuperNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SuperDirectiveContextAttrs<'input> for SuperDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn superDirective(&mut self,)
	-> Result<Rc<SuperDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SuperDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 596, RULE_superDirective);
        let mut _localctx: Rc<SuperDirectiveContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2399);
			recog.base.match_token(SUPER_DIRECTIVE,&mut recog.err_handler)?;

			/*InvokeRule superName*/
			recog.base.set_state(2400);
			recog.superName()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sourceName ----------------
pub type SourceNameContextAll<'input> = SourceNameContext<'input>;


pub type SourceNameContext<'input> = BaseParserRuleContext<'input,SourceNameContextExt<'input>>;

#[derive(Clone)]
pub struct SourceNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SourceNameContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SourceNameContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sourceName(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sourceName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SourceNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sourceName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sourceName }
}
antlr_rust::tid!{SourceNameContextExt<'a>}

impl<'input> SourceNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SourceNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SourceNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SourceNameContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SourceNameContextExt<'input>>{

fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SourceNameContextAttrs<'input> for SourceNameContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sourceName(&mut self,)
	-> Result<Rc<SourceNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SourceNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 598, RULE_sourceName);
        let mut _localctx: Rc<SourceNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule stringLiteral*/
			recog.base.set_state(2402);
			recog.stringLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sourceDirective ----------------
pub type SourceDirectiveContextAll<'input> = SourceDirectiveContext<'input>;


pub type SourceDirectiveContext<'input> = BaseParserRuleContext<'input,SourceDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct SourceDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SourceDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SourceDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sourceDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sourceDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SourceDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sourceDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sourceDirective }
}
antlr_rust::tid!{SourceDirectiveContextExt<'a>}

impl<'input> SourceDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SourceDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SourceDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SourceDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SourceDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SOURCE_DIRECTIVE
/// Returns `None` if there is no child corresponding to token SOURCE_DIRECTIVE
fn SOURCE_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(SOURCE_DIRECTIVE, 0)
}
fn sourceName(&self) -> Option<Rc<SourceNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SourceDirectiveContextAttrs<'input> for SourceDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sourceDirective(&mut self,)
	-> Result<Rc<SourceDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SourceDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 600, RULE_sourceDirective);
        let mut _localctx: Rc<SourceDirectiveContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2404);
			recog.base.match_token(SOURCE_DIRECTIVE,&mut recog.err_handler)?;

			/*InvokeRule sourceName*/
			recog.base.set_state(2405);
			recog.sourceName()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodIdentifier ----------------
pub type MethodIdentifierContextAll<'input> = MethodIdentifierContext<'input>;


pub type MethodIdentifierContext<'input> = BaseParserRuleContext<'input,MethodIdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct MethodIdentifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MethodIdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MethodIdentifierContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodIdentifier(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_methodIdentifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodIdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodIdentifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodIdentifier }
}
antlr_rust::tid!{MethodIdentifierContextExt<'a>}

impl<'input> MethodIdentifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodIdentifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodIdentifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodIdentifierContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MethodIdentifierContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LT
/// Returns `None` if there is no child corresponding to token LT
fn LT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(LT, 0)
}
/// Retrieves first TerminalNode corresponding to token GT
/// Returns `None` if there is no child corresponding to token GT
fn GT(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(GT, 0)
}

}

impl<'input> MethodIdentifierContextAttrs<'input> for MethodIdentifierContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodIdentifier(&mut self,)
	-> Result<Rc<MethodIdentifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodIdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 602, RULE_methodIdentifier);
        let mut _localctx: Rc<MethodIdentifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2412);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 VOID_TYPE | BOOLEAN_TYPE | BYTE_TYPE | SHORT_TYPE | CHAR_TYPE | INT_TYPE |
			 LONG_TYPE | FLOAT_TYPE | DOUBLE_TYPE | ANNOTATION | SYNTHETIC | CONSTRUCTOR |
			 BRIDGE | VARARGS | NATIVE | IDENTIFIER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule identifier*/
					recog.base.set_state(2407);
					recog.identifier()?;

					}
				}

			 LT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2408);
					recog.base.match_token(LT,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(2409);
					recog.identifier()?;

					recog.base.set_state(2410);
					recog.base.match_token(GT,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodReturnType ----------------
pub type MethodReturnTypeContextAll<'input> = MethodReturnTypeContext<'input>;


pub type MethodReturnTypeContext<'input> = BaseParserRuleContext<'input,MethodReturnTypeContextExt<'input>>;

#[derive(Clone)]
pub struct MethodReturnTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MethodReturnTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MethodReturnTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodReturnType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_methodReturnType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodReturnTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodReturnType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodReturnType }
}
antlr_rust::tid!{MethodReturnTypeContextExt<'a>}

impl<'input> MethodReturnTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodReturnTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodReturnTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodReturnTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MethodReturnTypeContextExt<'input>>{

fn anyType(&self) -> Option<Rc<AnyTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MethodReturnTypeContextAttrs<'input> for MethodReturnTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodReturnType(&mut self,)
	-> Result<Rc<MethodReturnTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodReturnTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 604, RULE_methodReturnType);
        let mut _localctx: Rc<MethodReturnTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule anyType*/
			recog.base.set_state(2414);
			recog.anyType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodParameterType ----------------
pub type MethodParameterTypeContextAll<'input> = MethodParameterTypeContext<'input>;


pub type MethodParameterTypeContext<'input> = BaseParserRuleContext<'input,MethodParameterTypeContextExt<'input>>;

#[derive(Clone)]
pub struct MethodParameterTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MethodParameterTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MethodParameterTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodParameterType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_methodParameterType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodParameterTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodParameterType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodParameterType }
}
antlr_rust::tid!{MethodParameterTypeContextExt<'a>}

impl<'input> MethodParameterTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodParameterTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodParameterTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodParameterTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MethodParameterTypeContextExt<'input>>{

fn nonVoidType(&self) -> Option<Rc<NonVoidTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodParameterLiteral(&self) -> Option<Rc<MethodParameterLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MethodParameterTypeContextAttrs<'input> for MethodParameterTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodParameterType(&mut self,)
	-> Result<Rc<MethodParameterTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodParameterTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 606, RULE_methodParameterType);
        let mut _localctx: Rc<MethodParameterTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2418);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 QUALIFIED_TYPE_NAME | BOOLEAN_TYPE | BYTE_TYPE | SHORT_TYPE | CHAR_TYPE |
			 INT_TYPE | LONG_TYPE | FLOAT_TYPE | DOUBLE_TYPE | LBRACK 
				=> {
					{
					/*InvokeRule nonVoidType*/
					recog.base.set_state(2416);
					recog.nonVoidType()?;

					}
				}

			 COMPOUND_METHOD_ARG_LITERAL | IDENTIFIER 
				=> {
					{
					/*InvokeRule methodParameterLiteral*/
					recog.base.set_state(2417);
					recog.methodParameterLiteral()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodArguments ----------------
pub type MethodArgumentsContextAll<'input> = MethodArgumentsContext<'input>;


pub type MethodArgumentsContext<'input> = BaseParserRuleContext<'input,MethodArgumentsContextExt<'input>>;

#[derive(Clone)]
pub struct MethodArgumentsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MethodArgumentsContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MethodArgumentsContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodArguments(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_methodArguments(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodArgumentsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodArguments }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodArguments }
}
antlr_rust::tid!{MethodArgumentsContextExt<'a>}

impl<'input> MethodArgumentsContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodArgumentsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodArgumentsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodArgumentsContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MethodArgumentsContextExt<'input>>{

fn methodParameterType_all(&self) ->  Vec<Rc<MethodParameterTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn methodParameterType(&self, i: usize) -> Option<Rc<MethodParameterTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> MethodArgumentsContextAttrs<'input> for MethodArgumentsContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodArguments(&mut self,)
	-> Result<Rc<MethodArgumentsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodArgumentsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 608, RULE_methodArguments);
        let mut _localctx: Rc<MethodArgumentsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2421); 
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			loop {
				{
				{
				/*InvokeRule methodParameterType*/
				recog.base.set_state(2420);
				recog.methodParameterType()?;

				}
				}
				recog.base.set_state(2423); 
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if !((((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << QUALIFIED_TYPE_NAME) | (1usize << BOOLEAN_TYPE) | (1usize << BYTE_TYPE) | (1usize << SHORT_TYPE) | (1usize << CHAR_TYPE) | (1usize << INT_TYPE) | (1usize << LONG_TYPE) | (1usize << FLOAT_TYPE) | (1usize << DOUBLE_TYPE) | (1usize << COMPOUND_METHOD_ARG_LITERAL) | (1usize << LBRACK))) != 0) || _la==IDENTIFIER) {break}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodSignature ----------------
pub type MethodSignatureContextAll<'input> = MethodSignatureContext<'input>;


pub type MethodSignatureContext<'input> = BaseParserRuleContext<'input,MethodSignatureContextExt<'input>>;

#[derive(Clone)]
pub struct MethodSignatureContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MethodSignatureContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MethodSignatureContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodSignature(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_methodSignature(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodSignatureContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodSignature }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodSignature }
}
antlr_rust::tid!{MethodSignatureContextExt<'a>}

impl<'input> MethodSignatureContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodSignatureContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodSignatureContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodSignatureContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MethodSignatureContextExt<'input>>{

fn methodIdentifier(&self) -> Option<Rc<MethodIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn methodReturnType(&self) -> Option<Rc<MethodReturnTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodArguments(&self) -> Option<Rc<MethodArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MethodSignatureContextAttrs<'input> for MethodSignatureContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodSignature(&mut self,)
	-> Result<Rc<MethodSignatureContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodSignatureContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 610, RULE_methodSignature);
        let mut _localctx: Rc<MethodSignatureContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule methodIdentifier*/
			recog.base.set_state(2425);
			recog.methodIdentifier()?;

			recog.base.set_state(2426);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2428);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << QUALIFIED_TYPE_NAME) | (1usize << BOOLEAN_TYPE) | (1usize << BYTE_TYPE) | (1usize << SHORT_TYPE) | (1usize << CHAR_TYPE) | (1usize << INT_TYPE) | (1usize << LONG_TYPE) | (1usize << FLOAT_TYPE) | (1usize << DOUBLE_TYPE) | (1usize << COMPOUND_METHOD_ARG_LITERAL) | (1usize << LBRACK))) != 0) || _la==IDENTIFIER {
				{
				/*InvokeRule methodArguments*/
				recog.base.set_state(2427);
				recog.methodArguments()?;

				}
			}

			recog.base.set_state(2430);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			/*InvokeRule methodReturnType*/
			recog.base.set_state(2431);
			recog.methodReturnType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodDeclaration ----------------
pub type MethodDeclarationContextAll<'input> = MethodDeclarationContext<'input>;


pub type MethodDeclarationContext<'input> = BaseParserRuleContext<'input,MethodDeclarationContextExt<'input>>;

#[derive(Clone)]
pub struct MethodDeclarationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MethodDeclarationContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MethodDeclarationContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodDeclaration(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_methodDeclaration(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodDeclarationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodDeclaration }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodDeclaration }
}
antlr_rust::tid!{MethodDeclarationContextExt<'a>}

impl<'input> MethodDeclarationContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodDeclarationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodDeclarationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodDeclarationContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MethodDeclarationContextExt<'input>>{

fn methodSignature(&self) -> Option<Rc<MethodSignatureContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodModifier_all(&self) ->  Vec<Rc<MethodModifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn methodModifier(&self, i: usize) -> Option<Rc<MethodModifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> MethodDeclarationContextAttrs<'input> for MethodDeclarationContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodDeclaration(&mut self,)
	-> Result<Rc<MethodDeclarationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodDeclarationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 612, RULE_methodDeclaration);
        let mut _localctx: Rc<MethodDeclarationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2436);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(22,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule methodModifier*/
					recog.base.set_state(2433);
					recog.methodModifier()?;

					}
					} 
				}
				recog.base.set_state(2438);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(22,&mut recog.base)?;
			}
			/*InvokeRule methodSignature*/
			recog.base.set_state(2439);
			recog.methodSignature()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotationScope ----------------
pub type AnnotationScopeContextAll<'input> = AnnotationScopeContext<'input>;


pub type AnnotationScopeContext<'input> = BaseParserRuleContext<'input,AnnotationScopeContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationScopeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AnnotationScopeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AnnotationScopeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotationScope(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_annotationScope(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AnnotationScopeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotationScope }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotationScope }
}
antlr_rust::tid!{AnnotationScopeContextExt<'a>}

impl<'input> AnnotationScopeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationScopeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationScopeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationScopeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AnnotationScopeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IDENTIFIER
/// Returns `None` if there is no child corresponding to token IDENTIFIER
fn IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(IDENTIFIER, 0)
}

}

impl<'input> AnnotationScopeContextAttrs<'input> for AnnotationScopeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotationScope(&mut self,)
	-> Result<Rc<AnnotationScopeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationScopeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 614, RULE_annotationScope);
        let mut _localctx: Rc<AnnotationScopeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2441);
			recog.base.match_token(IDENTIFIER,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotationType ----------------
pub type AnnotationTypeContextAll<'input> = AnnotationTypeContext<'input>;


pub type AnnotationTypeContext<'input> = BaseParserRuleContext<'input,AnnotationTypeContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AnnotationTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AnnotationTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotationType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_annotationType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AnnotationTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotationType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotationType }
}
antlr_rust::tid!{AnnotationTypeContextExt<'a>}

impl<'input> AnnotationTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AnnotationTypeContextExt<'input>>{

fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AnnotationTypeContextAttrs<'input> for AnnotationTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotationType(&mut self,)
	-> Result<Rc<AnnotationTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 616, RULE_annotationType);
        let mut _localctx: Rc<AnnotationTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule referenceType*/
			recog.base.set_state(2443);
			recog.referenceType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotationFieldValue ----------------
pub type AnnotationFieldValueContextAll<'input> = AnnotationFieldValueContext<'input>;


pub type AnnotationFieldValueContext<'input> = BaseParserRuleContext<'input,AnnotationFieldValueContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationFieldValueContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AnnotationFieldValueContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AnnotationFieldValueContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotationFieldValue(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_annotationFieldValue(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AnnotationFieldValueContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotationFieldValue }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotationFieldValue }
}
antlr_rust::tid!{AnnotationFieldValueContextExt<'a>}

impl<'input> AnnotationFieldValueContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationFieldValueContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationFieldValueContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationFieldValueContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AnnotationFieldValueContextExt<'input>>{

fn assignableValue(&self) -> Option<Rc<AssignableValueContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AnnotationFieldValueContextAttrs<'input> for AnnotationFieldValueContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotationFieldValue(&mut self,)
	-> Result<Rc<AnnotationFieldValueContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationFieldValueContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 618, RULE_annotationFieldValue);
        let mut _localctx: Rc<AnnotationFieldValueContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2447);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(23,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule assignableValue*/
					recog.base.set_state(2445);
					recog.assignableValue()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule referenceType*/
					recog.base.set_state(2446);
					recog.referenceType()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotationValueScoped ----------------
pub type AnnotationValueScopedContextAll<'input> = AnnotationValueScopedContext<'input>;


pub type AnnotationValueScopedContext<'input> = BaseParserRuleContext<'input,AnnotationValueScopedContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationValueScopedContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AnnotationValueScopedContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AnnotationValueScopedContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotationValueScoped(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_annotationValueScoped(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AnnotationValueScopedContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotationValueScoped }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotationValueScoped }
}
antlr_rust::tid!{AnnotationValueScopedContextExt<'a>}

impl<'input> AnnotationValueScopedContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationValueScopedContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationValueScopedContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationValueScopedContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AnnotationValueScopedContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn annotationFieldValue_all(&self) ->  Vec<Rc<AnnotationFieldValueContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotationFieldValue(&self, i: usize) -> Option<Rc<AnnotationFieldValueContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> AnnotationValueScopedContextAttrs<'input> for AnnotationValueScopedContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotationValueScoped(&mut self,)
	-> Result<Rc<AnnotationValueScopedContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationValueScopedContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 620, RULE_annotationValueScoped);
        let mut _localctx: Rc<AnnotationValueScopedContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2449);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			recog.base.set_state(2458);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << QUALIFIED_TYPE_NAME) | (1usize << VOID_TYPE) | (1usize << BOOLEAN_TYPE) | (1usize << BYTE_TYPE) | (1usize << SHORT_TYPE) | (1usize << CHAR_TYPE) | (1usize << INT_TYPE) | (1usize << LONG_TYPE) | (1usize << FLOAT_TYPE) | (1usize << DOUBLE_TYPE) | (1usize << LBRACK) | (1usize << SUB))) != 0) || ((((_la - 294)) & !0x3f) == 0 && ((1usize << (_la - 294)) & ((1usize << (DECIMAL_LITERAL - 294)) | (1usize << (HEX_LITERAL - 294)) | (1usize << (OCT_LITERAL - 294)) | (1usize << (BINARY_LITERAL - 294)) | (1usize << (FLOAT_LITERAL - 294)) | (1usize << (HEX_FLOAT_LITERAL - 294)) | (1usize << (BOOL_LITERAL - 294)) | (1usize << (NULL_LITERAL - 294)) | (1usize << (STRING_LITERAL - 294)))) != 0) {
				{
				/*InvokeRule annotationFieldValue*/
				recog.base.set_state(2450);
				recog.annotationFieldValue()?;

				recog.base.set_state(2455);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				while _la==COMMA {
					{
					{
					recog.base.set_state(2451);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule annotationFieldValue*/
					recog.base.set_state(2452);
					recog.annotationFieldValue()?;

					}
					}
					recog.base.set_state(2457);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
				}
				}
			}

			recog.base.set_state(2460);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotationField ----------------
pub type AnnotationFieldContextAll<'input> = AnnotationFieldContext<'input>;


pub type AnnotationFieldContext<'input> = BaseParserRuleContext<'input,AnnotationFieldContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationFieldContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AnnotationFieldContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AnnotationFieldContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotationField(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_annotationField(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AnnotationFieldContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotationField }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotationField }
}
antlr_rust::tid!{AnnotationFieldContextExt<'a>}

impl<'input> AnnotationFieldContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationFieldContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationFieldContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationFieldContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AnnotationFieldContextExt<'input>>{

fn fieldName(&self) -> Option<Rc<FieldNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ASSIGN
/// Returns `None` if there is no child corresponding to token ASSIGN
fn ASSIGN(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(ASSIGN, 0)
}
fn annotationFieldValue(&self) -> Option<Rc<AnnotationFieldValueContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotationValueScoped(&self) -> Option<Rc<AnnotationValueScopedContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AnnotationFieldContextAttrs<'input> for AnnotationFieldContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotationField(&mut self,)
	-> Result<Rc<AnnotationFieldContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationFieldContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 622, RULE_annotationField);
        let mut _localctx: Rc<AnnotationFieldContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule fieldName*/
			recog.base.set_state(2462);
			recog.fieldName()?;

			recog.base.set_state(2463);
			recog.base.match_token(ASSIGN,&mut recog.err_handler)?;

			recog.base.set_state(2466);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 QUALIFIED_TYPE_NAME | VOID_TYPE | BOOLEAN_TYPE | BYTE_TYPE | SHORT_TYPE |
			 CHAR_TYPE | INT_TYPE | LONG_TYPE | FLOAT_TYPE | DOUBLE_TYPE | LBRACK |
			 SUB | DECIMAL_LITERAL | HEX_LITERAL | OCT_LITERAL | BINARY_LITERAL |
			 FLOAT_LITERAL | HEX_FLOAT_LITERAL | BOOL_LITERAL | NULL_LITERAL | STRING_LITERAL 
				=> {
					{
					/*InvokeRule annotationFieldValue*/
					recog.base.set_state(2464);
					recog.annotationFieldValue()?;

					}
				}

			 LBRACE 
				=> {
					{
					/*InvokeRule annotationValueScoped*/
					recog.base.set_state(2465);
					recog.annotationValueScoped()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- annotationDirective ----------------
pub type AnnotationDirectiveContextAll<'input> = AnnotationDirectiveContext<'input>;


pub type AnnotationDirectiveContext<'input> = BaseParserRuleContext<'input,AnnotationDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct AnnotationDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for AnnotationDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for AnnotationDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_annotationDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_annotationDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for AnnotationDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_annotationDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_annotationDirective }
}
antlr_rust::tid!{AnnotationDirectiveContextExt<'a>}

impl<'input> AnnotationDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AnnotationDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AnnotationDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AnnotationDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<AnnotationDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ANNOTATION_DIRECTIVE
/// Returns `None` if there is no child corresponding to token ANNOTATION_DIRECTIVE
fn ANNOTATION_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(ANNOTATION_DIRECTIVE, 0)
}
fn annotationScope(&self) -> Option<Rc<AnnotationScopeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotationType(&self) -> Option<Rc<AnnotationTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ANNOTATION_END_DIRECTIVE
/// Returns `None` if there is no child corresponding to token ANNOTATION_END_DIRECTIVE
fn ANNOTATION_END_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(ANNOTATION_END_DIRECTIVE, 0)
}
fn annotationField_all(&self) ->  Vec<Rc<AnnotationFieldContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotationField(&self, i: usize) -> Option<Rc<AnnotationFieldContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> AnnotationDirectiveContextAttrs<'input> for AnnotationDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn annotationDirective(&mut self,)
	-> Result<Rc<AnnotationDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AnnotationDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 624, RULE_annotationDirective);
        let mut _localctx: Rc<AnnotationDirectiveContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2468);
			recog.base.match_token(ANNOTATION_DIRECTIVE,&mut recog.err_handler)?;

			/*InvokeRule annotationScope*/
			recog.base.set_state(2469);
			recog.annotationScope()?;

			/*InvokeRule annotationType*/
			recog.base.set_state(2470);
			recog.annotationType()?;

			recog.base.set_state(2474);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << VOID_TYPE) | (1usize << BOOLEAN_TYPE) | (1usize << BYTE_TYPE) | (1usize << SHORT_TYPE) | (1usize << CHAR_TYPE) | (1usize << INT_TYPE) | (1usize << LONG_TYPE) | (1usize << FLOAT_TYPE) | (1usize << DOUBLE_TYPE))) != 0) || ((((_la - 56)) & !0x3f) == 0 && ((1usize << (_la - 56)) & ((1usize << (ANNOTATION - 56)) | (1usize << (SYNTHETIC - 56)) | (1usize << (CONSTRUCTOR - 56)) | (1usize << (BRIDGE - 56)) | (1usize << (VARARGS - 56)) | (1usize << (NATIVE - 56)))) != 0) || _la==IDENTIFIER {
				{
				{
				/*InvokeRule annotationField*/
				recog.base.set_state(2471);
				recog.annotationField()?;

				}
				}
				recog.base.set_state(2476);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2477);
			recog.base.match_token(ANNOTATION_END_DIRECTIVE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- locaDirectiveVariableName ----------------
pub type LocaDirectiveVariableNameContextAll<'input> = LocaDirectiveVariableNameContext<'input>;


pub type LocaDirectiveVariableNameContext<'input> = BaseParserRuleContext<'input,LocaDirectiveVariableNameContextExt<'input>>;

#[derive(Clone)]
pub struct LocaDirectiveVariableNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for LocaDirectiveVariableNameContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for LocaDirectiveVariableNameContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_locaDirectiveVariableName(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_locaDirectiveVariableName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LocaDirectiveVariableNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_locaDirectiveVariableName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_locaDirectiveVariableName }
}
antlr_rust::tid!{LocaDirectiveVariableNameContextExt<'a>}

impl<'input> LocaDirectiveVariableNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LocaDirectiveVariableNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LocaDirectiveVariableNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LocaDirectiveVariableNameContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<LocaDirectiveVariableNameContextExt<'input>>{

fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LocaDirectiveVariableNameContextAttrs<'input> for LocaDirectiveVariableNameContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn locaDirectiveVariableName(&mut self,)
	-> Result<Rc<LocaDirectiveVariableNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LocaDirectiveVariableNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 626, RULE_locaDirectiveVariableName);
        let mut _localctx: Rc<LocaDirectiveVariableNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule stringLiteral*/
			recog.base.set_state(2479);
			recog.stringLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- localDirectiveType ----------------
pub type LocalDirectiveTypeContextAll<'input> = LocalDirectiveTypeContext<'input>;


pub type LocalDirectiveTypeContext<'input> = BaseParserRuleContext<'input,LocalDirectiveTypeContextExt<'input>>;

#[derive(Clone)]
pub struct LocalDirectiveTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for LocalDirectiveTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for LocalDirectiveTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_localDirectiveType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_localDirectiveType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LocalDirectiveTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_localDirectiveType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_localDirectiveType }
}
antlr_rust::tid!{LocalDirectiveTypeContextExt<'a>}

impl<'input> LocalDirectiveTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LocalDirectiveTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LocalDirectiveTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LocalDirectiveTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<LocalDirectiveTypeContextExt<'input>>{

fn nonVoidType(&self) -> Option<Rc<NonVoidTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LocalDirectiveTypeContextAttrs<'input> for LocalDirectiveTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn localDirectiveType(&mut self,)
	-> Result<Rc<LocalDirectiveTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LocalDirectiveTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 628, RULE_localDirectiveType);
        let mut _localctx: Rc<LocalDirectiveTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule nonVoidType*/
			recog.base.set_state(2481);
			recog.nonVoidType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- localDirectiveGenericHint ----------------
pub type LocalDirectiveGenericHintContextAll<'input> = LocalDirectiveGenericHintContext<'input>;


pub type LocalDirectiveGenericHintContext<'input> = BaseParserRuleContext<'input,LocalDirectiveGenericHintContextExt<'input>>;

#[derive(Clone)]
pub struct LocalDirectiveGenericHintContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for LocalDirectiveGenericHintContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for LocalDirectiveGenericHintContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_localDirectiveGenericHint(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_localDirectiveGenericHint(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LocalDirectiveGenericHintContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_localDirectiveGenericHint }
	//fn type_rule_index() -> usize where Self: Sized { RULE_localDirectiveGenericHint }
}
antlr_rust::tid!{LocalDirectiveGenericHintContextExt<'a>}

impl<'input> LocalDirectiveGenericHintContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LocalDirectiveGenericHintContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LocalDirectiveGenericHintContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LocalDirectiveGenericHintContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<LocalDirectiveGenericHintContextExt<'input>>{

fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LocalDirectiveGenericHintContextAttrs<'input> for LocalDirectiveGenericHintContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn localDirectiveGenericHint(&mut self,)
	-> Result<Rc<LocalDirectiveGenericHintContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LocalDirectiveGenericHintContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 630, RULE_localDirectiveGenericHint);
        let mut _localctx: Rc<LocalDirectiveGenericHintContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule stringLiteral*/
			recog.base.set_state(2483);
			recog.stringLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- localDirectiveRegister ----------------
pub type LocalDirectiveRegisterContextAll<'input> = LocalDirectiveRegisterContext<'input>;


pub type LocalDirectiveRegisterContext<'input> = BaseParserRuleContext<'input,LocalDirectiveRegisterContextExt<'input>>;

#[derive(Clone)]
pub struct LocalDirectiveRegisterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for LocalDirectiveRegisterContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for LocalDirectiveRegisterContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_localDirectiveRegister(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_localDirectiveRegister(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LocalDirectiveRegisterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_localDirectiveRegister }
	//fn type_rule_index() -> usize where Self: Sized { RULE_localDirectiveRegister }
}
antlr_rust::tid!{LocalDirectiveRegisterContextExt<'a>}

impl<'input> LocalDirectiveRegisterContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LocalDirectiveRegisterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LocalDirectiveRegisterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LocalDirectiveRegisterContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<LocalDirectiveRegisterContextExt<'input>>{

fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LocalDirectiveRegisterContextAttrs<'input> for LocalDirectiveRegisterContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn localDirectiveRegister(&mut self,)
	-> Result<Rc<LocalDirectiveRegisterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LocalDirectiveRegisterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 632, RULE_localDirectiveRegister);
        let mut _localctx: Rc<LocalDirectiveRegisterContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule registerIdentifier*/
			recog.base.set_state(2485);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- localDirective ----------------
pub type LocalDirectiveContextAll<'input> = LocalDirectiveContext<'input>;


pub type LocalDirectiveContext<'input> = BaseParserRuleContext<'input,LocalDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct LocalDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for LocalDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for LocalDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_localDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_localDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LocalDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_localDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_localDirective }
}
antlr_rust::tid!{LocalDirectiveContextExt<'a>}

impl<'input> LocalDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LocalDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LocalDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LocalDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<LocalDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LOCAL_DIRECTIVE
/// Returns `None` if there is no child corresponding to token LOCAL_DIRECTIVE
fn LOCAL_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(LOCAL_DIRECTIVE, 0)
}
fn localDirectiveRegister(&self) -> Option<Rc<LocalDirectiveRegisterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn locaDirectiveVariableName(&self) -> Option<Rc<LocaDirectiveVariableNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn localDirectiveType(&self) -> Option<Rc<LocalDirectiveTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn localDirectiveGenericHint(&self) -> Option<Rc<LocalDirectiveGenericHintContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LocalDirectiveContextAttrs<'input> for LocalDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn localDirective(&mut self,)
	-> Result<Rc<LocalDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LocalDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 634, RULE_localDirective);
        let mut _localctx: Rc<LocalDirectiveContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2487);
			recog.base.match_token(LOCAL_DIRECTIVE,&mut recog.err_handler)?;

			/*InvokeRule localDirectiveRegister*/
			recog.base.set_state(2488);
			recog.localDirectiveRegister()?;

			recog.base.set_state(2489);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule locaDirectiveVariableName*/
			recog.base.set_state(2490);
			recog.locaDirectiveVariableName()?;

			recog.base.set_state(2493);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(28,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2491);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					/*InvokeRule localDirectiveType*/
					recog.base.set_state(2492);
					recog.localDirectiveType()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2497);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				recog.base.set_state(2495);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule localDirectiveGenericHint*/
				recog.base.set_state(2496);
				recog.localDirectiveGenericHint()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- localEndDirective ----------------
pub type LocalEndDirectiveContextAll<'input> = LocalEndDirectiveContext<'input>;


pub type LocalEndDirectiveContext<'input> = BaseParserRuleContext<'input,LocalEndDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct LocalEndDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for LocalEndDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for LocalEndDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_localEndDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_localEndDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LocalEndDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_localEndDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_localEndDirective }
}
antlr_rust::tid!{LocalEndDirectiveContextExt<'a>}

impl<'input> LocalEndDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LocalEndDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LocalEndDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LocalEndDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<LocalEndDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LOCAL_END_DIRECTIVE
/// Returns `None` if there is no child corresponding to token LOCAL_END_DIRECTIVE
fn LOCAL_END_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(LOCAL_END_DIRECTIVE, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LocalEndDirectiveContextAttrs<'input> for LocalEndDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn localEndDirective(&mut self,)
	-> Result<Rc<LocalEndDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LocalEndDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 636, RULE_localEndDirective);
        let mut _localctx: Rc<LocalEndDirectiveContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2499);
			recog.base.match_token(LOCAL_END_DIRECTIVE,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(2500);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- localRestartDirective ----------------
pub type LocalRestartDirectiveContextAll<'input> = LocalRestartDirectiveContext<'input>;


pub type LocalRestartDirectiveContext<'input> = BaseParserRuleContext<'input,LocalRestartDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct LocalRestartDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for LocalRestartDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for LocalRestartDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_localRestartDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_localRestartDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LocalRestartDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_localRestartDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_localRestartDirective }
}
antlr_rust::tid!{LocalRestartDirectiveContextExt<'a>}

impl<'input> LocalRestartDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LocalRestartDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LocalRestartDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LocalRestartDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<LocalRestartDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token RESTART_LOCAL_DIRECTIVE
/// Returns `None` if there is no child corresponding to token RESTART_LOCAL_DIRECTIVE
fn RESTART_LOCAL_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(RESTART_LOCAL_DIRECTIVE, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LocalRestartDirectiveContextAttrs<'input> for LocalRestartDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn localRestartDirective(&mut self,)
	-> Result<Rc<LocalRestartDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LocalRestartDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 638, RULE_localRestartDirective);
        let mut _localctx: Rc<LocalRestartDirectiveContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2502);
			recog.base.match_token(RESTART_LOCAL_DIRECTIVE,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(2503);
			recog.registerIdentifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lineLabel ----------------
pub type LineLabelContextAll<'input> = LineLabelContext<'input>;


pub type LineLabelContext<'input> = BaseParserRuleContext<'input,LineLabelContextExt<'input>>;

#[derive(Clone)]
pub struct LineLabelContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for LineLabelContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for LineLabelContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lineLabel(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_lineLabel(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LineLabelContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lineLabel }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lineLabel }
}
antlr_rust::tid!{LineLabelContextExt<'a>}

impl<'input> LineLabelContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LineLabelContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LineLabelContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LineLabelContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<LineLabelContextExt<'input>>{

fn label(&self) -> Option<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LineLabelContextAttrs<'input> for LineLabelContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lineLabel(&mut self,)
	-> Result<Rc<LineLabelContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LineLabelContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 640, RULE_lineLabel);
        let mut _localctx: Rc<LineLabelContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule label*/
			recog.base.set_state(2505);
			recog.label()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodBodyStatement ----------------
pub type MethodBodyStatementContextAll<'input> = MethodBodyStatementContext<'input>;


pub type MethodBodyStatementContext<'input> = BaseParserRuleContext<'input,MethodBodyStatementContextExt<'input>>;

#[derive(Clone)]
pub struct MethodBodyStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MethodBodyStatementContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MethodBodyStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodBodyStatement(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_methodBodyStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodBodyStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodBodyStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodBodyStatement }
}
antlr_rust::tid!{MethodBodyStatementContextExt<'a>}

impl<'input> MethodBodyStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodBodyStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodBodyStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodBodyStatementContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MethodBodyStatementContextExt<'input>>{

fn registersDirective(&self) -> Option<Rc<RegistersDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn localsDirective(&self) -> Option<Rc<LocalsDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn paramDirective(&self) -> Option<Rc<ParamDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn lineDirective(&self) -> Option<Rc<LineDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn instruction(&self) -> Option<Rc<InstructionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn lineLabel(&self) -> Option<Rc<LineLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn catchDirective(&self) -> Option<Rc<CatchDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn catchAllDirective(&self) -> Option<Rc<CatchAllDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn annotationDirective(&self) -> Option<Rc<AnnotationDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn localDirective(&self) -> Option<Rc<LocalDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn localEndDirective(&self) -> Option<Rc<LocalEndDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn localRestartDirective(&self) -> Option<Rc<LocalRestartDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn packedSwitchDirective(&self) -> Option<Rc<PackedSwitchDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn arrayDataDirective(&self) -> Option<Rc<ArrayDataDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sparseSwitchDirective(&self) -> Option<Rc<SparseSwitchDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MethodBodyStatementContextAttrs<'input> for MethodBodyStatementContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodBodyStatement(&mut self,)
	-> Result<Rc<MethodBodyStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodBodyStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 642, RULE_methodBodyStatement);
        let mut _localctx: Rc<MethodBodyStatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2522);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 REGISTERS_DIRECTIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule registersDirective*/
					recog.base.set_state(2507);
					recog.registersDirective()?;

					}
				}

			 LOCALS_DIRECTIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule localsDirective*/
					recog.base.set_state(2508);
					recog.localsDirective()?;

					}
				}

			 PARAM_DIRECTIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule paramDirective*/
					recog.base.set_state(2509);
					recog.paramDirective()?;

					}
				}

			 LINE_DIRECTIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule lineDirective*/
					recog.base.set_state(2510);
					recog.lineDirective()?;

					}
				}

			 OP_NOP | OP_MOVE | OP_MOVE_FROM16 | OP_MOVE_16 | OP_MOVE_WIDE | OP_MOVE_WIDE_FROM16 |
			 OP_MOVE_WIDE_16 | OP_MOVE_OBJECT | OP_MOVE_OBJECT_FROM16 | OP_MOVE_OBJECT_16 |
			 OP_MOVE_RESULT | OP_MOVE_RESULT_WIDE | OP_MOVE_RESULT_OBJECT | OP_MOVE_EXCEPTION |
			 OP_RETURN_VOID | OP_RETURN | OP_RETURN_WIDE | OP_RETURN_OBJECT | OP_CONST_4 |
			 OP_CONST_16 | OP_CONST | OP_CONST_HIGH16 | OP_CONST_WIDE_16 | OP_CONST_WIDE_32 |
			 OP_CONST_WIDE | OP_CONST_WIDE_HIGH16 | OP_CONST_STRING | OP_CONST_STRING_JUMBO |
			 OP_CONST_CLASS | OP_MONITOR_ENTER | OP_MONITOR_EXIT | OP_CHECK_CAST |
			 OP_INSTANCE_OF | OP_ARRAY_LENGTH | OP_NEW_INSTANCE | OP_NEW_ARRAY | OP_FILLED_NEW_ARRAY |
			 OP_FILLED_NEW_ARRAY_RANGE | OP_FILL_ARRAY_DATA | OP_THROW | OP_GOTO |
			 OP_GOTO_16 | OP_GOTO_32 | OP_CMPL_FLOAT | OP_CMPG_FLOAT | OP_CMPL_DOUBLE |
			 OP_CMPG_DOUBLE | OP_CMP_LONG | OP_IF_EQ | OP_IF_NE | OP_IF_LT | OP_IF_GE |
			 OP_IF_GT | OP_IF_LE | OP_IF_EQZ | OP_IF_NEZ | OP_IF_LTZ | OP_IF_GEZ |
			 OP_IF_GTZ | OP_IF_LEZ | OP_AGET | OP_AGET_WIDE | OP_AGET_OBJECT | OP_AGET_BOOLEAN |
			 OP_AGET_BYTE | OP_AGET_CHAR | OP_AGET_SHORT | OP_APUT | OP_APUT_WIDE |
			 OP_APUT_OBJECT | OP_APUT_BOOLEAN | OP_APUT_BYTE | OP_APUT_CHAR | OP_APUT_SHORT |
			 OP_IGET | OP_IGET_WIDE | OP_IGET_OBJECT | OP_IGET_BOOLEAN | OP_IGET_BYTE |
			 OP_IGET_CHAR | OP_IGET_SHORT | OP_IPUT | OP_IPUT_WIDE | OP_IPUT_OBJECT |
			 OP_IPUT_BOOLEAN | OP_IPUT_BYTE | OP_IPUT_CHAR | OP_IPUT_SHORT | OP_SGET |
			 OP_SGET_WIDE | OP_SGET_OBJECT | OP_SGET_BOOLEAN | OP_SGET_BYTE | OP_SGET_CHAR |
			 OP_SGET_SHORT | OP_SPUT | OP_SPUT_WIDE | OP_SPUT_OBJECT | OP_SPUT_BOOLEAN |
			 OP_SPUT_BYTE | OP_SPUT_CHAR | OP_SPUT_SHORT | OP_INVOKE_VIRTUAL | OP_INVOKE_SUPER |
			 OP_INVOKE_DIRECT | OP_INVOKE_STATIC | OP_INVOKE_INTERFACE | OP_INVOKE_VIRTUAL_RANGE |
			 OP_INVOKE_SUPER_RANGE | OP_INVOKE_DIRECT_RANGE | OP_INVOKE_STATIC_RANGE |
			 OP_INVOKE_INTERFACE_RANGE | OP_NEG_INT | OP_NOT_INT | OP_NEG_LONG | OP_NOT_LONG |
			 OP_NEG_FLOAT | OP_NEG_DOUBLE | OP_INT_TO_LONG | OP_INT_TO_FLOAT | OP_INT_TO_DOUBLE |
			 OP_LONG_TO_INT | OP_LONG_TO_FLOAT | OP_LONG_TO_DOUBLE | OP_FLOAT_TO_INT |
			 OP_FLOAT_TO_LONG | OP_FLOAT_TO_DOUBLE | OP_DOUBLE_TO_INT | OP_DOUBLE_TO_LONG |
			 OP_DOUBLE_TO_FLOAT | OP_INT_TO_BYTE | OP_INT_TO_CHAR | OP_INT_TO_SHORT |
			 OP_ADD_INT | OP_SUB_INT | OP_MUL_INT | OP_DIV_INT | OP_REM_INT | OP_AND_INT |
			 OP_OR_INT | OP_XOR_INT | OP_SHL_INT | OP_SHR_INT | OP_USHR_INT | OP_ADD_LONG |
			 OP_SUB_LONG | OP_MUL_LONG | OP_DIV_LONG | OP_REM_LONG | OP_AND_LONG |
			 OP_OR_LONG | OP_XOR_LONG | OP_SHL_LONG | OP_SHR_LONG | OP_USHR_LONG |
			 OP_ADD_FLOAT | OP_SUB_FLOAT | OP_MUL_FLOAT | OP_DIV_FLOAT | OP_REM_FLOAT |
			 OP_ADD_DOUBLE | OP_SUB_DOUBLE | OP_MUL_DOUBLE | OP_DIV_DOUBLE | OP_REM_DOUBLE |
			 OP_ADD_INT_2ADDR | OP_SUB_INT_2ADDR | OP_MUL_INT_2ADDR | OP_DIV_INT_2ADDR |
			 OP_REM_INT_2ADDR | OP_AND_INT_2ADDR | OP_OR_INT_2ADDR | OP_XOR_INT_2ADDR |
			 OP_SHL_INT_2ADDR | OP_SHR_INT_2ADDR | OP_USHR_INT_2ADDR | OP_ADD_LONG_2ADDR |
			 OP_SUB_LONG_2ADDR | OP_MUL_LONG_2ADDR | OP_DIV_LONG_2ADDR | OP_REM_LONG_2ADDR |
			 OP_AND_LONG_2ADDR | OP_OR_LONG_2ADDR | OP_XOR_LONG_2ADDR | OP_SHL_LONG_2ADDR |
			 OP_SHR_LONG_2ADDR | OP_USHR_LONG_2ADDR | OP_ADD_FLOAT_2ADDR | OP_SUB_FLOAT_2ADDR |
			 OP_MUL_FLOAT_2ADDR | OP_DIV_FLOAT_2ADDR | OP_REM_FLOAT_2ADDR | OP_ADD_DOUBLE_2ADDR |
			 OP_SUB_DOUBLE_2ADDR | OP_MUL_DOUBLE_2ADDR | OP_DIV_DOUBLE_2ADDR | OP_REM_DOUBLE_2ADDR |
			 OP_ADD_INT_LIT16 | OP_RSUB_INT | OP_MUL_INT_LIT16 | OP_DIV_INT_LIT16 |
			 OP_REM_INT_LIT16 | OP_AND_INT_LIT16 | OP_OR_INT_LIT16 | OP_XOR_INT_LIT16 |
			 OP_ADD_INT_LIT8 | OP_RSUB_INT_LIT8 | OP_MUL_INT_LIT8 | OP_DIV_INT_LIT8 |
			 OP_REM_INT_LIT8 | OP_AND_INT_LIT8 | OP_OR_INT_LIT8 | OP_XOR_INT_LIT8 |
			 OP_SHL_INT_LIT8 | OP_SHR_INT_LIT8 | OP_USHR_INT_LIT8 | OP_INVOKE_POLYMORPHIC |
			 OP_INVOKE_POLYMORPHIC_RANGE | OP_INVOKE_CUSTOM | OP_INVOKE_CUSTOM_RANGE |
			 OP_CONST_METHOD_HANDLE | OP_CONST_METHOD_TYPE | OP_PACKED_SWITCH | OP_SPARSE_SWITCH 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule instruction*/
					recog.base.set_state(2511);
					recog.instruction()?;

					}
				}

			 COLON 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					/*InvokeRule lineLabel*/
					recog.base.set_state(2512);
					recog.lineLabel()?;

					}
				}

			 CATCH_DIRECTIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					/*InvokeRule catchDirective*/
					recog.base.set_state(2513);
					recog.catchDirective()?;

					}
				}

			 CATCHALL_DIRECTIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					/*InvokeRule catchAllDirective*/
					recog.base.set_state(2514);
					recog.catchAllDirective()?;

					}
				}

			 ANNOTATION_DIRECTIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					/*InvokeRule annotationDirective*/
					recog.base.set_state(2515);
					recog.annotationDirective()?;

					}
				}

			 LOCAL_DIRECTIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					/*InvokeRule localDirective*/
					recog.base.set_state(2516);
					recog.localDirective()?;

					}
				}

			 LOCAL_END_DIRECTIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					/*InvokeRule localEndDirective*/
					recog.base.set_state(2517);
					recog.localEndDirective()?;

					}
				}

			 RESTART_LOCAL_DIRECTIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 12);
					recog.base.enter_outer_alt(None, 12);
					{
					/*InvokeRule localRestartDirective*/
					recog.base.set_state(2518);
					recog.localRestartDirective()?;

					}
				}

			 PACKED_SWITCH_DIRECTIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 13);
					recog.base.enter_outer_alt(None, 13);
					{
					/*InvokeRule packedSwitchDirective*/
					recog.base.set_state(2519);
					recog.packedSwitchDirective()?;

					}
				}

			 ARRAY_DATA_DIRECTIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 14);
					recog.base.enter_outer_alt(None, 14);
					{
					/*InvokeRule arrayDataDirective*/
					recog.base.set_state(2520);
					recog.arrayDataDirective()?;

					}
				}

			 SPARSE_SWITCH_DIRECTIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 15);
					recog.base.enter_outer_alt(None, 15);
					{
					/*InvokeRule sparseSwitchDirective*/
					recog.base.set_state(2521);
					recog.sparseSwitchDirective()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodBody ----------------
pub type MethodBodyContextAll<'input> = MethodBodyContext<'input>;


pub type MethodBodyContext<'input> = BaseParserRuleContext<'input,MethodBodyContextExt<'input>>;

#[derive(Clone)]
pub struct MethodBodyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MethodBodyContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MethodBodyContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodBody(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_methodBody(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodBodyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodBody }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodBody }
}
antlr_rust::tid!{MethodBodyContextExt<'a>}

impl<'input> MethodBodyContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodBodyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodBodyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodBodyContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MethodBodyContextExt<'input>>{

fn methodBodyStatement_all(&self) ->  Vec<Rc<MethodBodyStatementContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn methodBodyStatement(&self, i: usize) -> Option<Rc<MethodBodyStatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> MethodBodyContextAttrs<'input> for MethodBodyContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodBody(&mut self,)
	-> Result<Rc<MethodBodyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodBodyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 644, RULE_methodBody);
        let mut _localctx: Rc<MethodBodyContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2525); 
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			loop {
				{
				{
				/*InvokeRule methodBodyStatement*/
				recog.base.set_state(2524);
				recog.methodBodyStatement()?;

				}
				}
				recog.base.set_state(2527); 
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if !(((((_la - 18)) & !0x3f) == 0 && ((1usize << (_la - 18)) & ((1usize << (COLON - 18)) | (1usize << (REGISTERS_DIRECTIVE - 18)) | (1usize << (LOCALS_DIRECTIVE - 18)) | (1usize << (PARAM_DIRECTIVE - 18)) | (1usize << (LINE_DIRECTIVE - 18)) | (1usize << (CATCH_DIRECTIVE - 18)) | (1usize << (CATCHALL_DIRECTIVE - 18)) | (1usize << (ANNOTATION_DIRECTIVE - 18)) | (1usize << (LOCAL_DIRECTIVE - 18)) | (1usize << (LOCAL_END_DIRECTIVE - 18)) | (1usize << (RESTART_LOCAL_DIRECTIVE - 18)) | (1usize << (PACKED_SWITCH_DIRECTIVE - 18)) | (1usize << (ARRAY_DATA_DIRECTIVE - 18)) | (1usize << (SPARSE_SWITCH_DIRECTIVE - 18)))) != 0) || ((((_la - 70)) & !0x3f) == 0 && ((1usize << (_la - 70)) & ((1usize << (OP_NOP - 70)) | (1usize << (OP_MOVE - 70)) | (1usize << (OP_MOVE_FROM16 - 70)) | (1usize << (OP_MOVE_16 - 70)) | (1usize << (OP_MOVE_WIDE - 70)) | (1usize << (OP_MOVE_WIDE_FROM16 - 70)) | (1usize << (OP_MOVE_WIDE_16 - 70)) | (1usize << (OP_MOVE_OBJECT - 70)) | (1usize << (OP_MOVE_OBJECT_FROM16 - 70)) | (1usize << (OP_MOVE_OBJECT_16 - 70)) | (1usize << (OP_MOVE_RESULT - 70)) | (1usize << (OP_MOVE_RESULT_WIDE - 70)) | (1usize << (OP_MOVE_RESULT_OBJECT - 70)) | (1usize << (OP_MOVE_EXCEPTION - 70)) | (1usize << (OP_RETURN_VOID - 70)) | (1usize << (OP_RETURN - 70)) | (1usize << (OP_RETURN_WIDE - 70)) | (1usize << (OP_RETURN_OBJECT - 70)) | (1usize << (OP_CONST_4 - 70)) | (1usize << (OP_CONST_16 - 70)) | (1usize << (OP_CONST - 70)) | (1usize << (OP_CONST_HIGH16 - 70)) | (1usize << (OP_CONST_WIDE_16 - 70)) | (1usize << (OP_CONST_WIDE_32 - 70)) | (1usize << (OP_CONST_WIDE - 70)) | (1usize << (OP_CONST_WIDE_HIGH16 - 70)) | (1usize << (OP_CONST_STRING - 70)) | (1usize << (OP_CONST_STRING_JUMBO - 70)) | (1usize << (OP_CONST_CLASS - 70)) | (1usize << (OP_MONITOR_ENTER - 70)) | (1usize << (OP_MONITOR_EXIT - 70)) | (1usize << (OP_CHECK_CAST - 70)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (OP_INSTANCE_OF - 102)) | (1usize << (OP_ARRAY_LENGTH - 102)) | (1usize << (OP_NEW_INSTANCE - 102)) | (1usize << (OP_NEW_ARRAY - 102)) | (1usize << (OP_FILLED_NEW_ARRAY - 102)) | (1usize << (OP_FILLED_NEW_ARRAY_RANGE - 102)) | (1usize << (OP_FILL_ARRAY_DATA - 102)) | (1usize << (OP_THROW - 102)) | (1usize << (OP_GOTO - 102)) | (1usize << (OP_GOTO_16 - 102)) | (1usize << (OP_GOTO_32 - 102)) | (1usize << (OP_CMPL_FLOAT - 102)) | (1usize << (OP_CMPG_FLOAT - 102)) | (1usize << (OP_CMPL_DOUBLE - 102)) | (1usize << (OP_CMPG_DOUBLE - 102)) | (1usize << (OP_CMP_LONG - 102)) | (1usize << (OP_IF_EQ - 102)) | (1usize << (OP_IF_NE - 102)) | (1usize << (OP_IF_LT - 102)) | (1usize << (OP_IF_GE - 102)) | (1usize << (OP_IF_GT - 102)) | (1usize << (OP_IF_LE - 102)) | (1usize << (OP_IF_EQZ - 102)) | (1usize << (OP_IF_NEZ - 102)) | (1usize << (OP_IF_LTZ - 102)) | (1usize << (OP_IF_GEZ - 102)) | (1usize << (OP_IF_GTZ - 102)) | (1usize << (OP_IF_LEZ - 102)) | (1usize << (OP_AGET - 102)) | (1usize << (OP_AGET_WIDE - 102)) | (1usize << (OP_AGET_OBJECT - 102)) | (1usize << (OP_AGET_BOOLEAN - 102)))) != 0) || ((((_la - 134)) & !0x3f) == 0 && ((1usize << (_la - 134)) & ((1usize << (OP_AGET_BYTE - 134)) | (1usize << (OP_AGET_CHAR - 134)) | (1usize << (OP_AGET_SHORT - 134)) | (1usize << (OP_APUT - 134)) | (1usize << (OP_APUT_WIDE - 134)) | (1usize << (OP_APUT_OBJECT - 134)) | (1usize << (OP_APUT_BOOLEAN - 134)) | (1usize << (OP_APUT_BYTE - 134)) | (1usize << (OP_APUT_CHAR - 134)) | (1usize << (OP_APUT_SHORT - 134)) | (1usize << (OP_IGET - 134)) | (1usize << (OP_IGET_WIDE - 134)) | (1usize << (OP_IGET_OBJECT - 134)) | (1usize << (OP_IGET_BOOLEAN - 134)) | (1usize << (OP_IGET_BYTE - 134)) | (1usize << (OP_IGET_CHAR - 134)) | (1usize << (OP_IGET_SHORT - 134)) | (1usize << (OP_IPUT - 134)) | (1usize << (OP_IPUT_WIDE - 134)) | (1usize << (OP_IPUT_OBJECT - 134)) | (1usize << (OP_IPUT_BOOLEAN - 134)) | (1usize << (OP_IPUT_BYTE - 134)) | (1usize << (OP_IPUT_CHAR - 134)) | (1usize << (OP_IPUT_SHORT - 134)) | (1usize << (OP_SGET - 134)) | (1usize << (OP_SGET_WIDE - 134)) | (1usize << (OP_SGET_OBJECT - 134)) | (1usize << (OP_SGET_BOOLEAN - 134)) | (1usize << (OP_SGET_BYTE - 134)) | (1usize << (OP_SGET_CHAR - 134)) | (1usize << (OP_SGET_SHORT - 134)) | (1usize << (OP_SPUT - 134)))) != 0) || ((((_la - 166)) & !0x3f) == 0 && ((1usize << (_la - 166)) & ((1usize << (OP_SPUT_WIDE - 166)) | (1usize << (OP_SPUT_OBJECT - 166)) | (1usize << (OP_SPUT_BOOLEAN - 166)) | (1usize << (OP_SPUT_BYTE - 166)) | (1usize << (OP_SPUT_CHAR - 166)) | (1usize << (OP_SPUT_SHORT - 166)) | (1usize << (OP_INVOKE_VIRTUAL - 166)) | (1usize << (OP_INVOKE_SUPER - 166)) | (1usize << (OP_INVOKE_DIRECT - 166)) | (1usize << (OP_INVOKE_STATIC - 166)) | (1usize << (OP_INVOKE_INTERFACE - 166)) | (1usize << (OP_INVOKE_VIRTUAL_RANGE - 166)) | (1usize << (OP_INVOKE_SUPER_RANGE - 166)) | (1usize << (OP_INVOKE_DIRECT_RANGE - 166)) | (1usize << (OP_INVOKE_STATIC_RANGE - 166)) | (1usize << (OP_INVOKE_INTERFACE_RANGE - 166)) | (1usize << (OP_NEG_INT - 166)) | (1usize << (OP_NOT_INT - 166)) | (1usize << (OP_NEG_LONG - 166)) | (1usize << (OP_NOT_LONG - 166)) | (1usize << (OP_NEG_FLOAT - 166)) | (1usize << (OP_NEG_DOUBLE - 166)) | (1usize << (OP_INT_TO_LONG - 166)) | (1usize << (OP_INT_TO_FLOAT - 166)) | (1usize << (OP_INT_TO_DOUBLE - 166)) | (1usize << (OP_LONG_TO_INT - 166)) | (1usize << (OP_LONG_TO_FLOAT - 166)) | (1usize << (OP_LONG_TO_DOUBLE - 166)) | (1usize << (OP_FLOAT_TO_INT - 166)) | (1usize << (OP_FLOAT_TO_LONG - 166)) | (1usize << (OP_FLOAT_TO_DOUBLE - 166)) | (1usize << (OP_DOUBLE_TO_INT - 166)))) != 0) || ((((_la - 198)) & !0x3f) == 0 && ((1usize << (_la - 198)) & ((1usize << (OP_DOUBLE_TO_LONG - 198)) | (1usize << (OP_DOUBLE_TO_FLOAT - 198)) | (1usize << (OP_INT_TO_BYTE - 198)) | (1usize << (OP_INT_TO_CHAR - 198)) | (1usize << (OP_INT_TO_SHORT - 198)) | (1usize << (OP_ADD_INT - 198)) | (1usize << (OP_SUB_INT - 198)) | (1usize << (OP_MUL_INT - 198)) | (1usize << (OP_DIV_INT - 198)) | (1usize << (OP_REM_INT - 198)) | (1usize << (OP_AND_INT - 198)) | (1usize << (OP_OR_INT - 198)) | (1usize << (OP_XOR_INT - 198)) | (1usize << (OP_SHL_INT - 198)) | (1usize << (OP_SHR_INT - 198)) | (1usize << (OP_USHR_INT - 198)) | (1usize << (OP_ADD_LONG - 198)) | (1usize << (OP_SUB_LONG - 198)) | (1usize << (OP_MUL_LONG - 198)) | (1usize << (OP_DIV_LONG - 198)) | (1usize << (OP_REM_LONG - 198)) | (1usize << (OP_AND_LONG - 198)) | (1usize << (OP_OR_LONG - 198)) | (1usize << (OP_XOR_LONG - 198)) | (1usize << (OP_SHL_LONG - 198)) | (1usize << (OP_SHR_LONG - 198)) | (1usize << (OP_USHR_LONG - 198)) | (1usize << (OP_ADD_FLOAT - 198)) | (1usize << (OP_SUB_FLOAT - 198)) | (1usize << (OP_MUL_FLOAT - 198)) | (1usize << (OP_DIV_FLOAT - 198)) | (1usize << (OP_REM_FLOAT - 198)))) != 0) || ((((_la - 230)) & !0x3f) == 0 && ((1usize << (_la - 230)) & ((1usize << (OP_ADD_DOUBLE - 230)) | (1usize << (OP_SUB_DOUBLE - 230)) | (1usize << (OP_MUL_DOUBLE - 230)) | (1usize << (OP_DIV_DOUBLE - 230)) | (1usize << (OP_REM_DOUBLE - 230)) | (1usize << (OP_ADD_INT_2ADDR - 230)) | (1usize << (OP_SUB_INT_2ADDR - 230)) | (1usize << (OP_MUL_INT_2ADDR - 230)) | (1usize << (OP_DIV_INT_2ADDR - 230)) | (1usize << (OP_REM_INT_2ADDR - 230)) | (1usize << (OP_AND_INT_2ADDR - 230)) | (1usize << (OP_OR_INT_2ADDR - 230)) | (1usize << (OP_XOR_INT_2ADDR - 230)) | (1usize << (OP_SHL_INT_2ADDR - 230)) | (1usize << (OP_SHR_INT_2ADDR - 230)) | (1usize << (OP_USHR_INT_2ADDR - 230)) | (1usize << (OP_ADD_LONG_2ADDR - 230)) | (1usize << (OP_SUB_LONG_2ADDR - 230)) | (1usize << (OP_MUL_LONG_2ADDR - 230)) | (1usize << (OP_DIV_LONG_2ADDR - 230)) | (1usize << (OP_REM_LONG_2ADDR - 230)) | (1usize << (OP_AND_LONG_2ADDR - 230)) | (1usize << (OP_OR_LONG_2ADDR - 230)) | (1usize << (OP_XOR_LONG_2ADDR - 230)) | (1usize << (OP_SHL_LONG_2ADDR - 230)) | (1usize << (OP_SHR_LONG_2ADDR - 230)) | (1usize << (OP_USHR_LONG_2ADDR - 230)) | (1usize << (OP_ADD_FLOAT_2ADDR - 230)) | (1usize << (OP_SUB_FLOAT_2ADDR - 230)) | (1usize << (OP_MUL_FLOAT_2ADDR - 230)) | (1usize << (OP_DIV_FLOAT_2ADDR - 230)) | (1usize << (OP_REM_FLOAT_2ADDR - 230)))) != 0) || ((((_la - 262)) & !0x3f) == 0 && ((1usize << (_la - 262)) & ((1usize << (OP_ADD_DOUBLE_2ADDR - 262)) | (1usize << (OP_SUB_DOUBLE_2ADDR - 262)) | (1usize << (OP_MUL_DOUBLE_2ADDR - 262)) | (1usize << (OP_DIV_DOUBLE_2ADDR - 262)) | (1usize << (OP_REM_DOUBLE_2ADDR - 262)) | (1usize << (OP_ADD_INT_LIT16 - 262)) | (1usize << (OP_RSUB_INT - 262)) | (1usize << (OP_MUL_INT_LIT16 - 262)) | (1usize << (OP_DIV_INT_LIT16 - 262)) | (1usize << (OP_REM_INT_LIT16 - 262)) | (1usize << (OP_AND_INT_LIT16 - 262)) | (1usize << (OP_OR_INT_LIT16 - 262)) | (1usize << (OP_XOR_INT_LIT16 - 262)) | (1usize << (OP_ADD_INT_LIT8 - 262)) | (1usize << (OP_RSUB_INT_LIT8 - 262)) | (1usize << (OP_MUL_INT_LIT8 - 262)) | (1usize << (OP_DIV_INT_LIT8 - 262)) | (1usize << (OP_REM_INT_LIT8 - 262)) | (1usize << (OP_AND_INT_LIT8 - 262)) | (1usize << (OP_OR_INT_LIT8 - 262)) | (1usize << (OP_XOR_INT_LIT8 - 262)) | (1usize << (OP_SHL_INT_LIT8 - 262)) | (1usize << (OP_SHR_INT_LIT8 - 262)) | (1usize << (OP_USHR_INT_LIT8 - 262)) | (1usize << (OP_INVOKE_POLYMORPHIC - 262)) | (1usize << (OP_INVOKE_POLYMORPHIC_RANGE - 262)) | (1usize << (OP_INVOKE_CUSTOM - 262)) | (1usize << (OP_INVOKE_CUSTOM_RANGE - 262)) | (1usize << (OP_CONST_METHOD_HANDLE - 262)) | (1usize << (OP_CONST_METHOD_TYPE - 262)) | (1usize << (OP_PACKED_SWITCH - 262)) | (1usize << (OP_SPARSE_SWITCH - 262)))) != 0)) {break}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- packedSwitchIdent ----------------
pub type PackedSwitchIdentContextAll<'input> = PackedSwitchIdentContext<'input>;


pub type PackedSwitchIdentContext<'input> = BaseParserRuleContext<'input,PackedSwitchIdentContextExt<'input>>;

#[derive(Clone)]
pub struct PackedSwitchIdentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for PackedSwitchIdentContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for PackedSwitchIdentContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_packedSwitchIdent(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_packedSwitchIdent(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PackedSwitchIdentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_packedSwitchIdent }
	//fn type_rule_index() -> usize where Self: Sized { RULE_packedSwitchIdent }
}
antlr_rust::tid!{PackedSwitchIdentContextExt<'a>}

impl<'input> PackedSwitchIdentContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PackedSwitchIdentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PackedSwitchIdentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PackedSwitchIdentContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<PackedSwitchIdentContextExt<'input>>{

fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PackedSwitchIdentContextAttrs<'input> for PackedSwitchIdentContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn packedSwitchIdent(&mut self,)
	-> Result<Rc<PackedSwitchIdentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PackedSwitchIdentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 646, RULE_packedSwitchIdent);
        let mut _localctx: Rc<PackedSwitchIdentContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule numericLiteral*/
			recog.base.set_state(2529);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- packedSwitchDirectiveLabel ----------------
pub type PackedSwitchDirectiveLabelContextAll<'input> = PackedSwitchDirectiveLabelContext<'input>;


pub type PackedSwitchDirectiveLabelContext<'input> = BaseParserRuleContext<'input,PackedSwitchDirectiveLabelContextExt<'input>>;

#[derive(Clone)]
pub struct PackedSwitchDirectiveLabelContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for PackedSwitchDirectiveLabelContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for PackedSwitchDirectiveLabelContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_packedSwitchDirectiveLabel(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_packedSwitchDirectiveLabel(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PackedSwitchDirectiveLabelContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_packedSwitchDirectiveLabel }
	//fn type_rule_index() -> usize where Self: Sized { RULE_packedSwitchDirectiveLabel }
}
antlr_rust::tid!{PackedSwitchDirectiveLabelContextExt<'a>}

impl<'input> PackedSwitchDirectiveLabelContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PackedSwitchDirectiveLabelContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PackedSwitchDirectiveLabelContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PackedSwitchDirectiveLabelContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<PackedSwitchDirectiveLabelContextExt<'input>>{

fn label(&self) -> Option<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PackedSwitchDirectiveLabelContextAttrs<'input> for PackedSwitchDirectiveLabelContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn packedSwitchDirectiveLabel(&mut self,)
	-> Result<Rc<PackedSwitchDirectiveLabelContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PackedSwitchDirectiveLabelContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 648, RULE_packedSwitchDirectiveLabel);
        let mut _localctx: Rc<PackedSwitchDirectiveLabelContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule label*/
			recog.base.set_state(2531);
			recog.label()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- packedSwitchDirectiveLabels ----------------
pub type PackedSwitchDirectiveLabelsContextAll<'input> = PackedSwitchDirectiveLabelsContext<'input>;


pub type PackedSwitchDirectiveLabelsContext<'input> = BaseParserRuleContext<'input,PackedSwitchDirectiveLabelsContextExt<'input>>;

#[derive(Clone)]
pub struct PackedSwitchDirectiveLabelsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for PackedSwitchDirectiveLabelsContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for PackedSwitchDirectiveLabelsContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_packedSwitchDirectiveLabels(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_packedSwitchDirectiveLabels(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PackedSwitchDirectiveLabelsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_packedSwitchDirectiveLabels }
	//fn type_rule_index() -> usize where Self: Sized { RULE_packedSwitchDirectiveLabels }
}
antlr_rust::tid!{PackedSwitchDirectiveLabelsContextExt<'a>}

impl<'input> PackedSwitchDirectiveLabelsContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PackedSwitchDirectiveLabelsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PackedSwitchDirectiveLabelsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PackedSwitchDirectiveLabelsContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<PackedSwitchDirectiveLabelsContextExt<'input>>{

fn packedSwitchDirectiveLabel_all(&self) ->  Vec<Rc<PackedSwitchDirectiveLabelContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn packedSwitchDirectiveLabel(&self, i: usize) -> Option<Rc<PackedSwitchDirectiveLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> PackedSwitchDirectiveLabelsContextAttrs<'input> for PackedSwitchDirectiveLabelsContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn packedSwitchDirectiveLabels(&mut self,)
	-> Result<Rc<PackedSwitchDirectiveLabelsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PackedSwitchDirectiveLabelsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 650, RULE_packedSwitchDirectiveLabels);
        let mut _localctx: Rc<PackedSwitchDirectiveLabelsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2534); 
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			loop {
				{
				{
				/*InvokeRule packedSwitchDirectiveLabel*/
				recog.base.set_state(2533);
				recog.packedSwitchDirectiveLabel()?;

				}
				}
				recog.base.set_state(2536); 
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if !(_la==COLON) {break}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- packedSwitchDirective ----------------
pub type PackedSwitchDirectiveContextAll<'input> = PackedSwitchDirectiveContext<'input>;


pub type PackedSwitchDirectiveContext<'input> = BaseParserRuleContext<'input,PackedSwitchDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct PackedSwitchDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for PackedSwitchDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for PackedSwitchDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_packedSwitchDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_packedSwitchDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for PackedSwitchDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_packedSwitchDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_packedSwitchDirective }
}
antlr_rust::tid!{PackedSwitchDirectiveContextExt<'a>}

impl<'input> PackedSwitchDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PackedSwitchDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PackedSwitchDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PackedSwitchDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<PackedSwitchDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token PACKED_SWITCH_DIRECTIVE
/// Returns `None` if there is no child corresponding to token PACKED_SWITCH_DIRECTIVE
fn PACKED_SWITCH_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(PACKED_SWITCH_DIRECTIVE, 0)
}
fn packedSwitchIdent(&self) -> Option<Rc<PackedSwitchIdentContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PACKED_SWITCH_END_DIRECTIVE
/// Returns `None` if there is no child corresponding to token PACKED_SWITCH_END_DIRECTIVE
fn PACKED_SWITCH_END_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(PACKED_SWITCH_END_DIRECTIVE, 0)
}
fn packedSwitchDirectiveLabels(&self) -> Option<Rc<PackedSwitchDirectiveLabelsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PackedSwitchDirectiveContextAttrs<'input> for PackedSwitchDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn packedSwitchDirective(&mut self,)
	-> Result<Rc<PackedSwitchDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PackedSwitchDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 652, RULE_packedSwitchDirective);
        let mut _localctx: Rc<PackedSwitchDirectiveContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2538);
			recog.base.match_token(PACKED_SWITCH_DIRECTIVE,&mut recog.err_handler)?;

			/*InvokeRule packedSwitchIdent*/
			recog.base.set_state(2539);
			recog.packedSwitchIdent()?;

			recog.base.set_state(2541);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COLON {
				{
				/*InvokeRule packedSwitchDirectiveLabels*/
				recog.base.set_state(2540);
				recog.packedSwitchDirectiveLabels()?;

				}
			}

			recog.base.set_state(2543);
			recog.base.match_token(PACKED_SWITCH_END_DIRECTIVE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- methodDirective ----------------
pub type MethodDirectiveContextAll<'input> = MethodDirectiveContext<'input>;


pub type MethodDirectiveContext<'input> = BaseParserRuleContext<'input,MethodDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct MethodDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for MethodDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for MethodDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_methodDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_methodDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for MethodDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_methodDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_methodDirective }
}
antlr_rust::tid!{MethodDirectiveContextExt<'a>}

impl<'input> MethodDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MethodDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MethodDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MethodDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<MethodDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token METHOD_DIRECTIVE
/// Returns `None` if there is no child corresponding to token METHOD_DIRECTIVE
fn METHOD_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(METHOD_DIRECTIVE, 0)
}
fn methodDeclaration(&self) -> Option<Rc<MethodDeclarationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token METHOD_END_DIRECTIVE
/// Returns `None` if there is no child corresponding to token METHOD_END_DIRECTIVE
fn METHOD_END_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(METHOD_END_DIRECTIVE, 0)
}
fn methodBody(&self) -> Option<Rc<MethodBodyContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MethodDirectiveContextAttrs<'input> for MethodDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn methodDirective(&mut self,)
	-> Result<Rc<MethodDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MethodDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 654, RULE_methodDirective);
        let mut _localctx: Rc<MethodDirectiveContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2545);
			recog.base.match_token(METHOD_DIRECTIVE,&mut recog.err_handler)?;

			/*InvokeRule methodDeclaration*/
			recog.base.set_state(2546);
			recog.methodDeclaration()?;

			recog.base.set_state(2548);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if ((((_la - 18)) & !0x3f) == 0 && ((1usize << (_la - 18)) & ((1usize << (COLON - 18)) | (1usize << (REGISTERS_DIRECTIVE - 18)) | (1usize << (LOCALS_DIRECTIVE - 18)) | (1usize << (PARAM_DIRECTIVE - 18)) | (1usize << (LINE_DIRECTIVE - 18)) | (1usize << (CATCH_DIRECTIVE - 18)) | (1usize << (CATCHALL_DIRECTIVE - 18)) | (1usize << (ANNOTATION_DIRECTIVE - 18)) | (1usize << (LOCAL_DIRECTIVE - 18)) | (1usize << (LOCAL_END_DIRECTIVE - 18)) | (1usize << (RESTART_LOCAL_DIRECTIVE - 18)) | (1usize << (PACKED_SWITCH_DIRECTIVE - 18)) | (1usize << (ARRAY_DATA_DIRECTIVE - 18)) | (1usize << (SPARSE_SWITCH_DIRECTIVE - 18)))) != 0) || ((((_la - 70)) & !0x3f) == 0 && ((1usize << (_la - 70)) & ((1usize << (OP_NOP - 70)) | (1usize << (OP_MOVE - 70)) | (1usize << (OP_MOVE_FROM16 - 70)) | (1usize << (OP_MOVE_16 - 70)) | (1usize << (OP_MOVE_WIDE - 70)) | (1usize << (OP_MOVE_WIDE_FROM16 - 70)) | (1usize << (OP_MOVE_WIDE_16 - 70)) | (1usize << (OP_MOVE_OBJECT - 70)) | (1usize << (OP_MOVE_OBJECT_FROM16 - 70)) | (1usize << (OP_MOVE_OBJECT_16 - 70)) | (1usize << (OP_MOVE_RESULT - 70)) | (1usize << (OP_MOVE_RESULT_WIDE - 70)) | (1usize << (OP_MOVE_RESULT_OBJECT - 70)) | (1usize << (OP_MOVE_EXCEPTION - 70)) | (1usize << (OP_RETURN_VOID - 70)) | (1usize << (OP_RETURN - 70)) | (1usize << (OP_RETURN_WIDE - 70)) | (1usize << (OP_RETURN_OBJECT - 70)) | (1usize << (OP_CONST_4 - 70)) | (1usize << (OP_CONST_16 - 70)) | (1usize << (OP_CONST - 70)) | (1usize << (OP_CONST_HIGH16 - 70)) | (1usize << (OP_CONST_WIDE_16 - 70)) | (1usize << (OP_CONST_WIDE_32 - 70)) | (1usize << (OP_CONST_WIDE - 70)) | (1usize << (OP_CONST_WIDE_HIGH16 - 70)) | (1usize << (OP_CONST_STRING - 70)) | (1usize << (OP_CONST_STRING_JUMBO - 70)) | (1usize << (OP_CONST_CLASS - 70)) | (1usize << (OP_MONITOR_ENTER - 70)) | (1usize << (OP_MONITOR_EXIT - 70)) | (1usize << (OP_CHECK_CAST - 70)))) != 0) || ((((_la - 102)) & !0x3f) == 0 && ((1usize << (_la - 102)) & ((1usize << (OP_INSTANCE_OF - 102)) | (1usize << (OP_ARRAY_LENGTH - 102)) | (1usize << (OP_NEW_INSTANCE - 102)) | (1usize << (OP_NEW_ARRAY - 102)) | (1usize << (OP_FILLED_NEW_ARRAY - 102)) | (1usize << (OP_FILLED_NEW_ARRAY_RANGE - 102)) | (1usize << (OP_FILL_ARRAY_DATA - 102)) | (1usize << (OP_THROW - 102)) | (1usize << (OP_GOTO - 102)) | (1usize << (OP_GOTO_16 - 102)) | (1usize << (OP_GOTO_32 - 102)) | (1usize << (OP_CMPL_FLOAT - 102)) | (1usize << (OP_CMPG_FLOAT - 102)) | (1usize << (OP_CMPL_DOUBLE - 102)) | (1usize << (OP_CMPG_DOUBLE - 102)) | (1usize << (OP_CMP_LONG - 102)) | (1usize << (OP_IF_EQ - 102)) | (1usize << (OP_IF_NE - 102)) | (1usize << (OP_IF_LT - 102)) | (1usize << (OP_IF_GE - 102)) | (1usize << (OP_IF_GT - 102)) | (1usize << (OP_IF_LE - 102)) | (1usize << (OP_IF_EQZ - 102)) | (1usize << (OP_IF_NEZ - 102)) | (1usize << (OP_IF_LTZ - 102)) | (1usize << (OP_IF_GEZ - 102)) | (1usize << (OP_IF_GTZ - 102)) | (1usize << (OP_IF_LEZ - 102)) | (1usize << (OP_AGET - 102)) | (1usize << (OP_AGET_WIDE - 102)) | (1usize << (OP_AGET_OBJECT - 102)) | (1usize << (OP_AGET_BOOLEAN - 102)))) != 0) || ((((_la - 134)) & !0x3f) == 0 && ((1usize << (_la - 134)) & ((1usize << (OP_AGET_BYTE - 134)) | (1usize << (OP_AGET_CHAR - 134)) | (1usize << (OP_AGET_SHORT - 134)) | (1usize << (OP_APUT - 134)) | (1usize << (OP_APUT_WIDE - 134)) | (1usize << (OP_APUT_OBJECT - 134)) | (1usize << (OP_APUT_BOOLEAN - 134)) | (1usize << (OP_APUT_BYTE - 134)) | (1usize << (OP_APUT_CHAR - 134)) | (1usize << (OP_APUT_SHORT - 134)) | (1usize << (OP_IGET - 134)) | (1usize << (OP_IGET_WIDE - 134)) | (1usize << (OP_IGET_OBJECT - 134)) | (1usize << (OP_IGET_BOOLEAN - 134)) | (1usize << (OP_IGET_BYTE - 134)) | (1usize << (OP_IGET_CHAR - 134)) | (1usize << (OP_IGET_SHORT - 134)) | (1usize << (OP_IPUT - 134)) | (1usize << (OP_IPUT_WIDE - 134)) | (1usize << (OP_IPUT_OBJECT - 134)) | (1usize << (OP_IPUT_BOOLEAN - 134)) | (1usize << (OP_IPUT_BYTE - 134)) | (1usize << (OP_IPUT_CHAR - 134)) | (1usize << (OP_IPUT_SHORT - 134)) | (1usize << (OP_SGET - 134)) | (1usize << (OP_SGET_WIDE - 134)) | (1usize << (OP_SGET_OBJECT - 134)) | (1usize << (OP_SGET_BOOLEAN - 134)) | (1usize << (OP_SGET_BYTE - 134)) | (1usize << (OP_SGET_CHAR - 134)) | (1usize << (OP_SGET_SHORT - 134)) | (1usize << (OP_SPUT - 134)))) != 0) || ((((_la - 166)) & !0x3f) == 0 && ((1usize << (_la - 166)) & ((1usize << (OP_SPUT_WIDE - 166)) | (1usize << (OP_SPUT_OBJECT - 166)) | (1usize << (OP_SPUT_BOOLEAN - 166)) | (1usize << (OP_SPUT_BYTE - 166)) | (1usize << (OP_SPUT_CHAR - 166)) | (1usize << (OP_SPUT_SHORT - 166)) | (1usize << (OP_INVOKE_VIRTUAL - 166)) | (1usize << (OP_INVOKE_SUPER - 166)) | (1usize << (OP_INVOKE_DIRECT - 166)) | (1usize << (OP_INVOKE_STATIC - 166)) | (1usize << (OP_INVOKE_INTERFACE - 166)) | (1usize << (OP_INVOKE_VIRTUAL_RANGE - 166)) | (1usize << (OP_INVOKE_SUPER_RANGE - 166)) | (1usize << (OP_INVOKE_DIRECT_RANGE - 166)) | (1usize << (OP_INVOKE_STATIC_RANGE - 166)) | (1usize << (OP_INVOKE_INTERFACE_RANGE - 166)) | (1usize << (OP_NEG_INT - 166)) | (1usize << (OP_NOT_INT - 166)) | (1usize << (OP_NEG_LONG - 166)) | (1usize << (OP_NOT_LONG - 166)) | (1usize << (OP_NEG_FLOAT - 166)) | (1usize << (OP_NEG_DOUBLE - 166)) | (1usize << (OP_INT_TO_LONG - 166)) | (1usize << (OP_INT_TO_FLOAT - 166)) | (1usize << (OP_INT_TO_DOUBLE - 166)) | (1usize << (OP_LONG_TO_INT - 166)) | (1usize << (OP_LONG_TO_FLOAT - 166)) | (1usize << (OP_LONG_TO_DOUBLE - 166)) | (1usize << (OP_FLOAT_TO_INT - 166)) | (1usize << (OP_FLOAT_TO_LONG - 166)) | (1usize << (OP_FLOAT_TO_DOUBLE - 166)) | (1usize << (OP_DOUBLE_TO_INT - 166)))) != 0) || ((((_la - 198)) & !0x3f) == 0 && ((1usize << (_la - 198)) & ((1usize << (OP_DOUBLE_TO_LONG - 198)) | (1usize << (OP_DOUBLE_TO_FLOAT - 198)) | (1usize << (OP_INT_TO_BYTE - 198)) | (1usize << (OP_INT_TO_CHAR - 198)) | (1usize << (OP_INT_TO_SHORT - 198)) | (1usize << (OP_ADD_INT - 198)) | (1usize << (OP_SUB_INT - 198)) | (1usize << (OP_MUL_INT - 198)) | (1usize << (OP_DIV_INT - 198)) | (1usize << (OP_REM_INT - 198)) | (1usize << (OP_AND_INT - 198)) | (1usize << (OP_OR_INT - 198)) | (1usize << (OP_XOR_INT - 198)) | (1usize << (OP_SHL_INT - 198)) | (1usize << (OP_SHR_INT - 198)) | (1usize << (OP_USHR_INT - 198)) | (1usize << (OP_ADD_LONG - 198)) | (1usize << (OP_SUB_LONG - 198)) | (1usize << (OP_MUL_LONG - 198)) | (1usize << (OP_DIV_LONG - 198)) | (1usize << (OP_REM_LONG - 198)) | (1usize << (OP_AND_LONG - 198)) | (1usize << (OP_OR_LONG - 198)) | (1usize << (OP_XOR_LONG - 198)) | (1usize << (OP_SHL_LONG - 198)) | (1usize << (OP_SHR_LONG - 198)) | (1usize << (OP_USHR_LONG - 198)) | (1usize << (OP_ADD_FLOAT - 198)) | (1usize << (OP_SUB_FLOAT - 198)) | (1usize << (OP_MUL_FLOAT - 198)) | (1usize << (OP_DIV_FLOAT - 198)) | (1usize << (OP_REM_FLOAT - 198)))) != 0) || ((((_la - 230)) & !0x3f) == 0 && ((1usize << (_la - 230)) & ((1usize << (OP_ADD_DOUBLE - 230)) | (1usize << (OP_SUB_DOUBLE - 230)) | (1usize << (OP_MUL_DOUBLE - 230)) | (1usize << (OP_DIV_DOUBLE - 230)) | (1usize << (OP_REM_DOUBLE - 230)) | (1usize << (OP_ADD_INT_2ADDR - 230)) | (1usize << (OP_SUB_INT_2ADDR - 230)) | (1usize << (OP_MUL_INT_2ADDR - 230)) | (1usize << (OP_DIV_INT_2ADDR - 230)) | (1usize << (OP_REM_INT_2ADDR - 230)) | (1usize << (OP_AND_INT_2ADDR - 230)) | (1usize << (OP_OR_INT_2ADDR - 230)) | (1usize << (OP_XOR_INT_2ADDR - 230)) | (1usize << (OP_SHL_INT_2ADDR - 230)) | (1usize << (OP_SHR_INT_2ADDR - 230)) | (1usize << (OP_USHR_INT_2ADDR - 230)) | (1usize << (OP_ADD_LONG_2ADDR - 230)) | (1usize << (OP_SUB_LONG_2ADDR - 230)) | (1usize << (OP_MUL_LONG_2ADDR - 230)) | (1usize << (OP_DIV_LONG_2ADDR - 230)) | (1usize << (OP_REM_LONG_2ADDR - 230)) | (1usize << (OP_AND_LONG_2ADDR - 230)) | (1usize << (OP_OR_LONG_2ADDR - 230)) | (1usize << (OP_XOR_LONG_2ADDR - 230)) | (1usize << (OP_SHL_LONG_2ADDR - 230)) | (1usize << (OP_SHR_LONG_2ADDR - 230)) | (1usize << (OP_USHR_LONG_2ADDR - 230)) | (1usize << (OP_ADD_FLOAT_2ADDR - 230)) | (1usize << (OP_SUB_FLOAT_2ADDR - 230)) | (1usize << (OP_MUL_FLOAT_2ADDR - 230)) | (1usize << (OP_DIV_FLOAT_2ADDR - 230)) | (1usize << (OP_REM_FLOAT_2ADDR - 230)))) != 0) || ((((_la - 262)) & !0x3f) == 0 && ((1usize << (_la - 262)) & ((1usize << (OP_ADD_DOUBLE_2ADDR - 262)) | (1usize << (OP_SUB_DOUBLE_2ADDR - 262)) | (1usize << (OP_MUL_DOUBLE_2ADDR - 262)) | (1usize << (OP_DIV_DOUBLE_2ADDR - 262)) | (1usize << (OP_REM_DOUBLE_2ADDR - 262)) | (1usize << (OP_ADD_INT_LIT16 - 262)) | (1usize << (OP_RSUB_INT - 262)) | (1usize << (OP_MUL_INT_LIT16 - 262)) | (1usize << (OP_DIV_INT_LIT16 - 262)) | (1usize << (OP_REM_INT_LIT16 - 262)) | (1usize << (OP_AND_INT_LIT16 - 262)) | (1usize << (OP_OR_INT_LIT16 - 262)) | (1usize << (OP_XOR_INT_LIT16 - 262)) | (1usize << (OP_ADD_INT_LIT8 - 262)) | (1usize << (OP_RSUB_INT_LIT8 - 262)) | (1usize << (OP_MUL_INT_LIT8 - 262)) | (1usize << (OP_DIV_INT_LIT8 - 262)) | (1usize << (OP_REM_INT_LIT8 - 262)) | (1usize << (OP_AND_INT_LIT8 - 262)) | (1usize << (OP_OR_INT_LIT8 - 262)) | (1usize << (OP_XOR_INT_LIT8 - 262)) | (1usize << (OP_SHL_INT_LIT8 - 262)) | (1usize << (OP_SHR_INT_LIT8 - 262)) | (1usize << (OP_USHR_INT_LIT8 - 262)) | (1usize << (OP_INVOKE_POLYMORPHIC - 262)) | (1usize << (OP_INVOKE_POLYMORPHIC_RANGE - 262)) | (1usize << (OP_INVOKE_CUSTOM - 262)) | (1usize << (OP_INVOKE_CUSTOM_RANGE - 262)) | (1usize << (OP_CONST_METHOD_HANDLE - 262)) | (1usize << (OP_CONST_METHOD_TYPE - 262)) | (1usize << (OP_PACKED_SWITCH - 262)) | (1usize << (OP_SPARSE_SWITCH - 262)))) != 0) {
				{
				/*InvokeRule methodBody*/
				recog.base.set_state(2547);
				recog.methodBody()?;

				}
			}

			recog.base.set_state(2550);
			recog.base.match_token(METHOD_END_DIRECTIVE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- registersDirective ----------------
pub type RegistersDirectiveContextAll<'input> = RegistersDirectiveContext<'input>;


pub type RegistersDirectiveContext<'input> = BaseParserRuleContext<'input,RegistersDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct RegistersDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for RegistersDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for RegistersDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_registersDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_registersDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for RegistersDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_registersDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_registersDirective }
}
antlr_rust::tid!{RegistersDirectiveContextExt<'a>}

impl<'input> RegistersDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RegistersDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RegistersDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RegistersDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<RegistersDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token REGISTERS_DIRECTIVE
/// Returns `None` if there is no child corresponding to token REGISTERS_DIRECTIVE
fn REGISTERS_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(REGISTERS_DIRECTIVE, 0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RegistersDirectiveContextAttrs<'input> for RegistersDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn registersDirective(&mut self,)
	-> Result<Rc<RegistersDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RegistersDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 656, RULE_registersDirective);
        let mut _localctx: Rc<RegistersDirectiveContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2552);
			recog.base.match_token(REGISTERS_DIRECTIVE,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(2553);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- localsDirective ----------------
pub type LocalsDirectiveContextAll<'input> = LocalsDirectiveContext<'input>;


pub type LocalsDirectiveContext<'input> = BaseParserRuleContext<'input,LocalsDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct LocalsDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for LocalsDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for LocalsDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_localsDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_localsDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LocalsDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_localsDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_localsDirective }
}
antlr_rust::tid!{LocalsDirectiveContextExt<'a>}

impl<'input> LocalsDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LocalsDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LocalsDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LocalsDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<LocalsDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LOCALS_DIRECTIVE
/// Returns `None` if there is no child corresponding to token LOCALS_DIRECTIVE
fn LOCALS_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(LOCALS_DIRECTIVE, 0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LocalsDirectiveContextAttrs<'input> for LocalsDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn localsDirective(&mut self,)
	-> Result<Rc<LocalsDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LocalsDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 658, RULE_localsDirective);
        let mut _localctx: Rc<LocalsDirectiveContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2555);
			recog.base.match_token(LOCALS_DIRECTIVE,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(2556);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- simpleParamDirective ----------------
pub type SimpleParamDirectiveContextAll<'input> = SimpleParamDirectiveContext<'input>;


pub type SimpleParamDirectiveContext<'input> = BaseParserRuleContext<'input,SimpleParamDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct SimpleParamDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SimpleParamDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SimpleParamDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_simpleParamDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_simpleParamDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SimpleParamDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_simpleParamDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_simpleParamDirective }
}
antlr_rust::tid!{SimpleParamDirectiveContextExt<'a>}

impl<'input> SimpleParamDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SimpleParamDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SimpleParamDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SimpleParamDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SimpleParamDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}
fn stringLiteral(&self) -> Option<Rc<StringLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SimpleParamDirectiveContextAttrs<'input> for SimpleParamDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn simpleParamDirective(&mut self,)
	-> Result<Rc<SimpleParamDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SimpleParamDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 660, RULE_simpleParamDirective);
        let mut _localctx: Rc<SimpleParamDirectiveContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2558);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule stringLiteral*/
			recog.base.set_state(2559);
			recog.stringLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- extendedParamDirective ----------------
pub type ExtendedParamDirectiveContextAll<'input> = ExtendedParamDirectiveContext<'input>;


pub type ExtendedParamDirectiveContext<'input> = BaseParserRuleContext<'input,ExtendedParamDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct ExtendedParamDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ExtendedParamDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ExtendedParamDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_extendedParamDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_extendedParamDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ExtendedParamDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_extendedParamDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_extendedParamDirective }
}
antlr_rust::tid!{ExtendedParamDirectiveContextExt<'a>}

impl<'input> ExtendedParamDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExtendedParamDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExtendedParamDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExtendedParamDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ExtendedParamDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token PARAM_END_DIRECTIVE
/// Returns `None` if there is no child corresponding to token PARAM_END_DIRECTIVE
fn PARAM_END_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(PARAM_END_DIRECTIVE, 0)
}
fn annotationDirective_all(&self) ->  Vec<Rc<AnnotationDirectiveContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn annotationDirective(&self, i: usize) -> Option<Rc<AnnotationDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ExtendedParamDirectiveContextAttrs<'input> for ExtendedParamDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn extendedParamDirective(&mut self,)
	-> Result<Rc<ExtendedParamDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExtendedParamDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 662, RULE_extendedParamDirective);
        let mut _localctx: Rc<ExtendedParamDirectiveContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2564);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==ANNOTATION_DIRECTIVE {
				{
				{
				/*InvokeRule annotationDirective*/
				recog.base.set_state(2561);
				recog.annotationDirective()?;

				}
				}
				recog.base.set_state(2566);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2567);
			recog.base.match_token(PARAM_END_DIRECTIVE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- paramDirective ----------------
pub type ParamDirectiveContextAll<'input> = ParamDirectiveContext<'input>;


pub type ParamDirectiveContext<'input> = BaseParserRuleContext<'input,ParamDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct ParamDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ParamDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ParamDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_paramDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_paramDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ParamDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_paramDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_paramDirective }
}
antlr_rust::tid!{ParamDirectiveContextExt<'a>}

impl<'input> ParamDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParamDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParamDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParamDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ParamDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token PARAM_DIRECTIVE
/// Returns `None` if there is no child corresponding to token PARAM_DIRECTIVE
fn PARAM_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(PARAM_DIRECTIVE, 0)
}
fn registerIdentifier(&self) -> Option<Rc<RegisterIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn extendedParamDirective(&self) -> Option<Rc<ExtendedParamDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn simpleParamDirective(&self) -> Option<Rc<SimpleParamDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ParamDirectiveContextAttrs<'input> for ParamDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn paramDirective(&mut self,)
	-> Result<Rc<ParamDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParamDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 664, RULE_paramDirective);
        let mut _localctx: Rc<ParamDirectiveContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2569);
			recog.base.match_token(PARAM_DIRECTIVE,&mut recog.err_handler)?;

			/*InvokeRule registerIdentifier*/
			recog.base.set_state(2570);
			recog.registerIdentifier()?;

			recog.base.set_state(2573);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 ANNOTATION_DIRECTIVE | PARAM_END_DIRECTIVE 
				=> {
					{
					/*InvokeRule extendedParamDirective*/
					recog.base.set_state(2571);
					recog.extendedParamDirective()?;

					}
				}

			 COMMA 
				=> {
					{
					/*InvokeRule simpleParamDirective*/
					recog.base.set_state(2572);
					recog.simpleParamDirective()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- lineDirective ----------------
pub type LineDirectiveContextAll<'input> = LineDirectiveContext<'input>;


pub type LineDirectiveContext<'input> = BaseParserRuleContext<'input,LineDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct LineDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for LineDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for LineDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_lineDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_lineDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for LineDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_lineDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_lineDirective }
}
antlr_rust::tid!{LineDirectiveContextExt<'a>}

impl<'input> LineDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LineDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LineDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LineDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<LineDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LINE_DIRECTIVE
/// Returns `None` if there is no child corresponding to token LINE_DIRECTIVE
fn LINE_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(LINE_DIRECTIVE, 0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LineDirectiveContextAttrs<'input> for LineDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn lineDirective(&mut self,)
	-> Result<Rc<LineDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LineDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 666, RULE_lineDirective);
        let mut _localctx: Rc<LineDirectiveContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2575);
			recog.base.match_token(LINE_DIRECTIVE,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(2576);
			recog.numericLiteral()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- catchFromLabel ----------------
pub type CatchFromLabelContextAll<'input> = CatchFromLabelContext<'input>;


pub type CatchFromLabelContext<'input> = BaseParserRuleContext<'input,CatchFromLabelContextExt<'input>>;

#[derive(Clone)]
pub struct CatchFromLabelContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for CatchFromLabelContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for CatchFromLabelContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_catchFromLabel(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_catchFromLabel(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CatchFromLabelContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_catchFromLabel }
	//fn type_rule_index() -> usize where Self: Sized { RULE_catchFromLabel }
}
antlr_rust::tid!{CatchFromLabelContextExt<'a>}

impl<'input> CatchFromLabelContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CatchFromLabelContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CatchFromLabelContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CatchFromLabelContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<CatchFromLabelContextExt<'input>>{

fn label(&self) -> Option<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CatchFromLabelContextAttrs<'input> for CatchFromLabelContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn catchFromLabel(&mut self,)
	-> Result<Rc<CatchFromLabelContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CatchFromLabelContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 668, RULE_catchFromLabel);
        let mut _localctx: Rc<CatchFromLabelContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule label*/
			recog.base.set_state(2578);
			recog.label()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- catchToLabel ----------------
pub type CatchToLabelContextAll<'input> = CatchToLabelContext<'input>;


pub type CatchToLabelContext<'input> = BaseParserRuleContext<'input,CatchToLabelContextExt<'input>>;

#[derive(Clone)]
pub struct CatchToLabelContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for CatchToLabelContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for CatchToLabelContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_catchToLabel(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_catchToLabel(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CatchToLabelContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_catchToLabel }
	//fn type_rule_index() -> usize where Self: Sized { RULE_catchToLabel }
}
antlr_rust::tid!{CatchToLabelContextExt<'a>}

impl<'input> CatchToLabelContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CatchToLabelContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CatchToLabelContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CatchToLabelContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<CatchToLabelContextExt<'input>>{

fn label(&self) -> Option<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CatchToLabelContextAttrs<'input> for CatchToLabelContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn catchToLabel(&mut self,)
	-> Result<Rc<CatchToLabelContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CatchToLabelContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 670, RULE_catchToLabel);
        let mut _localctx: Rc<CatchToLabelContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule label*/
			recog.base.set_state(2580);
			recog.label()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- catchGotoLabel ----------------
pub type CatchGotoLabelContextAll<'input> = CatchGotoLabelContext<'input>;


pub type CatchGotoLabelContext<'input> = BaseParserRuleContext<'input,CatchGotoLabelContextExt<'input>>;

#[derive(Clone)]
pub struct CatchGotoLabelContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for CatchGotoLabelContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for CatchGotoLabelContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_catchGotoLabel(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_catchGotoLabel(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CatchGotoLabelContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_catchGotoLabel }
	//fn type_rule_index() -> usize where Self: Sized { RULE_catchGotoLabel }
}
antlr_rust::tid!{CatchGotoLabelContextExt<'a>}

impl<'input> CatchGotoLabelContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CatchGotoLabelContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CatchGotoLabelContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CatchGotoLabelContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<CatchGotoLabelContextExt<'input>>{

fn label(&self) -> Option<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CatchGotoLabelContextAttrs<'input> for CatchGotoLabelContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn catchGotoLabel(&mut self,)
	-> Result<Rc<CatchGotoLabelContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CatchGotoLabelContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 672, RULE_catchGotoLabel);
        let mut _localctx: Rc<CatchGotoLabelContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule label*/
			recog.base.set_state(2582);
			recog.label()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- catchExceptionType ----------------
pub type CatchExceptionTypeContextAll<'input> = CatchExceptionTypeContext<'input>;


pub type CatchExceptionTypeContext<'input> = BaseParserRuleContext<'input,CatchExceptionTypeContextExt<'input>>;

#[derive(Clone)]
pub struct CatchExceptionTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for CatchExceptionTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for CatchExceptionTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_catchExceptionType(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_catchExceptionType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CatchExceptionTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_catchExceptionType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_catchExceptionType }
}
antlr_rust::tid!{CatchExceptionTypeContextExt<'a>}

impl<'input> CatchExceptionTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CatchExceptionTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CatchExceptionTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CatchExceptionTypeContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<CatchExceptionTypeContextExt<'input>>{

fn referenceType(&self) -> Option<Rc<ReferenceTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CatchExceptionTypeContextAttrs<'input> for CatchExceptionTypeContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn catchExceptionType(&mut self,)
	-> Result<Rc<CatchExceptionTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CatchExceptionTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 674, RULE_catchExceptionType);
        let mut _localctx: Rc<CatchExceptionTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule referenceType*/
			recog.base.set_state(2584);
			recog.referenceType()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- catchDirective ----------------
pub type CatchDirectiveContextAll<'input> = CatchDirectiveContext<'input>;


pub type CatchDirectiveContext<'input> = BaseParserRuleContext<'input,CatchDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct CatchDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for CatchDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for CatchDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_catchDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_catchDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CatchDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_catchDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_catchDirective }
}
antlr_rust::tid!{CatchDirectiveContextExt<'a>}

impl<'input> CatchDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CatchDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CatchDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CatchDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<CatchDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CATCH_DIRECTIVE
/// Returns `None` if there is no child corresponding to token CATCH_DIRECTIVE
fn CATCH_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(CATCH_DIRECTIVE, 0)
}
fn catchExceptionType(&self) -> Option<Rc<CatchExceptionTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
fn catchFromLabel(&self) -> Option<Rc<CatchFromLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}
fn catchToLabel(&self) -> Option<Rc<CatchToLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn catchGotoLabel(&self) -> Option<Rc<CatchGotoLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CatchDirectiveContextAttrs<'input> for CatchDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn catchDirective(&mut self,)
	-> Result<Rc<CatchDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CatchDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 676, RULE_catchDirective);
        let mut _localctx: Rc<CatchDirectiveContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2586);
			recog.base.match_token(CATCH_DIRECTIVE,&mut recog.err_handler)?;

			/*InvokeRule catchExceptionType*/
			recog.base.set_state(2587);
			recog.catchExceptionType()?;

			recog.base.set_state(2588);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			/*InvokeRule catchFromLabel*/
			recog.base.set_state(2589);
			recog.catchFromLabel()?;

			recog.base.set_state(2590);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			recog.base.set_state(2591);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			/*InvokeRule catchToLabel*/
			recog.base.set_state(2592);
			recog.catchToLabel()?;

			recog.base.set_state(2593);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			/*InvokeRule catchGotoLabel*/
			recog.base.set_state(2594);
			recog.catchGotoLabel()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- catchAllDirective ----------------
pub type CatchAllDirectiveContextAll<'input> = CatchAllDirectiveContext<'input>;


pub type CatchAllDirectiveContext<'input> = BaseParserRuleContext<'input,CatchAllDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct CatchAllDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for CatchAllDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for CatchAllDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_catchAllDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_catchAllDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for CatchAllDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_catchAllDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_catchAllDirective }
}
antlr_rust::tid!{CatchAllDirectiveContextExt<'a>}

impl<'input> CatchAllDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CatchAllDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CatchAllDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CatchAllDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<CatchAllDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CATCHALL_DIRECTIVE
/// Returns `None` if there is no child corresponding to token CATCHALL_DIRECTIVE
fn CATCHALL_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(CATCHALL_DIRECTIVE, 0)
}
/// Retrieves first TerminalNode corresponding to token LBRACE
/// Returns `None` if there is no child corresponding to token LBRACE
fn LBRACE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(LBRACE, 0)
}
fn catchFromLabel(&self) -> Option<Rc<CatchFromLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,SmaliParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(DOT, i)
}
fn catchToLabel(&self) -> Option<Rc<CatchToLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RBRACE
/// Returns `None` if there is no child corresponding to token RBRACE
fn RBRACE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(RBRACE, 0)
}
fn catchGotoLabel(&self) -> Option<Rc<CatchGotoLabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CatchAllDirectiveContextAttrs<'input> for CatchAllDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn catchAllDirective(&mut self,)
	-> Result<Rc<CatchAllDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CatchAllDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 678, RULE_catchAllDirective);
        let mut _localctx: Rc<CatchAllDirectiveContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2596);
			recog.base.match_token(CATCHALL_DIRECTIVE,&mut recog.err_handler)?;

			recog.base.set_state(2597);
			recog.base.match_token(LBRACE,&mut recog.err_handler)?;

			/*InvokeRule catchFromLabel*/
			recog.base.set_state(2598);
			recog.catchFromLabel()?;

			recog.base.set_state(2599);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			recog.base.set_state(2600);
			recog.base.match_token(DOT,&mut recog.err_handler)?;

			/*InvokeRule catchToLabel*/
			recog.base.set_state(2601);
			recog.catchToLabel()?;

			recog.base.set_state(2602);
			recog.base.match_token(RBRACE,&mut recog.err_handler)?;

			/*InvokeRule catchGotoLabel*/
			recog.base.set_state(2603);
			recog.catchGotoLabel()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayDataDirective ----------------
pub type ArrayDataDirectiveContextAll<'input> = ArrayDataDirectiveContext<'input>;


pub type ArrayDataDirectiveContext<'input> = BaseParserRuleContext<'input,ArrayDataDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayDataDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ArrayDataDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ArrayDataDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayDataDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_arrayDataDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ArrayDataDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayDataDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayDataDirective }
}
antlr_rust::tid!{ArrayDataDirectiveContextExt<'a>}

impl<'input> ArrayDataDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayDataDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayDataDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayDataDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ArrayDataDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ARRAY_DATA_DIRECTIVE
/// Returns `None` if there is no child corresponding to token ARRAY_DATA_DIRECTIVE
fn ARRAY_DATA_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(ARRAY_DATA_DIRECTIVE, 0)
}
fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ARRAY_DATA_END_DIRECTIVE
/// Returns `None` if there is no child corresponding to token ARRAY_DATA_END_DIRECTIVE
fn ARRAY_DATA_END_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(ARRAY_DATA_END_DIRECTIVE, 0)
}
fn arrayDataEntry_all(&self) ->  Vec<Rc<ArrayDataEntryContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn arrayDataEntry(&self, i: usize) -> Option<Rc<ArrayDataEntryContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ArrayDataDirectiveContextAttrs<'input> for ArrayDataDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayDataDirective(&mut self,)
	-> Result<Rc<ArrayDataDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayDataDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 680, RULE_arrayDataDirective);
        let mut _localctx: Rc<ArrayDataDirectiveContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2605);
			recog.base.match_token(ARRAY_DATA_DIRECTIVE,&mut recog.err_handler)?;

			/*InvokeRule numericLiteral*/
			recog.base.set_state(2606);
			recog.numericLiteral()?;

			recog.base.set_state(2610);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==SUB || ((((_la - 294)) & !0x3f) == 0 && ((1usize << (_la - 294)) & ((1usize << (DECIMAL_LITERAL - 294)) | (1usize << (HEX_LITERAL - 294)) | (1usize << (OCT_LITERAL - 294)) | (1usize << (BINARY_LITERAL - 294)) | (1usize << (FLOAT_LITERAL - 294)) | (1usize << (HEX_FLOAT_LITERAL - 294)))) != 0) {
				{
				{
				/*InvokeRule arrayDataEntry*/
				recog.base.set_state(2607);
				recog.arrayDataEntry()?;

				}
				}
				recog.base.set_state(2612);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2613);
			recog.base.match_token(ARRAY_DATA_END_DIRECTIVE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- arrayDataEntry ----------------
pub type ArrayDataEntryContextAll<'input> = ArrayDataEntryContext<'input>;


pub type ArrayDataEntryContext<'input> = BaseParserRuleContext<'input,ArrayDataEntryContextExt<'input>>;

#[derive(Clone)]
pub struct ArrayDataEntryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ArrayDataEntryContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ArrayDataEntryContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_arrayDataEntry(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_arrayDataEntry(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ArrayDataEntryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_arrayDataEntry }
	//fn type_rule_index() -> usize where Self: Sized { RULE_arrayDataEntry }
}
antlr_rust::tid!{ArrayDataEntryContextExt<'a>}

impl<'input> ArrayDataEntryContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ArrayDataEntryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ArrayDataEntryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ArrayDataEntryContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ArrayDataEntryContextExt<'input>>{

fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token IDENTIFIER
/// Returns `None` if there is no child corresponding to token IDENTIFIER
fn IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(IDENTIFIER, 0)
}

}

impl<'input> ArrayDataEntryContextAttrs<'input> for ArrayDataEntryContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn arrayDataEntry(&mut self,)
	-> Result<Rc<ArrayDataEntryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ArrayDataEntryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 682, RULE_arrayDataEntry);
        let mut _localctx: Rc<ArrayDataEntryContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule numericLiteral*/
			recog.base.set_state(2615);
			recog.numericLiteral()?;

			recog.base.set_state(2617);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==IDENTIFIER {
				{
				recog.base.set_state(2616);
				recog.base.match_token(IDENTIFIER,&mut recog.err_handler)?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sparseSwitchDirectiveValue ----------------
pub type SparseSwitchDirectiveValueContextAll<'input> = SparseSwitchDirectiveValueContext<'input>;


pub type SparseSwitchDirectiveValueContext<'input> = BaseParserRuleContext<'input,SparseSwitchDirectiveValueContextExt<'input>>;

#[derive(Clone)]
pub struct SparseSwitchDirectiveValueContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SparseSwitchDirectiveValueContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SparseSwitchDirectiveValueContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sparseSwitchDirectiveValue(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sparseSwitchDirectiveValue(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SparseSwitchDirectiveValueContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sparseSwitchDirectiveValue }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sparseSwitchDirectiveValue }
}
antlr_rust::tid!{SparseSwitchDirectiveValueContextExt<'a>}

impl<'input> SparseSwitchDirectiveValueContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SparseSwitchDirectiveValueContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SparseSwitchDirectiveValueContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SparseSwitchDirectiveValueContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SparseSwitchDirectiveValueContextExt<'input>>{

fn numericLiteral(&self) -> Option<Rc<NumericLiteralContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ARROW
/// Returns `None` if there is no child corresponding to token ARROW
fn ARROW(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(ARROW, 0)
}
fn label(&self) -> Option<Rc<LabelContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SparseSwitchDirectiveValueContextAttrs<'input> for SparseSwitchDirectiveValueContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sparseSwitchDirectiveValue(&mut self,)
	-> Result<Rc<SparseSwitchDirectiveValueContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SparseSwitchDirectiveValueContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 684, RULE_sparseSwitchDirectiveValue);
        let mut _localctx: Rc<SparseSwitchDirectiveValueContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule numericLiteral*/
			recog.base.set_state(2619);
			recog.numericLiteral()?;

			recog.base.set_state(2620);
			recog.base.match_token(ARROW,&mut recog.err_handler)?;

			/*InvokeRule label*/
			recog.base.set_state(2621);
			recog.label()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sparseSwitchDirective ----------------
pub type SparseSwitchDirectiveContextAll<'input> = SparseSwitchDirectiveContext<'input>;


pub type SparseSwitchDirectiveContext<'input> = BaseParserRuleContext<'input,SparseSwitchDirectiveContextExt<'input>>;

#[derive(Clone)]
pub struct SparseSwitchDirectiveContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for SparseSwitchDirectiveContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for SparseSwitchDirectiveContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sparseSwitchDirective(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_sparseSwitchDirective(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for SparseSwitchDirectiveContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sparseSwitchDirective }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sparseSwitchDirective }
}
antlr_rust::tid!{SparseSwitchDirectiveContextExt<'a>}

impl<'input> SparseSwitchDirectiveContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SparseSwitchDirectiveContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SparseSwitchDirectiveContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SparseSwitchDirectiveContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<SparseSwitchDirectiveContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SPARSE_SWITCH_DIRECTIVE
/// Returns `None` if there is no child corresponding to token SPARSE_SWITCH_DIRECTIVE
fn SPARSE_SWITCH_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(SPARSE_SWITCH_DIRECTIVE, 0)
}
/// Retrieves first TerminalNode corresponding to token SPARSE_SWITCH_END_DIRECTIVE
/// Returns `None` if there is no child corresponding to token SPARSE_SWITCH_END_DIRECTIVE
fn SPARSE_SWITCH_END_DIRECTIVE(&self) -> Option<Rc<TerminalNode<'input,SmaliParserContextType>>> where Self:Sized{
	self.get_token(SPARSE_SWITCH_END_DIRECTIVE, 0)
}
fn sparseSwitchDirectiveValue_all(&self) ->  Vec<Rc<SparseSwitchDirectiveValueContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn sparseSwitchDirectiveValue(&self, i: usize) -> Option<Rc<SparseSwitchDirectiveValueContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> SparseSwitchDirectiveContextAttrs<'input> for SparseSwitchDirectiveContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sparseSwitchDirective(&mut self,)
	-> Result<Rc<SparseSwitchDirectiveContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SparseSwitchDirectiveContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 686, RULE_sparseSwitchDirective);
        let mut _localctx: Rc<SparseSwitchDirectiveContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2623);
			recog.base.match_token(SPARSE_SWITCH_DIRECTIVE,&mut recog.err_handler)?;

			recog.base.set_state(2627);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==SUB || ((((_la - 294)) & !0x3f) == 0 && ((1usize << (_la - 294)) & ((1usize << (DECIMAL_LITERAL - 294)) | (1usize << (HEX_LITERAL - 294)) | (1usize << (OCT_LITERAL - 294)) | (1usize << (BINARY_LITERAL - 294)) | (1usize << (FLOAT_LITERAL - 294)) | (1usize << (HEX_FLOAT_LITERAL - 294)))) != 0) {
				{
				{
				/*InvokeRule sparseSwitchDirectiveValue*/
				recog.base.set_state(2624);
				recog.sparseSwitchDirectiveValue()?;

				}
				}
				recog.base.set_state(2629);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(2630);
			recog.base.match_token(SPARSE_SWITCH_END_DIRECTIVE,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- statement ----------------
pub type StatementContextAll<'input> = StatementContext<'input>;


pub type StatementContext<'input> = BaseParserRuleContext<'input,StatementContextExt<'input>>;

#[derive(Clone)]
pub struct StatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for StatementContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for StatementContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_statement(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_statement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for StatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}
antlr_rust::tid!{StatementContextExt<'a>}

impl<'input> StatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StatementContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<StatementContextExt<'input>>{

fn classDirective(&self) -> Option<Rc<ClassDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn superDirective(&self) -> Option<Rc<SuperDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sourceDirective(&self) -> Option<Rc<SourceDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn fieldDirective(&self) -> Option<Rc<FieldDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn methodDirective(&self) -> Option<Rc<MethodDirectiveContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> StatementContextAttrs<'input> for StatementContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn statement(&mut self,)
	-> Result<Rc<StatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 688, RULE_statement);
        let mut _localctx: Rc<StatementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2637);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 CLASS_DIRECTIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule classDirective*/
					recog.base.set_state(2632);
					recog.classDirective()?;

					}
				}

			 SUPER_DIRECTIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule superDirective*/
					recog.base.set_state(2633);
					recog.superDirective()?;

					}
				}

			 SOURCE_DIRECTIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule sourceDirective*/
					recog.base.set_state(2634);
					recog.sourceDirective()?;

					}
				}

			 FIELD_DIRECTIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule fieldDirective*/
					recog.base.set_state(2635);
					recog.fieldDirective()?;

					}
				}

			 METHOD_DIRECTIVE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					/*InvokeRule methodDirective*/
					recog.base.set_state(2636);
					recog.methodDirective()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- parse ----------------
pub type ParseContextAll<'input> = ParseContext<'input>;


pub type ParseContext<'input> = BaseParserRuleContext<'input,ParseContextExt<'input>>;

#[derive(Clone)]
pub struct ParseContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SmaliParserContext<'input> for ParseContext<'input>{}

impl<'input,'a> Listenable<dyn SmaliParserListener<'input> + 'a> for ParseContext<'input>{
		fn enter(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_parse(self);
		}fn exit(&self,listener: &mut (dyn SmaliParserListener<'input> + 'a)) {
			listener.exit_parse(self);
			listener.exit_every_rule(self);
		}
}

impl<'input> CustomRuleContext<'input> for ParseContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SmaliParserContextType;
	fn get_rule_index(&self) -> usize { RULE_parse }
	//fn type_rule_index() -> usize where Self: Sized { RULE_parse }
}
antlr_rust::tid!{ParseContextExt<'a>}

impl<'input> ParseContextExt<'input>{
	fn new(parent: Option<Rc<dyn SmaliParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ParseContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ParseContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ParseContextAttrs<'input>: SmaliParserContext<'input> + BorrowMut<ParseContextExt<'input>>{

fn statement_all(&self) ->  Vec<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn statement(&self, i: usize) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> ParseContextAttrs<'input> for ParseContext<'input>{}

impl<'input, I, H> SmaliParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn parse(&mut self,)
	-> Result<Rc<ParseContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ParseContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 690, RULE_parse);
        let mut _localctx: Rc<ParseContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2640); 
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			loop {
				{
				{
				/*InvokeRule statement*/
				recog.base.set_state(2639);
				recog.statement()?;

				}
				}
				recog.base.set_state(2642); 
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if !(((((_la - 28)) & !0x3f) == 0 && ((1usize << (_la - 28)) & ((1usize << (METHOD_DIRECTIVE - 28)) | (1usize << (CLASS_DIRECTIVE - 28)) | (1usize << (SOURCE_DIRECTIVE - 28)) | (1usize << (SUPER_DIRECTIVE - 28)) | (1usize << (FIELD_DIRECTIVE - 28)))) != 0)) {break}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}

lazy_static! {
    static ref _ATN: Arc<ATN> =
        Arc::new(ATNDeserializer::new(None).deserialize(_serializedATN.chars()));
    static ref _decision_to_DFA: Arc<Vec<antlr_rust::RwLock<DFA>>> = {
        let mut dfa = Vec::new();
        let size = _ATN.decision_to_state.len();
        for i in 0..size {
            dfa.push(DFA::new(
                _ATN.clone(),
                _ATN.get_decision_state(i),
                i as isize,
            ).into())
        }
        Arc::new(dfa)
    };
}



const _serializedATN:&'static str =
	"\x03\u{608b}\u{a72a}\u{8133}\u{b9ed}\u{417c}\u{3be7}\u{7786}\u{5964}\x03\
	\u{134}\u{a57}\x04\x02\x09\x02\x04\x03\x09\x03\x04\x04\x09\x04\x04\x05\x09\
	\x05\x04\x06\x09\x06\x04\x07\x09\x07\x04\x08\x09\x08\x04\x09\x09\x09\x04\
	\x0a\x09\x0a\x04\x0b\x09\x0b\x04\x0c\x09\x0c\x04\x0d\x09\x0d\x04\x0e\x09\
	\x0e\x04\x0f\x09\x0f\x04\x10\x09\x10\x04\x11\x09\x11\x04\x12\x09\x12\x04\
	\x13\x09\x13\x04\x14\x09\x14\x04\x15\x09\x15\x04\x16\x09\x16\x04\x17\x09\
	\x17\x04\x18\x09\x18\x04\x19\x09\x19\x04\x1a\x09\x1a\x04\x1b\x09\x1b\x04\
	\x1c\x09\x1c\x04\x1d\x09\x1d\x04\x1e\x09\x1e\x04\x1f\x09\x1f\x04\x20\x09\
	\x20\x04\x21\x09\x21\x04\x22\x09\x22\x04\x23\x09\x23\x04\x24\x09\x24\x04\
	\x25\x09\x25\x04\x26\x09\x26\x04\x27\x09\x27\x04\x28\x09\x28\x04\x29\x09\
	\x29\x04\x2a\x09\x2a\x04\x2b\x09\x2b\x04\x2c\x09\x2c\x04\x2d\x09\x2d\x04\
	\x2e\x09\x2e\x04\x2f\x09\x2f\x04\x30\x09\x30\x04\x31\x09\x31\x04\x32\x09\
	\x32\x04\x33\x09\x33\x04\x34\x09\x34\x04\x35\x09\x35\x04\x36\x09\x36\x04\
	\x37\x09\x37\x04\x38\x09\x38\x04\x39\x09\x39\x04\x3a\x09\x3a\x04\x3b\x09\
	\x3b\x04\x3c\x09\x3c\x04\x3d\x09\x3d\x04\x3e\x09\x3e\x04\x3f\x09\x3f\x04\
	\x40\x09\x40\x04\x41\x09\x41\x04\x42\x09\x42\x04\x43\x09\x43\x04\x44\x09\
	\x44\x04\x45\x09\x45\x04\x46\x09\x46\x04\x47\x09\x47\x04\x48\x09\x48\x04\
	\x49\x09\x49\x04\x4a\x09\x4a\x04\x4b\x09\x4b\x04\x4c\x09\x4c\x04\x4d\x09\
	\x4d\x04\x4e\x09\x4e\x04\x4f\x09\x4f\x04\x50\x09\x50\x04\x51\x09\x51\x04\
	\x52\x09\x52\x04\x53\x09\x53\x04\x54\x09\x54\x04\x55\x09\x55\x04\x56\x09\
	\x56\x04\x57\x09\x57\x04\x58\x09\x58\x04\x59\x09\x59\x04\x5a\x09\x5a\x04\
	\x5b\x09\x5b\x04\x5c\x09\x5c\x04\x5d\x09\x5d\x04\x5e\x09\x5e\x04\x5f\x09\
	\x5f\x04\x60\x09\x60\x04\x61\x09\x61\x04\x62\x09\x62\x04\x63\x09\x63\x04\
	\x64\x09\x64\x04\x65\x09\x65\x04\x66\x09\x66\x04\x67\x09\x67\x04\x68\x09\
	\x68\x04\x69\x09\x69\x04\x6a\x09\x6a\x04\x6b\x09\x6b\x04\x6c\x09\x6c\x04\
	\x6d\x09\x6d\x04\x6e\x09\x6e\x04\x6f\x09\x6f\x04\x70\x09\x70\x04\x71\x09\
	\x71\x04\x72\x09\x72\x04\x73\x09\x73\x04\x74\x09\x74\x04\x75\x09\x75\x04\
	\x76\x09\x76\x04\x77\x09\x77\x04\x78\x09\x78\x04\x79\x09\x79\x04\x7a\x09\
	\x7a\x04\x7b\x09\x7b\x04\x7c\x09\x7c\x04\x7d\x09\x7d\x04\x7e\x09\x7e\x04\
	\x7f\x09\x7f\x04\u{80}\x09\u{80}\x04\u{81}\x09\u{81}\x04\u{82}\x09\u{82}\
	\x04\u{83}\x09\u{83}\x04\u{84}\x09\u{84}\x04\u{85}\x09\u{85}\x04\u{86}\x09\
	\u{86}\x04\u{87}\x09\u{87}\x04\u{88}\x09\u{88}\x04\u{89}\x09\u{89}\x04\u{8a}\
	\x09\u{8a}\x04\u{8b}\x09\u{8b}\x04\u{8c}\x09\u{8c}\x04\u{8d}\x09\u{8d}\x04\
	\u{8e}\x09\u{8e}\x04\u{8f}\x09\u{8f}\x04\u{90}\x09\u{90}\x04\u{91}\x09\u{91}\
	\x04\u{92}\x09\u{92}\x04\u{93}\x09\u{93}\x04\u{94}\x09\u{94}\x04\u{95}\x09\
	\u{95}\x04\u{96}\x09\u{96}\x04\u{97}\x09\u{97}\x04\u{98}\x09\u{98}\x04\u{99}\
	\x09\u{99}\x04\u{9a}\x09\u{9a}\x04\u{9b}\x09\u{9b}\x04\u{9c}\x09\u{9c}\x04\
	\u{9d}\x09\u{9d}\x04\u{9e}\x09\u{9e}\x04\u{9f}\x09\u{9f}\x04\u{a0}\x09\u{a0}\
	\x04\u{a1}\x09\u{a1}\x04\u{a2}\x09\u{a2}\x04\u{a3}\x09\u{a3}\x04\u{a4}\x09\
	\u{a4}\x04\u{a5}\x09\u{a5}\x04\u{a6}\x09\u{a6}\x04\u{a7}\x09\u{a7}\x04\u{a8}\
	\x09\u{a8}\x04\u{a9}\x09\u{a9}\x04\u{aa}\x09\u{aa}\x04\u{ab}\x09\u{ab}\x04\
	\u{ac}\x09\u{ac}\x04\u{ad}\x09\u{ad}\x04\u{ae}\x09\u{ae}\x04\u{af}\x09\u{af}\
	\x04\u{b0}\x09\u{b0}\x04\u{b1}\x09\u{b1}\x04\u{b2}\x09\u{b2}\x04\u{b3}\x09\
	\u{b3}\x04\u{b4}\x09\u{b4}\x04\u{b5}\x09\u{b5}\x04\u{b6}\x09\u{b6}\x04\u{b7}\
	\x09\u{b7}\x04\u{b8}\x09\u{b8}\x04\u{b9}\x09\u{b9}\x04\u{ba}\x09\u{ba}\x04\
	\u{bb}\x09\u{bb}\x04\u{bc}\x09\u{bc}\x04\u{bd}\x09\u{bd}\x04\u{be}\x09\u{be}\
	\x04\u{bf}\x09\u{bf}\x04\u{c0}\x09\u{c0}\x04\u{c1}\x09\u{c1}\x04\u{c2}\x09\
	\u{c2}\x04\u{c3}\x09\u{c3}\x04\u{c4}\x09\u{c4}\x04\u{c5}\x09\u{c5}\x04\u{c6}\
	\x09\u{c6}\x04\u{c7}\x09\u{c7}\x04\u{c8}\x09\u{c8}\x04\u{c9}\x09\u{c9}\x04\
	\u{ca}\x09\u{ca}\x04\u{cb}\x09\u{cb}\x04\u{cc}\x09\u{cc}\x04\u{cd}\x09\u{cd}\
	\x04\u{ce}\x09\u{ce}\x04\u{cf}\x09\u{cf}\x04\u{d0}\x09\u{d0}\x04\u{d1}\x09\
	\u{d1}\x04\u{d2}\x09\u{d2}\x04\u{d3}\x09\u{d3}\x04\u{d4}\x09\u{d4}\x04\u{d5}\
	\x09\u{d5}\x04\u{d6}\x09\u{d6}\x04\u{d7}\x09\u{d7}\x04\u{d8}\x09\u{d8}\x04\
	\u{d9}\x09\u{d9}\x04\u{da}\x09\u{da}\x04\u{db}\x09\u{db}\x04\u{dc}\x09\u{dc}\
	\x04\u{dd}\x09\u{dd}\x04\u{de}\x09\u{de}\x04\u{df}\x09\u{df}\x04\u{e0}\x09\
	\u{e0}\x04\u{e1}\x09\u{e1}\x04\u{e2}\x09\u{e2}\x04\u{e3}\x09\u{e3}\x04\u{e4}\
	\x09\u{e4}\x04\u{e5}\x09\u{e5}\x04\u{e6}\x09\u{e6}\x04\u{e7}\x09\u{e7}\x04\
	\u{e8}\x09\u{e8}\x04\u{e9}\x09\u{e9}\x04\u{ea}\x09\u{ea}\x04\u{eb}\x09\u{eb}\
	\x04\u{ec}\x09\u{ec}\x04\u{ed}\x09\u{ed}\x04\u{ee}\x09\u{ee}\x04\u{ef}\x09\
	\u{ef}\x04\u{f0}\x09\u{f0}\x04\u{f1}\x09\u{f1}\x04\u{f2}\x09\u{f2}\x04\u{f3}\
	\x09\u{f3}\x04\u{f4}\x09\u{f4}\x04\u{f5}\x09\u{f5}\x04\u{f6}\x09\u{f6}\x04\
	\u{f7}\x09\u{f7}\x04\u{f8}\x09\u{f8}\x04\u{f9}\x09\u{f9}\x04\u{fa}\x09\u{fa}\
	\x04\u{fb}\x09\u{fb}\x04\u{fc}\x09\u{fc}\x04\u{fd}\x09\u{fd}\x04\u{fe}\x09\
	\u{fe}\x04\u{ff}\x09\u{ff}\x04\u{100}\x09\u{100}\x04\u{101}\x09\u{101}\x04\
	\u{102}\x09\u{102}\x04\u{103}\x09\u{103}\x04\u{104}\x09\u{104}\x04\u{105}\
	\x09\u{105}\x04\u{106}\x09\u{106}\x04\u{107}\x09\u{107}\x04\u{108}\x09\u{108}\
	\x04\u{109}\x09\u{109}\x04\u{10a}\x09\u{10a}\x04\u{10b}\x09\u{10b}\x04\u{10c}\
	\x09\u{10c}\x04\u{10d}\x09\u{10d}\x04\u{10e}\x09\u{10e}\x04\u{10f}\x09\u{10f}\
	\x04\u{110}\x09\u{110}\x04\u{111}\x09\u{111}\x04\u{112}\x09\u{112}\x04\u{113}\
	\x09\u{113}\x04\u{114}\x09\u{114}\x04\u{115}\x09\u{115}\x04\u{116}\x09\u{116}\
	\x04\u{117}\x09\u{117}\x04\u{118}\x09\u{118}\x04\u{119}\x09\u{119}\x04\u{11a}\
	\x09\u{11a}\x04\u{11b}\x09\u{11b}\x04\u{11c}\x09\u{11c}\x04\u{11d}\x09\u{11d}\
	\x04\u{11e}\x09\u{11e}\x04\u{11f}\x09\u{11f}\x04\u{120}\x09\u{120}\x04\u{121}\
	\x09\u{121}\x04\u{122}\x09\u{122}\x04\u{123}\x09\u{123}\x04\u{124}\x09\u{124}\
	\x04\u{125}\x09\u{125}\x04\u{126}\x09\u{126}\x04\u{127}\x09\u{127}\x04\u{128}\
	\x09\u{128}\x04\u{129}\x09\u{129}\x04\u{12a}\x09\u{12a}\x04\u{12b}\x09\u{12b}\
	\x04\u{12c}\x09\u{12c}\x04\u{12d}\x09\u{12d}\x04\u{12e}\x09\u{12e}\x04\u{12f}\
	\x09\u{12f}\x04\u{130}\x09\u{130}\x04\u{131}\x09\u{131}\x04\u{132}\x09\u{132}\
	\x04\u{133}\x09\u{133}\x04\u{134}\x09\u{134}\x04\u{135}\x09\u{135}\x04\u{136}\
	\x09\u{136}\x04\u{137}\x09\u{137}\x04\u{138}\x09\u{138}\x04\u{139}\x09\u{139}\
	\x04\u{13a}\x09\u{13a}\x04\u{13b}\x09\u{13b}\x04\u{13c}\x09\u{13c}\x04\u{13d}\
	\x09\u{13d}\x04\u{13e}\x09\u{13e}\x04\u{13f}\x09\u{13f}\x04\u{140}\x09\u{140}\
	\x04\u{141}\x09\u{141}\x04\u{142}\x09\u{142}\x04\u{143}\x09\u{143}\x04\u{144}\
	\x09\u{144}\x04\u{145}\x09\u{145}\x04\u{146}\x09\u{146}\x04\u{147}\x09\u{147}\
	\x04\u{148}\x09\u{148}\x04\u{149}\x09\u{149}\x04\u{14a}\x09\u{14a}\x04\u{14b}\
	\x09\u{14b}\x04\u{14c}\x09\u{14c}\x04\u{14d}\x09\u{14d}\x04\u{14e}\x09\u{14e}\
	\x04\u{14f}\x09\u{14f}\x04\u{150}\x09\u{150}\x04\u{151}\x09\u{151}\x04\u{152}\
	\x09\u{152}\x04\u{153}\x09\u{153}\x04\u{154}\x09\u{154}\x04\u{155}\x09\u{155}\
	\x04\u{156}\x09\u{156}\x04\u{157}\x09\u{157}\x04\u{158}\x09\u{158}\x04\u{159}\
	\x09\u{159}\x04\u{15a}\x09\u{15a}\x04\u{15b}\x09\u{15b}\x03\x02\x03\x02\
	\x03\x03\x03\x03\x03\x04\x03\x04\x03\x04\x03\x05\x03\x05\x03\x06\x03\x06\
	\x03\x07\x03\x07\x03\x08\x03\x08\x03\x09\x03\x09\x03\x0a\x03\x0a\x03\x0b\
	\x03\x0b\x03\x0b\x03\x0b\x03\x0b\x03\x0b\x05\x0b\u{2d0}\x0a\x0b\x03\x0c\
	\x03\x0c\x05\x0c\u{2d4}\x0a\x0c\x03\x0d\x06\x0d\u{2d7}\x0a\x0d\x0d\x0d\x0e\
	\x0d\u{2d8}\x03\x0e\x03\x0e\x03\x0f\x03\x0f\x03\x10\x03\x10\x03\x11\x03\
	\x11\x03\x12\x03\x12\x03\x13\x03\x13\x03\x14\x03\x14\x03\x15\x03\x15\x03\
	\x16\x03\x16\x03\x17\x03\x17\x03\x18\x03\x18\x03\x18\x03\x18\x03\x18\x03\
	\x18\x03\x18\x03\x18\x05\x18\u{2f7}\x0a\x18\x03\x19\x03\x19\x05\x19\u{2fb}\
	\x0a\x19\x03\x1a\x03\x1a\x03\x1b\x03\x1b\x03\x1b\x03\x1b\x05\x1b\u{303}\
	\x0a\x1b\x03\x1c\x03\x1c\x05\x1c\u{307}\x0a\x1c\x03\x1d\x03\x1d\x05\x1d\
	\u{30b}\x0a\x1d\x03\x1e\x03\x1e\x03\x1e\x05\x1e\u{310}\x0a\x1e\x03\x1f\x03\
	\x1f\x03\x20\x03\x20\x03\x21\x03\x21\x03\x21\x03\x21\x03\x21\x05\x21\u{31b}\
	\x0a\x21\x03\x22\x03\x22\x03\x23\x03\x23\x03\x24\x03\x24\x03\x25\x03\x25\
	\x03\x26\x03\x26\x03\x26\x03\x27\x03\x27\x03\x28\x03\x28\x03\x29\x03\x29\
	\x03\x29\x07\x29\u{32f}\x0a\x29\x0c\x29\x0e\x29\u{332}\x0b\x29\x03\x2a\x03\
	\x2a\x03\x2a\x03\x2a\x03\x2a\x03\x2a\x03\x2a\x03\x2b\x03\x2b\x03\x2b\x03\
	\x2b\x03\x2b\x03\x2b\x05\x2b\u{341}\x0a\x2b\x03\x2c\x03\x2c\x03\x2c\x03\
	\x2d\x03\x2d\x03\x2d\x03\x2e\x03\x2e\x03\x2e\x03\x2f\x03\x2f\x03\x2f\x03\
	\x30\x03\x30\x03\x30\x03\x31\x03\x31\x03\x31\x03\x32\x03\x32\x03\x32\x03\
	\x33\x03\x33\x03\x33\x03\x34\x03\x34\x03\x34\x03\x35\x03\x35\x03\x35\x03\
	\x36\x03\x36\x03\x36\x03\x37\x03\x37\x03\x37\x03\x38\x03\x38\x03\x38\x03\
	\x39\x03\x39\x03\x3a\x03\x3a\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\x3b\x03\
	\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3c\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\
	\x3d\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3e\x03\x3f\x03\x3f\x03\x3f\x03\
	\x3f\x03\x3f\x03\x40\x03\x40\x03\x40\x03\x40\x03\x40\x03\x41\x03\x41\x03\
	\x41\x03\x41\x03\x41\x03\x42\x03\x42\x03\x42\x03\x42\x03\x42\x03\x43\x03\
	\x43\x03\x43\x03\x43\x03\x43\x03\x44\x03\x44\x03\x44\x03\x44\x03\x44\x03\
	\x45\x03\x45\x03\x45\x03\x45\x03\x45\x03\x46\x03\x46\x03\x46\x03\x46\x03\
	\x46\x03\x47\x03\x47\x03\x47\x03\x47\x03\x47\x03\x48\x03\x48\x03\x48\x03\
	\x48\x03\x48\x03\x49\x03\x49\x03\x49\x03\x49\x03\x49\x03\x4a\x03\x4a\x03\
	\x4a\x03\x4a\x03\x4a\x03\x4b\x03\x4b\x03\x4b\x03\x4b\x03\x4b\x03\x4c\x03\
	\x4c\x03\x4c\x03\x4c\x03\x4c\x03\x4d\x03\x4d\x03\x4d\x03\x4d\x03\x4d\x03\
	\x4e\x03\x4e\x03\x4e\x03\x4e\x03\x4e\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x03\
	\x4f\x03\x50\x03\x50\x03\x50\x03\x50\x03\x50\x03\x51\x03\x51\x03\x51\x03\
	\x51\x03\x51\x03\x52\x03\x52\x03\x52\x03\x52\x03\x52\x03\x53\x03\x53\x03\
	\x53\x03\x53\x03\x53\x03\x54\x03\x54\x03\x54\x03\x54\x03\x54\x03\x55\x03\
	\x55\x03\x55\x03\x55\x03\x55\x03\x56\x03\x56\x03\x56\x03\x56\x03\x56\x03\
	\x57\x03\x57\x03\x57\x03\x57\x03\x57\x03\x58\x03\x58\x03\x58\x03\x58\x03\
	\x58\x03\x59\x03\x59\x03\x59\x03\x59\x03\x59\x03\x5a\x03\x5a\x03\x5a\x03\
	\x5a\x03\x5a\x03\x5b\x03\x5b\x03\x5b\x03\x5b\x03\x5b\x03\x5c\x03\x5c\x03\
	\x5c\x03\x5c\x03\x5c\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5e\x03\
	\x5e\x03\x5e\x03\x5e\x03\x5e\x03\x5f\x03\x5f\x03\x5f\x03\x5f\x03\x5f\x03\
	\x60\x03\x60\x03\x60\x03\x60\x03\x60\x03\x61\x03\x61\x03\x61\x03\x61\x03\
	\x61\x03\x62\x03\x62\x03\x62\x03\x62\x03\x62\x03\x63\x03\x63\x03\x63\x03\
	\x63\x03\x63\x03\x64\x03\x64\x03\x64\x03\x64\x03\x64\x03\x65\x03\x65\x03\
	\x65\x03\x65\x03\x65\x03\x66\x03\x66\x03\x66\x03\x66\x03\x66\x03\x67\x03\
	\x67\x03\x67\x03\x67\x03\x67\x03\x68\x03\x68\x03\x68\x03\x68\x03\x68\x03\
	\x69\x03\x69\x03\x69\x03\x69\x03\x69\x03\x6a\x03\x6a\x03\x6a\x03\x6a\x03\
	\x6a\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x03\x6c\x03\x6c\x03\x6c\x03\
	\x6c\x03\x6c\x03\x6d\x03\x6d\x03\x6d\x03\x6d\x03\x6d\x03\x6e\x03\x6e\x03\
	\x6e\x03\x6e\x03\x6e\x03\x6f\x03\x6f\x03\x6f\x03\x6f\x03\x6f\x03\x70\x03\
	\x70\x03\x70\x03\x70\x03\x70\x03\x71\x03\x71\x03\x71\x03\x71\x03\x71\x03\
	\x72\x03\x72\x03\x72\x03\x72\x03\x72\x03\x73\x03\x73\x03\x73\x03\x73\x03\
	\x73\x03\x74\x03\x74\x03\x74\x03\x74\x03\x74\x03\x75\x03\x75\x03\x75\x03\
	\x75\x03\x75\x03\x76\x03\x76\x03\x77\x03\x77\x03\x77\x03\x77\x03\x77\x03\
	\x78\x03\x78\x03\x78\x03\x78\x03\x78\x03\x79\x03\x79\x03\x79\x03\x79\x03\
	\x79\x03\x7a\x03\x7a\x03\x7a\x03\x7a\x03\x7a\x03\x7b\x03\x7b\x03\x7b\x03\
	\x7b\x03\x7b\x03\x7c\x03\x7c\x03\x7c\x03\x7c\x03\x7c\x03\x7d\x03\x7d\x03\
	\x7d\x03\x7d\x03\x7d\x03\x7e\x03\x7e\x03\x7e\x03\x7e\x03\x7e\x03\x7f\x03\
	\x7f\x03\x7f\x03\x7f\x03\x7f\x03\u{80}\x03\u{80}\x03\u{80}\x03\u{80}\x03\
	\u{80}\x03\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x03\u{82}\x03\u{82}\
	\x03\u{82}\x03\u{82}\x03\u{82}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x03\u{83}\x03\u{84}\x03\u{84}\x03\u{84}\x03\u{84}\x03\u{84}\
	\x03\u{84}\x03\u{84}\x03\u{85}\x03\u{85}\x03\u{85}\x03\u{85}\x03\u{85}\x03\
	\u{85}\x03\u{85}\x03\u{86}\x03\u{86}\x03\u{86}\x03\u{86}\x03\u{86}\x03\u{86}\
	\x03\u{86}\x03\u{87}\x03\u{87}\x03\u{87}\x03\u{87}\x03\u{87}\x03\u{87}\x03\
	\u{87}\x03\u{88}\x03\u{88}\x03\u{88}\x03\u{88}\x03\u{88}\x03\u{88}\x03\u{88}\
	\x03\u{89}\x03\u{89}\x03\u{89}\x03\u{89}\x03\u{89}\x03\u{8a}\x03\u{8a}\x03\
	\u{8a}\x03\u{8a}\x03\u{8a}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8c}\x03\u{8c}\x03\u{8c}\x03\u{8c}\x03\u{8c}\x03\u{8d}\x03\u{8d}\x03\
	\u{8d}\x03\u{8d}\x03\u{8d}\x03\u{8e}\x03\u{8e}\x03\u{8e}\x03\u{8e}\x03\u{8e}\
	\x03\u{8f}\x03\u{8f}\x03\u{8f}\x03\u{8f}\x03\u{8f}\x03\u{90}\x03\u{90}\x03\
	\u{90}\x03\u{90}\x03\u{90}\x03\u{91}\x03\u{91}\x03\u{91}\x03\u{91}\x03\u{91}\
	\x03\u{92}\x03\u{92}\x03\u{92}\x03\u{92}\x03\u{92}\x03\u{93}\x03\u{93}\x03\
	\u{93}\x03\u{93}\x03\u{93}\x03\u{94}\x03\u{94}\x03\u{94}\x03\u{94}\x03\u{94}\
	\x03\u{95}\x03\u{95}\x03\u{95}\x03\u{95}\x03\u{95}\x03\u{96}\x03\u{96}\x03\
	\u{96}\x03\u{96}\x03\u{96}\x03\u{97}\x03\u{97}\x03\u{97}\x03\u{97}\x03\u{97}\
	\x03\u{98}\x03\u{98}\x03\u{98}\x03\u{98}\x03\u{98}\x03\u{99}\x03\u{99}\x03\
	\u{99}\x03\u{99}\x03\u{99}\x03\u{9a}\x03\u{9a}\x03\u{9a}\x03\u{9a}\x03\u{9a}\
	\x03\u{9b}\x03\u{9b}\x03\u{9b}\x03\u{9b}\x03\u{9b}\x03\u{9c}\x03\u{9c}\x03\
	\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9d}\x03\u{9d}\x03\u{9d}\x03\u{9d}\x03\u{9d}\
	\x03\u{9e}\x03\u{9e}\x03\u{9e}\x03\u{9e}\x03\u{9e}\x03\u{9f}\x03\u{9f}\x03\
	\u{9f}\x03\u{9f}\x03\u{9f}\x03\u{a0}\x03\u{a0}\x03\u{a0}\x03\u{a0}\x03\u{a0}\
	\x03\u{a1}\x03\u{a1}\x03\u{a1}\x03\u{a1}\x03\u{a1}\x03\u{a2}\x03\u{a2}\x03\
	\u{a2}\x03\u{a2}\x03\u{a2}\x03\u{a3}\x03\u{a3}\x03\u{a3}\x03\u{a3}\x03\u{a3}\
	\x03\u{a4}\x03\u{a4}\x03\u{a4}\x03\u{a4}\x03\u{a4}\x03\u{a5}\x03\u{a5}\x03\
	\u{a5}\x03\u{a5}\x03\u{a5}\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a6}\
	\x03\u{a7}\x03\u{a7}\x03\u{a7}\x03\u{a7}\x03\u{a7}\x03\u{a8}\x03\u{a8}\x03\
	\u{a8}\x03\u{a8}\x03\u{a8}\x03\u{a9}\x03\u{a9}\x03\u{a9}\x03\u{a9}\x03\u{a9}\
	\x03\u{a9}\x03\u{a9}\x03\u{aa}\x03\u{aa}\x03\u{aa}\x03\u{aa}\x03\u{aa}\x03\
	\u{aa}\x03\u{aa}\x03\u{ab}\x03\u{ab}\x03\u{ab}\x03\u{ab}\x03\u{ab}\x03\u{ab}\
	\x03\u{ab}\x03\u{ac}\x03\u{ac}\x03\u{ac}\x03\u{ac}\x03\u{ac}\x03\u{ac}\x03\
	\u{ac}\x03\u{ad}\x03\u{ad}\x03\u{ad}\x03\u{ad}\x03\u{ad}\x03\u{ad}\x03\u{ad}\
	\x03\u{ae}\x03\u{ae}\x03\u{af}\x03\u{af}\x03\u{b0}\x03\u{b0}\x03\u{b1}\x03\
	\u{b1}\x03\u{b2}\x03\u{b2}\x03\u{b3}\x03\u{b3}\x03\u{b4}\x03\u{b4}\x03\u{b5}\
	\x03\u{b5}\x03\u{b5}\x03\u{b5}\x03\u{b5}\x03\u{b5}\x03\u{b5}\x03\u{b6}\x03\
	\u{b6}\x03\u{b6}\x03\u{b6}\x03\u{b6}\x03\u{b6}\x03\u{b6}\x03\u{b7}\x03\u{b7}\
	\x03\u{b7}\x03\u{b7}\x03\u{b7}\x03\u{b7}\x03\u{b7}\x03\u{b8}\x03\u{b8}\x03\
	\u{b8}\x03\u{b8}\x03\u{b8}\x03\u{b8}\x03\u{b8}\x03\u{b9}\x03\u{b9}\x03\u{b9}\
	\x03\u{b9}\x03\u{b9}\x03\u{b9}\x03\u{b9}\x03\u{ba}\x03\u{ba}\x03\u{ba}\x03\
	\u{ba}\x03\u{ba}\x03\u{ba}\x03\u{ba}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\
	\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bc}\x03\u{bc}\x03\u{bc}\x03\u{bc}\x03\
	\u{bc}\x03\u{bc}\x03\u{bc}\x03\u{bd}\x03\u{bd}\x03\u{bd}\x03\u{bd}\x03\u{bd}\
	\x03\u{bd}\x03\u{bd}\x03\u{be}\x03\u{be}\x03\u{be}\x03\u{be}\x03\u{be}\x03\
	\u{be}\x03\u{be}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x03\u{bf}\
	\x03\u{bf}\x03\u{c0}\x03\u{c0}\x03\u{c0}\x03\u{c0}\x03\u{c0}\x03\u{c0}\x03\
	\u{c0}\x03\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c1}\x03\u{c1}\
	\x03\u{c2}\x03\u{c2}\x03\u{c2}\x03\u{c2}\x03\u{c2}\x03\u{c2}\x03\u{c2}\x03\
	\u{c3}\x03\u{c3}\x03\u{c3}\x03\u{c3}\x03\u{c3}\x03\u{c3}\x03\u{c3}\x03\u{c4}\
	\x03\u{c4}\x03\u{c4}\x03\u{c4}\x03\u{c4}\x03\u{c4}\x03\u{c4}\x03\u{c5}\x03\
	\u{c5}\x03\u{c5}\x03\u{c5}\x03\u{c5}\x03\u{c5}\x03\u{c5}\x03\u{c6}\x03\u{c6}\
	\x03\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c6}\x03\u{c7}\x03\u{c7}\x03\
	\u{c7}\x03\u{c7}\x03\u{c7}\x03\u{c7}\x03\u{c7}\x03\u{c8}\x03\u{c8}\x03\u{c8}\
	\x03\u{c8}\x03\u{c8}\x03\u{c8}\x03\u{c8}\x03\u{c9}\x03\u{c9}\x03\u{c9}\x03\
	\u{c9}\x03\u{c9}\x03\u{c9}\x03\u{c9}\x03\u{ca}\x03\u{ca}\x03\u{ca}\x03\u{ca}\
	\x03\u{ca}\x03\u{ca}\x03\u{ca}\x03\u{cb}\x03\u{cb}\x03\u{cb}\x03\u{cb}\x03\
	\u{cb}\x03\u{cb}\x03\u{cb}\x03\u{cc}\x03\u{cc}\x03\u{cc}\x03\u{cc}\x03\u{cc}\
	\x03\u{cc}\x03\u{cc}\x03\u{cd}\x03\u{cd}\x03\u{cd}\x03\u{cd}\x03\u{cd}\x03\
	\u{cd}\x03\u{cd}\x03\u{ce}\x03\u{ce}\x03\u{ce}\x03\u{ce}\x03\u{ce}\x03\u{ce}\
	\x03\u{ce}\x03\u{cf}\x03\u{cf}\x03\u{cf}\x03\u{cf}\x03\u{cf}\x03\u{cf}\x03\
	\u{cf}\x03\u{d0}\x03\u{d0}\x03\u{d0}\x03\u{d0}\x03\u{d0}\x03\u{d0}\x03\u{d0}\
	\x03\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x03\u{d1}\x03\
	\u{d2}\x03\u{d2}\x03\u{d2}\x03\u{d2}\x03\u{d2}\x03\u{d2}\x03\u{d2}\x03\u{d3}\
	\x03\u{d3}\x03\u{d3}\x03\u{d3}\x03\u{d3}\x03\u{d3}\x03\u{d3}\x03\u{d4}\x03\
	\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d4}\x03\u{d5}\x03\u{d5}\
	\x03\u{d5}\x03\u{d5}\x03\u{d5}\x03\u{d5}\x03\u{d5}\x03\u{d6}\x03\u{d6}\x03\
	\u{d6}\x03\u{d6}\x03\u{d6}\x03\u{d6}\x03\u{d6}\x03\u{d7}\x03\u{d7}\x03\u{d7}\
	\x03\u{d7}\x03\u{d7}\x03\u{d7}\x03\u{d7}\x03\u{d8}\x03\u{d8}\x03\u{d8}\x03\
	\u{d8}\x03\u{d8}\x03\u{d8}\x03\u{d8}\x03\u{d9}\x03\u{d9}\x03\u{d9}\x03\u{d9}\
	\x03\u{d9}\x03\u{d9}\x03\u{d9}\x03\u{da}\x03\u{da}\x03\u{da}\x03\u{da}\x03\
	\u{da}\x03\u{da}\x03\u{da}\x03\u{db}\x03\u{db}\x03\u{db}\x03\u{db}\x03\u{db}\
	\x03\u{db}\x03\u{db}\x03\u{dc}\x03\u{dc}\x03\u{dc}\x03\u{dc}\x03\u{dc}\x03\
	\u{dc}\x03\u{dc}\x03\u{dd}\x03\u{dd}\x03\u{dd}\x03\u{dd}\x03\u{dd}\x03\u{dd}\
	\x03\u{dd}\x03\u{de}\x03\u{de}\x03\u{de}\x03\u{de}\x03\u{de}\x03\u{de}\x03\
	\u{de}\x03\u{df}\x03\u{df}\x03\u{df}\x03\u{df}\x03\u{df}\x03\u{df}\x03\u{df}\
	\x03\u{e0}\x03\u{e0}\x03\u{e0}\x03\u{e0}\x03\u{e0}\x03\u{e0}\x03\u{e0}\x03\
	\u{e1}\x03\u{e1}\x03\u{e1}\x03\u{e1}\x03\u{e1}\x03\u{e1}\x03\u{e1}\x03\u{e2}\
	\x03\u{e2}\x03\u{e2}\x03\u{e2}\x03\u{e2}\x03\u{e2}\x03\u{e2}\x03\u{e3}\x03\
	\u{e3}\x03\u{e3}\x03\u{e3}\x03\u{e3}\x03\u{e3}\x03\u{e3}\x03\u{e4}\x03\u{e4}\
	\x03\u{e4}\x03\u{e4}\x03\u{e4}\x03\u{e4}\x03\u{e4}\x03\u{e5}\x03\u{e5}\x03\
	\u{e5}\x03\u{e5}\x03\u{e5}\x03\u{e5}\x03\u{e5}\x03\u{e6}\x03\u{e6}\x03\u{e6}\
	\x03\u{e6}\x03\u{e6}\x03\u{e6}\x03\u{e6}\x03\u{e7}\x03\u{e7}\x03\u{e7}\x03\
	\u{e7}\x03\u{e7}\x03\u{e7}\x03\u{e7}\x03\u{e8}\x03\u{e8}\x03\u{e8}\x03\u{e8}\
	\x03\u{e8}\x03\u{e8}\x03\u{e8}\x03\u{e9}\x03\u{e9}\x03\u{e9}\x03\u{e9}\x03\
	\u{e9}\x03\u{e9}\x03\u{e9}\x03\u{ea}\x03\u{ea}\x03\u{ea}\x03\u{ea}\x03\u{ea}\
	\x03\u{ea}\x03\u{ea}\x03\u{eb}\x03\u{eb}\x03\u{eb}\x03\u{eb}\x03\u{eb}\x03\
	\u{eb}\x03\u{eb}\x03\u{ec}\x03\u{ec}\x03\u{ec}\x03\u{ec}\x03\u{ec}\x03\u{ec}\
	\x03\u{ec}\x03\u{ed}\x03\u{ed}\x03\u{ed}\x03\u{ed}\x03\u{ed}\x03\u{ed}\x03\
	\u{ed}\x03\u{ee}\x03\u{ee}\x03\u{ee}\x03\u{ee}\x03\u{ee}\x03\u{ee}\x03\u{ee}\
	\x03\u{ef}\x03\u{ef}\x03\u{ef}\x03\u{ef}\x03\u{ef}\x03\u{ef}\x03\u{ef}\x03\
	\u{f0}\x03\u{f0}\x03\u{f0}\x03\u{f0}\x03\u{f0}\x03\u{f0}\x03\u{f0}\x03\u{f1}\
	\x03\u{f1}\x03\u{f1}\x03\u{f1}\x03\u{f1}\x03\u{f1}\x03\u{f1}\x03\u{f2}\x03\
	\u{f2}\x03\u{f2}\x03\u{f2}\x03\u{f2}\x03\u{f2}\x03\u{f2}\x03\u{f3}\x03\u{f3}\
	\x03\u{f3}\x03\u{f3}\x03\u{f3}\x03\u{f3}\x03\u{f3}\x03\u{f4}\x03\u{f4}\x03\
	\u{f4}\x03\u{f4}\x03\u{f4}\x03\u{f4}\x03\u{f4}\x03\u{f5}\x03\u{f5}\x03\u{f5}\
	\x03\u{f5}\x03\u{f5}\x03\u{f5}\x03\u{f5}\x03\u{f6}\x03\u{f6}\x03\u{f6}\x03\
	\u{f6}\x03\u{f6}\x03\u{f6}\x03\u{f6}\x03\u{f7}\x03\u{f7}\x03\u{f7}\x03\u{f7}\
	\x03\u{f7}\x03\u{f7}\x03\u{f7}\x03\u{f8}\x03\u{f8}\x03\u{f8}\x03\u{f8}\x03\
	\u{f8}\x03\u{f8}\x03\u{f8}\x03\u{f9}\x03\u{f9}\x03\u{f9}\x03\u{f9}\x03\u{f9}\
	\x03\u{f9}\x03\u{f9}\x03\u{fa}\x03\u{fa}\x03\u{fa}\x03\u{fa}\x03\u{fa}\x03\
	\u{fa}\x03\u{fa}\x03\u{fb}\x03\u{fb}\x03\u{fb}\x03\u{fb}\x03\u{fb}\x03\u{fb}\
	\x03\u{fb}\x03\u{fc}\x03\u{fc}\x03\u{fc}\x03\u{fc}\x03\u{fc}\x03\u{fc}\x03\
	\u{fc}\x03\u{fd}\x03\u{fd}\x03\u{fd}\x03\u{fd}\x03\u{fd}\x03\u{fd}\x03\u{fd}\
	\x03\u{fe}\x03\u{fe}\x03\u{fe}\x03\u{fe}\x03\u{fe}\x03\u{fe}\x03\u{fe}\x03\
	\u{ff}\x03\u{ff}\x03\u{ff}\x03\u{ff}\x03\u{ff}\x03\u{ff}\x03\u{ff}\x03\u{100}\
	\x03\u{100}\x03\u{100}\x03\u{100}\x03\u{100}\x03\u{100}\x03\u{100}\x03\u{101}\
	\x03\u{101}\x03\u{101}\x03\u{101}\x03\u{101}\x03\u{101}\x03\u{101}\x03\u{102}\
	\x03\u{102}\x03\u{102}\x03\u{102}\x03\u{102}\x03\u{102}\x03\u{102}\x03\u{103}\
	\x03\u{103}\x03\u{103}\x03\u{103}\x03\u{103}\x03\u{103}\x03\u{103}\x03\u{104}\
	\x03\u{104}\x03\u{105}\x03\u{105}\x03\u{105}\x03\u{105}\x03\u{105}\x03\u{106}\
	\x03\u{106}\x03\u{107}\x03\u{107}\x03\u{107}\x03\u{107}\x03\u{107}\x03\u{108}\
	\x03\u{108}\x03\u{108}\x03\u{108}\x03\u{108}\x03\u{109}\x03\u{109}\x03\u{10a}\
	\x03\u{10a}\x03\u{10b}\x03\u{10b}\x03\u{10c}\x03\u{10c}\x03\u{10c}\x03\u{10c}\
	\x03\u{10c}\x03\u{10d}\x03\u{10d}\x03\u{10d}\x03\u{10d}\x03\u{10d}\x03\u{10e}\
	\x03\u{10e}\x03\u{10f}\x03\u{10f}\x03\u{10f}\x03\u{10f}\x03\u{10f}\x03\u{110}\
	\x03\u{110}\x03\u{111}\x03\u{111}\x03\u{111}\x03\u{111}\x03\u{111}\x03\u{111}\
	\x03\u{111}\x03\u{112}\x03\u{112}\x03\u{113}\x03\u{113}\x03\u{113}\x03\u{113}\
	\x03\u{113}\x03\u{113}\x03\u{113}\x03\u{114}\x03\u{114}\x03\u{115}\x03\u{115}\
	\x03\u{116}\x03\u{116}\x03\u{117}\x03\u{117}\x03\u{118}\x03\u{118}\x03\u{118}\
	\x03\u{118}\x03\u{118}\x03\u{119}\x03\u{119}\x03\u{119}\x03\u{119}\x03\u{119}\
	\x03\u{11a}\x03\u{11a}\x03\u{11b}\x03\u{11b}\x03\u{11c}\x03\u{11c}\x03\u{11d}\
	\x03\u{11d}\x03\u{11e}\x03\u{11e}\x03\u{11f}\x03\u{11f}\x03\u{120}\x03\u{120}\
	\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\
	\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\
	\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\
	\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\
	\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\
	\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\
	\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\
	\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\
	\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\
	\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\
	\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\
	\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\
	\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\
	\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\
	\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\
	\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\
	\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\x03\u{120}\
	\x03\u{120}\x05\u{120}\u{8cb}\x0a\u{120}\x03\u{121}\x03\u{121}\x03\u{121}\
	\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\
	\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\
	\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\
	\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\
	\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\
	\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\
	\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\
	\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\
	\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\
	\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\
	\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\
	\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\x03\u{121}\
	\x05\u{121}\u{924}\x0a\u{121}\x03\u{122}\x03\u{122}\x03\u{122}\x03\u{122}\
	\x03\u{122}\x03\u{122}\x03\u{122}\x03\u{122}\x03\u{122}\x03\u{122}\x03\u{122}\
	\x03\u{122}\x03\u{122}\x03\u{122}\x03\u{122}\x03\u{122}\x03\u{122}\x05\u{122}\
	\u{937}\x0a\u{122}\x03\u{123}\x03\u{123}\x03\u{123}\x03\u{123}\x03\u{124}\
	\x03\u{124}\x03\u{124}\x03\u{124}\x03\u{125}\x03\u{125}\x03\u{126}\x03\u{126}\
	\x03\u{127}\x03\u{127}\x03\u{127}\x03\u{127}\x03\u{128}\x03\u{128}\x07\u{128}\
	\u{94b}\x0a\u{128}\x0c\u{128}\x0e\u{128}\u{94e}\x0b\u{128}\x03\u{128}\x03\
	\u{128}\x03\u{128}\x05\u{128}\u{953}\x0a\u{128}\x03\u{129}\x03\u{129}\x03\
	\u{12a}\x03\u{12a}\x07\u{12a}\u{959}\x0a\u{12a}\x0c\u{12a}\x0e\u{12a}\u{95c}\
	\x0b\u{12a}\x03\u{12a}\x03\u{12a}\x03\u{12b}\x03\u{12b}\x03\u{12c}\x03\u{12c}\
	\x03\u{12c}\x03\u{12d}\x03\u{12d}\x03\u{12e}\x03\u{12e}\x03\u{12e}\x03\u{12f}\
	\x03\u{12f}\x03\u{12f}\x03\u{12f}\x03\u{12f}\x05\u{12f}\u{96f}\x0a\u{12f}\
	\x03\u{130}\x03\u{130}\x03\u{131}\x03\u{131}\x05\u{131}\u{975}\x0a\u{131}\
	\x03\u{132}\x06\u{132}\u{978}\x0a\u{132}\x0d\u{132}\x0e\u{132}\u{979}\x03\
	\u{133}\x03\u{133}\x03\u{133}\x05\u{133}\u{97f}\x0a\u{133}\x03\u{133}\x03\
	\u{133}\x03\u{133}\x03\u{134}\x07\u{134}\u{985}\x0a\u{134}\x0c\u{134}\x0e\
	\u{134}\u{988}\x0b\u{134}\x03\u{134}\x03\u{134}\x03\u{135}\x03\u{135}\x03\
	\u{136}\x03\u{136}\x03\u{137}\x03\u{137}\x05\u{137}\u{992}\x0a\u{137}\x03\
	\u{138}\x03\u{138}\x03\u{138}\x03\u{138}\x07\u{138}\u{998}\x0a\u{138}\x0c\
	\u{138}\x0e\u{138}\u{99b}\x0b\u{138}\x05\u{138}\u{99d}\x0a\u{138}\x03\u{138}\
	\x03\u{138}\x03\u{139}\x03\u{139}\x03\u{139}\x03\u{139}\x05\u{139}\u{9a5}\
	\x0a\u{139}\x03\u{13a}\x03\u{13a}\x03\u{13a}\x03\u{13a}\x07\u{13a}\u{9ab}\
	\x0a\u{13a}\x0c\u{13a}\x0e\u{13a}\u{9ae}\x0b\u{13a}\x03\u{13a}\x03\u{13a}\
	\x03\u{13b}\x03\u{13b}\x03\u{13c}\x03\u{13c}\x03\u{13d}\x03\u{13d}\x03\u{13e}\
	\x03\u{13e}\x03\u{13f}\x03\u{13f}\x03\u{13f}\x03\u{13f}\x03\u{13f}\x03\u{13f}\
	\x05\u{13f}\u{9c0}\x0a\u{13f}\x03\u{13f}\x03\u{13f}\x05\u{13f}\u{9c4}\x0a\
	\u{13f}\x03\u{140}\x03\u{140}\x03\u{140}\x03\u{141}\x03\u{141}\x03\u{141}\
	\x03\u{142}\x03\u{142}\x03\u{143}\x03\u{143}\x03\u{143}\x03\u{143}\x03\u{143}\
	\x03\u{143}\x03\u{143}\x03\u{143}\x03\u{143}\x03\u{143}\x03\u{143}\x03\u{143}\
	\x03\u{143}\x03\u{143}\x03\u{143}\x05\u{143}\u{9dd}\x0a\u{143}\x03\u{144}\
	\x06\u{144}\u{9e0}\x0a\u{144}\x0d\u{144}\x0e\u{144}\u{9e1}\x03\u{145}\x03\
	\u{145}\x03\u{146}\x03\u{146}\x03\u{147}\x06\u{147}\u{9e9}\x0a\u{147}\x0d\
	\u{147}\x0e\u{147}\u{9ea}\x03\u{148}\x03\u{148}\x03\u{148}\x05\u{148}\u{9f0}\
	\x0a\u{148}\x03\u{148}\x03\u{148}\x03\u{149}\x03\u{149}\x03\u{149}\x05\u{149}\
	\u{9f7}\x0a\u{149}\x03\u{149}\x03\u{149}\x03\u{14a}\x03\u{14a}\x03\u{14a}\
	\x03\u{14b}\x03\u{14b}\x03\u{14b}\x03\u{14c}\x03\u{14c}\x03\u{14c}\x03\u{14d}\
	\x07\u{14d}\u{a05}\x0a\u{14d}\x0c\u{14d}\x0e\u{14d}\u{a08}\x0b\u{14d}\x03\
	\u{14d}\x03\u{14d}\x03\u{14e}\x03\u{14e}\x03\u{14e}\x03\u{14e}\x05\u{14e}\
	\u{a10}\x0a\u{14e}\x03\u{14f}\x03\u{14f}\x03\u{14f}\x03\u{150}\x03\u{150}\
	\x03\u{151}\x03\u{151}\x03\u{152}\x03\u{152}\x03\u{153}\x03\u{153}\x03\u{154}\
	\x03\u{154}\x03\u{154}\x03\u{154}\x03\u{154}\x03\u{154}\x03\u{154}\x03\u{154}\
	\x03\u{154}\x03\u{154}\x03\u{155}\x03\u{155}\x03\u{155}\x03\u{155}\x03\u{155}\
	\x03\u{155}\x03\u{155}\x03\u{155}\x03\u{155}\x03\u{156}\x03\u{156}\x03\u{156}\
	\x07\u{156}\u{a33}\x0a\u{156}\x0c\u{156}\x0e\u{156}\u{a36}\x0b\u{156}\x03\
	\u{156}\x03\u{156}\x03\u{157}\x03\u{157}\x05\u{157}\u{a3c}\x0a\u{157}\x03\
	\u{158}\x03\u{158}\x03\u{158}\x03\u{158}\x03\u{159}\x03\u{159}\x07\u{159}\
	\u{a44}\x0a\u{159}\x0c\u{159}\x0e\u{159}\u{a47}\x0b\u{159}\x03\u{159}\x03\
	\u{159}\x03\u{15a}\x03\u{15a}\x03\u{15a}\x03\u{15a}\x03\u{15a}\x05\u{15a}\
	\u{a50}\x0a\u{15a}\x03\u{15b}\x06\u{15b}\u{a53}\x0a\u{15b}\x0d\u{15b}\x0e\
	\u{15b}\u{a54}\x03\u{15b}\x02\x02\u{15c}\x02\x04\x06\x08\x0a\x0c\x0e\x10\
	\x12\x14\x16\x18\x1a\x1c\x1e\x20\x22\x24\x26\x28\x2a\x2c\x2e\x30\x32\x34\
	\x36\x38\x3a\x3c\x3e\x40\x42\x44\x46\x48\x4a\x4c\x4e\x50\x52\x54\x56\x58\
	\x5a\x5c\x5e\x60\x62\x64\x66\x68\x6a\x6c\x6e\x70\x72\x74\x76\x78\x7a\x7c\
	\x7e\u{80}\u{82}\u{84}\u{86}\u{88}\u{8a}\u{8c}\u{8e}\u{90}\u{92}\u{94}\u{96}\
	\u{98}\u{9a}\u{9c}\u{9e}\u{a0}\u{a2}\u{a4}\u{a6}\u{a8}\u{aa}\u{ac}\u{ae}\
	\u{b0}\u{b2}\u{b4}\u{b6}\u{b8}\u{ba}\u{bc}\u{be}\u{c0}\u{c2}\u{c4}\u{c6}\
	\u{c8}\u{ca}\u{cc}\u{ce}\u{d0}\u{d2}\u{d4}\u{d6}\u{d8}\u{da}\u{dc}\u{de}\
	\u{e0}\u{e2}\u{e4}\u{e6}\u{e8}\u{ea}\u{ec}\u{ee}\u{f0}\u{f2}\u{f4}\u{f6}\
	\u{f8}\u{fa}\u{fc}\u{fe}\u{100}\u{102}\u{104}\u{106}\u{108}\u{10a}\u{10c}\
	\u{10e}\u{110}\u{112}\u{114}\u{116}\u{118}\u{11a}\u{11c}\u{11e}\u{120}\u{122}\
	\u{124}\u{126}\u{128}\u{12a}\u{12c}\u{12e}\u{130}\u{132}\u{134}\u{136}\u{138}\
	\u{13a}\u{13c}\u{13e}\u{140}\u{142}\u{144}\u{146}\u{148}\u{14a}\u{14c}\u{14e}\
	\u{150}\u{152}\u{154}\u{156}\u{158}\u{15a}\u{15c}\u{15e}\u{160}\u{162}\u{164}\
	\u{166}\u{168}\u{16a}\u{16c}\u{16e}\u{170}\u{172}\u{174}\u{176}\u{178}\u{17a}\
	\u{17c}\u{17e}\u{180}\u{182}\u{184}\u{186}\u{188}\u{18a}\u{18c}\u{18e}\u{190}\
	\u{192}\u{194}\u{196}\u{198}\u{19a}\u{19c}\u{19e}\u{1a0}\u{1a2}\u{1a4}\u{1a6}\
	\u{1a8}\u{1aa}\u{1ac}\u{1ae}\u{1b0}\u{1b2}\u{1b4}\u{1b6}\u{1b8}\u{1ba}\u{1bc}\
	\u{1be}\u{1c0}\u{1c2}\u{1c4}\u{1c6}\u{1c8}\u{1ca}\u{1cc}\u{1ce}\u{1d0}\u{1d2}\
	\u{1d4}\u{1d6}\u{1d8}\u{1da}\u{1dc}\u{1de}\u{1e0}\u{1e2}\u{1e4}\u{1e6}\u{1e8}\
	\u{1ea}\u{1ec}\u{1ee}\u{1f0}\u{1f2}\u{1f4}\u{1f6}\u{1f8}\u{1fa}\u{1fc}\u{1fe}\
	\u{200}\u{202}\u{204}\u{206}\u{208}\u{20a}\u{20c}\u{20e}\u{210}\u{212}\u{214}\
	\u{216}\u{218}\u{21a}\u{21c}\u{21e}\u{220}\u{222}\u{224}\u{226}\u{228}\u{22a}\
	\u{22c}\u{22e}\u{230}\u{232}\u{234}\u{236}\u{238}\u{23a}\u{23c}\u{23e}\u{240}\
	\u{242}\u{244}\u{246}\u{248}\u{24a}\u{24c}\u{24e}\u{250}\u{252}\u{254}\u{256}\
	\u{258}\u{25a}\u{25c}\u{25e}\u{260}\u{262}\u{264}\u{266}\u{268}\u{26a}\u{26c}\
	\u{26e}\u{270}\u{272}\u{274}\u{276}\u{278}\u{27a}\u{27c}\u{27e}\u{280}\u{282}\
	\u{284}\u{286}\u{288}\u{28a}\u{28c}\u{28e}\u{290}\u{292}\u{294}\u{296}\u{298}\
	\u{29a}\u{29c}\u{29e}\u{2a0}\u{2a2}\u{2a4}\u{2a6}\u{2a8}\u{2aa}\u{2ac}\u{2ae}\
	\u{2b0}\u{2b2}\u{2b4}\x02\x07\x08\x02\x04\x0c\x3a\x3a\x3c\x3d\x42\x42\x46\
	\x47\u{132}\u{132}\x04\x02\x0d\x0d\u{132}\u{132}\x04\x02\x36\x3c\x3e\x40\
	\x06\x02\x36\x39\x3b\x3e\x42\x43\x45\x47\x07\x02\x36\x39\x3b\x3c\x3f\x3f\
	\x41\x41\x44\x44\x02\u{a21}\x02\u{2b6}\x03\x02\x02\x02\x04\u{2b8}\x03\x02\
	\x02\x02\x06\u{2ba}\x03\x02\x02\x02\x08\u{2bd}\x03\x02\x02\x02\x0a\u{2bf}\
	\x03\x02\x02\x02\x0c\u{2c1}\x03\x02\x02\x02\x0e\u{2c3}\x03\x02\x02\x02\x10\
	\u{2c5}\x03\x02\x02\x02\x12\u{2c7}\x03\x02\x02\x02\x14\u{2cf}\x03\x02\x02\
	\x02\x16\u{2d3}\x03\x02\x02\x02\x18\u{2d6}\x03\x02\x02\x02\x1a\u{2da}\x03\
	\x02\x02\x02\x1c\u{2dc}\x03\x02\x02\x02\x1e\u{2de}\x03\x02\x02\x02\x20\u{2e0}\
	\x03\x02\x02\x02\x22\u{2e2}\x03\x02\x02\x02\x24\u{2e4}\x03\x02\x02\x02\x26\
	\u{2e6}\x03\x02\x02\x02\x28\u{2e8}\x03\x02\x02\x02\x2a\u{2ea}\x03\x02\x02\
	\x02\x2c\u{2ec}\x03\x02\x02\x02\x2e\u{2f6}\x03\x02\x02\x02\x30\u{2fa}\x03\
	\x02\x02\x02\x32\u{2fc}\x03\x02\x02\x02\x34\u{2fe}\x03\x02\x02\x02\x36\u{306}\
	\x03\x02\x02\x02\x38\u{30a}\x03\x02\x02\x02\x3a\u{30f}\x03\x02\x02\x02\x3c\
	\u{311}\x03\x02\x02\x02\x3e\u{313}\x03\x02\x02\x02\x40\u{31a}\x03\x02\x02\
	\x02\x42\u{31c}\x03\x02\x02\x02\x44\u{31e}\x03\x02\x02\x02\x46\u{320}\x03\
	\x02\x02\x02\x48\u{322}\x03\x02\x02\x02\x4a\u{324}\x03\x02\x02\x02\x4c\u{327}\
	\x03\x02\x02\x02\x4e\u{329}\x03\x02\x02\x02\x50\u{32b}\x03\x02\x02\x02\x52\
	\u{333}\x03\x02\x02\x02\x54\u{340}\x03\x02\x02\x02\x56\u{342}\x03\x02\x02\
	\x02\x58\u{345}\x03\x02\x02\x02\x5a\u{348}\x03\x02\x02\x02\x5c\u{34b}\x03\
	\x02\x02\x02\x5e\u{34e}\x03\x02\x02\x02\x60\u{351}\x03\x02\x02\x02\x62\u{354}\
	\x03\x02\x02\x02\x64\u{357}\x03\x02\x02\x02\x66\u{35a}\x03\x02\x02\x02\x68\
	\u{35d}\x03\x02\x02\x02\x6a\u{360}\x03\x02\x02\x02\x6c\u{363}\x03\x02\x02\
	\x02\x6e\u{366}\x03\x02\x02\x02\x70\u{369}\x03\x02\x02\x02\x72\u{36b}\x03\
	\x02\x02\x02\x74\u{36d}\x03\x02\x02\x02\x76\u{372}\x03\x02\x02\x02\x78\u{377}\
	\x03\x02\x02\x02\x7a\u{37c}\x03\x02\x02\x02\x7c\u{381}\x03\x02\x02\x02\x7e\
	\u{386}\x03\x02\x02\x02\u{80}\u{38b}\x03\x02\x02\x02\u{82}\u{390}\x03\x02\
	\x02\x02\u{84}\u{395}\x03\x02\x02\x02\u{86}\u{39a}\x03\x02\x02\x02\u{88}\
	\u{39f}\x03\x02\x02\x02\u{8a}\u{3a4}\x03\x02\x02\x02\u{8c}\u{3a9}\x03\x02\
	\x02\x02\u{8e}\u{3ae}\x03\x02\x02\x02\u{90}\u{3b3}\x03\x02\x02\x02\u{92}\
	\u{3b8}\x03\x02\x02\x02\u{94}\u{3bd}\x03\x02\x02\x02\u{96}\u{3c2}\x03\x02\
	\x02\x02\u{98}\u{3c7}\x03\x02\x02\x02\u{9a}\u{3cc}\x03\x02\x02\x02\u{9c}\
	\u{3d1}\x03\x02\x02\x02\u{9e}\u{3d6}\x03\x02\x02\x02\u{a0}\u{3db}\x03\x02\
	\x02\x02\u{a2}\u{3e0}\x03\x02\x02\x02\u{a4}\u{3e5}\x03\x02\x02\x02\u{a6}\
	\u{3ea}\x03\x02\x02\x02\u{a8}\u{3ef}\x03\x02\x02\x02\u{aa}\u{3f4}\x03\x02\
	\x02\x02\u{ac}\u{3f9}\x03\x02\x02\x02\u{ae}\u{3fe}\x03\x02\x02\x02\u{b0}\
	\u{403}\x03\x02\x02\x02\u{b2}\u{408}\x03\x02\x02\x02\u{b4}\u{40d}\x03\x02\
	\x02\x02\u{b6}\u{412}\x03\x02\x02\x02\u{b8}\u{417}\x03\x02\x02\x02\u{ba}\
	\u{41c}\x03\x02\x02\x02\u{bc}\u{421}\x03\x02\x02\x02\u{be}\u{426}\x03\x02\
	\x02\x02\u{c0}\u{42b}\x03\x02\x02\x02\u{c2}\u{430}\x03\x02\x02\x02\u{c4}\
	\u{435}\x03\x02\x02\x02\u{c6}\u{43a}\x03\x02\x02\x02\u{c8}\u{43f}\x03\x02\
	\x02\x02\u{ca}\u{444}\x03\x02\x02\x02\u{cc}\u{449}\x03\x02\x02\x02\u{ce}\
	\u{44e}\x03\x02\x02\x02\u{d0}\u{453}\x03\x02\x02\x02\u{d2}\u{458}\x03\x02\
	\x02\x02\u{d4}\u{45d}\x03\x02\x02\x02\u{d6}\u{462}\x03\x02\x02\x02\u{d8}\
	\u{467}\x03\x02\x02\x02\u{da}\u{46c}\x03\x02\x02\x02\u{dc}\u{471}\x03\x02\
	\x02\x02\u{de}\u{476}\x03\x02\x02\x02\u{e0}\u{47b}\x03\x02\x02\x02\u{e2}\
	\u{480}\x03\x02\x02\x02\u{e4}\u{485}\x03\x02\x02\x02\u{e6}\u{48a}\x03\x02\
	\x02\x02\u{e8}\u{48f}\x03\x02\x02\x02\u{ea}\u{494}\x03\x02\x02\x02\u{ec}\
	\u{496}\x03\x02\x02\x02\u{ee}\u{49b}\x03\x02\x02\x02\u{f0}\u{4a0}\x03\x02\
	\x02\x02\u{f2}\u{4a5}\x03\x02\x02\x02\u{f4}\u{4aa}\x03\x02\x02\x02\u{f6}\
	\u{4af}\x03\x02\x02\x02\u{f8}\u{4b4}\x03\x02\x02\x02\u{fa}\u{4b9}\x03\x02\
	\x02\x02\u{fc}\u{4be}\x03\x02\x02\x02\u{fe}\u{4c3}\x03\x02\x02\x02\u{100}\
	\u{4c8}\x03\x02\x02\x02\u{102}\u{4cd}\x03\x02\x02\x02\u{104}\u{4d2}\x03\
	\x02\x02\x02\u{106}\u{4d9}\x03\x02\x02\x02\u{108}\u{4e0}\x03\x02\x02\x02\
	\u{10a}\u{4e7}\x03\x02\x02\x02\u{10c}\u{4ee}\x03\x02\x02\x02\u{10e}\u{4f5}\
	\x03\x02\x02\x02\u{110}\u{4fc}\x03\x02\x02\x02\u{112}\u{501}\x03\x02\x02\
	\x02\u{114}\u{506}\x03\x02\x02\x02\u{116}\u{50b}\x03\x02\x02\x02\u{118}\
	\u{510}\x03\x02\x02\x02\u{11a}\u{515}\x03\x02\x02\x02\u{11c}\u{51a}\x03\
	\x02\x02\x02\u{11e}\u{51f}\x03\x02\x02\x02\u{120}\u{524}\x03\x02\x02\x02\
	\u{122}\u{529}\x03\x02\x02\x02\u{124}\u{52e}\x03\x02\x02\x02\u{126}\u{533}\
	\x03\x02\x02\x02\u{128}\u{538}\x03\x02\x02\x02\u{12a}\u{53d}\x03\x02\x02\
	\x02\u{12c}\u{542}\x03\x02\x02\x02\u{12e}\u{547}\x03\x02\x02\x02\u{130}\
	\u{54c}\x03\x02\x02\x02\u{132}\u{551}\x03\x02\x02\x02\u{134}\u{556}\x03\
	\x02\x02\x02\u{136}\u{55b}\x03\x02\x02\x02\u{138}\u{560}\x03\x02\x02\x02\
	\u{13a}\u{565}\x03\x02\x02\x02\u{13c}\u{56a}\x03\x02\x02\x02\u{13e}\u{56f}\
	\x03\x02\x02\x02\u{140}\u{574}\x03\x02\x02\x02\u{142}\u{579}\x03\x02\x02\
	\x02\u{144}\u{57e}\x03\x02\x02\x02\u{146}\u{583}\x03\x02\x02\x02\u{148}\
	\u{588}\x03\x02\x02\x02\u{14a}\u{58d}\x03\x02\x02\x02\u{14c}\u{592}\x03\
	\x02\x02\x02\u{14e}\u{597}\x03\x02\x02\x02\u{150}\u{59c}\x03\x02\x02\x02\
	\u{152}\u{5a3}\x03\x02\x02\x02\u{154}\u{5aa}\x03\x02\x02\x02\u{156}\u{5b1}\
	\x03\x02\x02\x02\u{158}\u{5b8}\x03\x02\x02\x02\u{15a}\u{5bf}\x03\x02\x02\
	\x02\u{15c}\u{5c1}\x03\x02\x02\x02\u{15e}\u{5c3}\x03\x02\x02\x02\u{160}\
	\u{5c5}\x03\x02\x02\x02\u{162}\u{5c7}\x03\x02\x02\x02\u{164}\u{5c9}\x03\
	\x02\x02\x02\u{166}\u{5cb}\x03\x02\x02\x02\u{168}\u{5cd}\x03\x02\x02\x02\
	\u{16a}\u{5d4}\x03\x02\x02\x02\u{16c}\u{5db}\x03\x02\x02\x02\u{16e}\u{5e2}\
	\x03\x02\x02\x02\u{170}\u{5e9}\x03\x02\x02\x02\u{172}\u{5f0}\x03\x02\x02\
	\x02\u{174}\u{5f7}\x03\x02\x02\x02\u{176}\u{5fe}\x03\x02\x02\x02\u{178}\
	\u{605}\x03\x02\x02\x02\u{17a}\u{60c}\x03\x02\x02\x02\u{17c}\u{613}\x03\
	\x02\x02\x02\u{17e}\u{61a}\x03\x02\x02\x02\u{180}\u{621}\x03\x02\x02\x02\
	\u{182}\u{628}\x03\x02\x02\x02\u{184}\u{62f}\x03\x02\x02\x02\u{186}\u{636}\
	\x03\x02\x02\x02\u{188}\u{63d}\x03\x02\x02\x02\u{18a}\u{644}\x03\x02\x02\
	\x02\u{18c}\u{64b}\x03\x02\x02\x02\u{18e}\u{652}\x03\x02\x02\x02\u{190}\
	\u{659}\x03\x02\x02\x02\u{192}\u{660}\x03\x02\x02\x02\u{194}\u{667}\x03\
	\x02\x02\x02\u{196}\u{66e}\x03\x02\x02\x02\u{198}\u{675}\x03\x02\x02\x02\
	\u{19a}\u{67c}\x03\x02\x02\x02\u{19c}\u{683}\x03\x02\x02\x02\u{19e}\u{68a}\
	\x03\x02\x02\x02\u{1a0}\u{691}\x03\x02\x02\x02\u{1a2}\u{698}\x03\x02\x02\
	\x02\u{1a4}\u{69f}\x03\x02\x02\x02\u{1a6}\u{6a6}\x03\x02\x02\x02\u{1a8}\
	\u{6ad}\x03\x02\x02\x02\u{1aa}\u{6b4}\x03\x02\x02\x02\u{1ac}\u{6bb}\x03\
	\x02\x02\x02\u{1ae}\u{6c2}\x03\x02\x02\x02\u{1b0}\u{6c9}\x03\x02\x02\x02\
	\u{1b2}\u{6d0}\x03\x02\x02\x02\u{1b4}\u{6d7}\x03\x02\x02\x02\u{1b6}\u{6de}\
	\x03\x02\x02\x02\u{1b8}\u{6e5}\x03\x02\x02\x02\u{1ba}\u{6ec}\x03\x02\x02\
	\x02\u{1bc}\u{6f3}\x03\x02\x02\x02\u{1be}\u{6fa}\x03\x02\x02\x02\u{1c0}\
	\u{701}\x03\x02\x02\x02\u{1c2}\u{708}\x03\x02\x02\x02\u{1c4}\u{70f}\x03\
	\x02\x02\x02\u{1c6}\u{716}\x03\x02\x02\x02\u{1c8}\u{71d}\x03\x02\x02\x02\
	\u{1ca}\u{724}\x03\x02\x02\x02\u{1cc}\u{72b}\x03\x02\x02\x02\u{1ce}\u{732}\
	\x03\x02\x02\x02\u{1d0}\u{739}\x03\x02\x02\x02\u{1d2}\u{740}\x03\x02\x02\
	\x02\u{1d4}\u{747}\x03\x02\x02\x02\u{1d6}\u{74e}\x03\x02\x02\x02\u{1d8}\
	\u{755}\x03\x02\x02\x02\u{1da}\u{75c}\x03\x02\x02\x02\u{1dc}\u{763}\x03\
	\x02\x02\x02\u{1de}\u{76a}\x03\x02\x02\x02\u{1e0}\u{771}\x03\x02\x02\x02\
	\u{1e2}\u{778}\x03\x02\x02\x02\u{1e4}\u{77f}\x03\x02\x02\x02\u{1e6}\u{786}\
	\x03\x02\x02\x02\u{1e8}\u{78d}\x03\x02\x02\x02\u{1ea}\u{794}\x03\x02\x02\
	\x02\u{1ec}\u{79b}\x03\x02\x02\x02\u{1ee}\u{7a2}\x03\x02\x02\x02\u{1f0}\
	\u{7a9}\x03\x02\x02\x02\u{1f2}\u{7b0}\x03\x02\x02\x02\u{1f4}\u{7b7}\x03\
	\x02\x02\x02\u{1f6}\u{7be}\x03\x02\x02\x02\u{1f8}\u{7c5}\x03\x02\x02\x02\
	\u{1fa}\u{7cc}\x03\x02\x02\x02\u{1fc}\u{7d3}\x03\x02\x02\x02\u{1fe}\u{7da}\
	\x03\x02\x02\x02\u{200}\u{7e1}\x03\x02\x02\x02\u{202}\u{7e8}\x03\x02\x02\
	\x02\u{204}\u{7ef}\x03\x02\x02\x02\u{206}\u{7f6}\x03\x02\x02\x02\u{208}\
	\u{7f8}\x03\x02\x02\x02\u{20a}\u{7fd}\x03\x02\x02\x02\u{20c}\u{7ff}\x03\
	\x02\x02\x02\u{20e}\u{804}\x03\x02\x02\x02\u{210}\u{809}\x03\x02\x02\x02\
	\u{212}\u{80b}\x03\x02\x02\x02\u{214}\u{80d}\x03\x02\x02\x02\u{216}\u{80f}\
	\x03\x02\x02\x02\u{218}\u{814}\x03\x02\x02\x02\u{21a}\u{819}\x03\x02\x02\
	\x02\u{21c}\u{81b}\x03\x02\x02\x02\u{21e}\u{820}\x03\x02\x02\x02\u{220}\
	\u{822}\x03\x02\x02\x02\u{222}\u{829}\x03\x02\x02\x02\u{224}\u{82b}\x03\
	\x02\x02\x02\u{226}\u{832}\x03\x02\x02\x02\u{228}\u{834}\x03\x02\x02\x02\
	\u{22a}\u{836}\x03\x02\x02\x02\u{22c}\u{838}\x03\x02\x02\x02\u{22e}\u{83a}\
	\x03\x02\x02\x02\u{230}\u{83f}\x03\x02\x02\x02\u{232}\u{844}\x03\x02\x02\
	\x02\u{234}\u{846}\x03\x02\x02\x02\u{236}\u{848}\x03\x02\x02\x02\u{238}\
	\u{84a}\x03\x02\x02\x02\u{23a}\u{84c}\x03\x02\x02\x02\u{23c}\u{84e}\x03\
	\x02\x02\x02\u{23e}\u{8ca}\x03\x02\x02\x02\u{240}\u{923}\x03\x02\x02\x02\
	\u{242}\u{936}\x03\x02\x02\x02\u{244}\u{938}\x03\x02\x02\x02\u{246}\u{93c}\
	\x03\x02\x02\x02\u{248}\u{940}\x03\x02\x02\x02\u{24a}\u{942}\x03\x02\x02\
	\x02\u{24c}\u{944}\x03\x02\x02\x02\u{24e}\u{948}\x03\x02\x02\x02\u{250}\
	\u{954}\x03\x02\x02\x02\u{252}\u{956}\x03\x02\x02\x02\u{254}\u{95f}\x03\
	\x02\x02\x02\u{256}\u{961}\x03\x02\x02\x02\u{258}\u{964}\x03\x02\x02\x02\
	\u{25a}\u{966}\x03\x02\x02\x02\u{25c}\u{96e}\x03\x02\x02\x02\u{25e}\u{970}\
	\x03\x02\x02\x02\u{260}\u{974}\x03\x02\x02\x02\u{262}\u{977}\x03\x02\x02\
	\x02\u{264}\u{97b}\x03\x02\x02\x02\u{266}\u{986}\x03\x02\x02\x02\u{268}\
	\u{98b}\x03\x02\x02\x02\u{26a}\u{98d}\x03\x02\x02\x02\u{26c}\u{991}\x03\
	\x02\x02\x02\u{26e}\u{993}\x03\x02\x02\x02\u{270}\u{9a0}\x03\x02\x02\x02\
	\u{272}\u{9a6}\x03\x02\x02\x02\u{274}\u{9b1}\x03\x02\x02\x02\u{276}\u{9b3}\
	\x03\x02\x02\x02\u{278}\u{9b5}\x03\x02\x02\x02\u{27a}\u{9b7}\x03\x02\x02\
	\x02\u{27c}\u{9b9}\x03\x02\x02\x02\u{27e}\u{9c5}\x03\x02\x02\x02\u{280}\
	\u{9c8}\x03\x02\x02\x02\u{282}\u{9cb}\x03\x02\x02\x02\u{284}\u{9dc}\x03\
	\x02\x02\x02\u{286}\u{9df}\x03\x02\x02\x02\u{288}\u{9e3}\x03\x02\x02\x02\
	\u{28a}\u{9e5}\x03\x02\x02\x02\u{28c}\u{9e8}\x03\x02\x02\x02\u{28e}\u{9ec}\
	\x03\x02\x02\x02\u{290}\u{9f3}\x03\x02\x02\x02\u{292}\u{9fa}\x03\x02\x02\
	\x02\u{294}\u{9fd}\x03\x02\x02\x02\u{296}\u{a00}\x03\x02\x02\x02\u{298}\
	\u{a06}\x03\x02\x02\x02\u{29a}\u{a0b}\x03\x02\x02\x02\u{29c}\u{a11}\x03\
	\x02\x02\x02\u{29e}\u{a14}\x03\x02\x02\x02\u{2a0}\u{a16}\x03\x02\x02\x02\
	\u{2a2}\u{a18}\x03\x02\x02\x02\u{2a4}\u{a1a}\x03\x02\x02\x02\u{2a6}\u{a1c}\
	\x03\x02\x02\x02\u{2a8}\u{a26}\x03\x02\x02\x02\u{2aa}\u{a2f}\x03\x02\x02\
	\x02\u{2ac}\u{a39}\x03\x02\x02\x02\u{2ae}\u{a3d}\x03\x02\x02\x02\u{2b0}\
	\u{a41}\x03\x02\x02\x02\u{2b2}\u{a4f}\x03\x02\x02\x02\u{2b4}\u{a52}\x03\
	\x02\x02\x02\u{2b6}\u{2b7}\x07\u{132}\x02\x02\u{2b7}\x03\x03\x02\x02\x02\
	\u{2b8}\u{2b9}\x07\u{131}\x02\x02\u{2b9}\x05\x03\x02\x02\x02\u{2ba}\u{2bb}\
	\x07\x17\x02\x02\u{2bb}\u{2bc}\x05\x14\x0b\x02\u{2bc}\x07\x03\x02\x02\x02\
	\u{2bd}\u{2be}\x07\u{128}\x02\x02\u{2be}\x09\x03\x02\x02\x02\u{2bf}\u{2c0}\
	\x07\u{129}\x02\x02\u{2c0}\x0b\x03\x02\x02\x02\u{2c1}\u{2c2}\x07\u{12a}\
	\x02\x02\u{2c2}\x0d\x03\x02\x02\x02\u{2c3}\u{2c4}\x07\u{12b}\x02\x02\u{2c4}\
	\x0f\x03\x02\x02\x02\u{2c5}\u{2c6}\x07\u{12c}\x02\x02\u{2c6}\x11\x03\x02\
	\x02\x02\u{2c7}\u{2c8}\x07\u{12d}\x02\x02\u{2c8}\x13\x03\x02\x02\x02\u{2c9}\
	\u{2d0}\x05\x08\x05\x02\u{2ca}\u{2d0}\x05\x0a\x06\x02\u{2cb}\u{2d0}\x05\
	\x0c\x07\x02\u{2cc}\u{2d0}\x05\x0e\x08\x02\u{2cd}\u{2d0}\x05\x10\x09\x02\
	\u{2ce}\u{2d0}\x05\x12\x0a\x02\u{2cf}\u{2c9}\x03\x02\x02\x02\u{2cf}\u{2ca}\
	\x03\x02\x02\x02\u{2cf}\u{2cb}\x03\x02\x02\x02\u{2cf}\u{2cc}\x03\x02\x02\
	\x02\u{2cf}\u{2cd}\x03\x02\x02\x02\u{2cf}\u{2ce}\x03\x02\x02\x02\u{2d0}\
	\x15\x03\x02\x02\x02\u{2d1}\u{2d4}\x05\x06\x04\x02\u{2d2}\u{2d4}\x05\x14\
	\x0b\x02\u{2d3}\u{2d1}\x03\x02\x02\x02\u{2d3}\u{2d2}\x03\x02\x02\x02\u{2d4}\
	\x17\x03\x02\x02\x02\u{2d5}\u{2d7}\x09\x02\x02\x02\u{2d6}\u{2d5}\x03\x02\
	\x02\x02\u{2d7}\u{2d8}\x03\x02\x02\x02\u{2d8}\u{2d6}\x03\x02\x02\x02\u{2d8}\
	\u{2d9}\x03\x02\x02\x02\u{2d9}\x19\x03\x02\x02\x02\u{2da}\u{2db}\x07\x03\
	\x02\x02\u{2db}\x1b\x03\x02\x02\x02\u{2dc}\u{2dd}\x07\x04\x02\x02\u{2dd}\
	\x1d\x03\x02\x02\x02\u{2de}\u{2df}\x07\x05\x02\x02\u{2df}\x1f\x03\x02\x02\
	\x02\u{2e0}\u{2e1}\x07\x06\x02\x02\u{2e1}\x21\x03\x02\x02\x02\u{2e2}\u{2e3}\
	\x07\x07\x02\x02\u{2e3}\x23\x03\x02\x02\x02\u{2e4}\u{2e5}\x07\x08\x02\x02\
	\u{2e5}\x25\x03\x02\x02\x02\u{2e6}\u{2e7}\x07\x09\x02\x02\u{2e7}\x27\x03\
	\x02\x02\x02\u{2e8}\u{2e9}\x07\x0a\x02\x02\u{2e9}\x29\x03\x02\x02\x02\u{2ea}\
	\u{2eb}\x07\x0b\x02\x02\u{2eb}\x2b\x03\x02\x02\x02\u{2ec}\u{2ed}\x07\x0c\
	\x02\x02\u{2ed}\x2d\x03\x02\x02\x02\u{2ee}\u{2f7}\x05\x1e\x10\x02\u{2ef}\
	\u{2f7}\x05\x20\x11\x02\u{2f0}\u{2f7}\x05\x22\x12\x02\u{2f1}\u{2f7}\x05\
	\x24\x13\x02\u{2f2}\u{2f7}\x05\x26\x14\x02\u{2f3}\u{2f7}\x05\x28\x15\x02\
	\u{2f4}\u{2f7}\x05\x2a\x16\x02\u{2f5}\u{2f7}\x05\x2c\x17\x02\u{2f6}\u{2ee}\
	\x03\x02\x02\x02\u{2f6}\u{2ef}\x03\x02\x02\x02\u{2f6}\u{2f0}\x03\x02\x02\
	\x02\u{2f6}\u{2f1}\x03\x02\x02\x02\u{2f6}\u{2f2}\x03\x02\x02\x02\u{2f6}\
	\u{2f3}\x03\x02\x02\x02\u{2f6}\u{2f4}\x03\x02\x02\x02\u{2f6}\u{2f5}\x03\
	\x02\x02\x02\u{2f7}\x2f\x03\x02\x02\x02\u{2f8}\u{2fb}\x05\x2e\x18\x02\u{2f9}\
	\u{2fb}\x05\x1a\x0e\x02\u{2fa}\u{2f8}\x03\x02\x02\x02\u{2fa}\u{2f9}\x03\
	\x02\x02\x02\u{2fb}\x31\x03\x02\x02\x02\u{2fc}\u{2fd}\x09\x03\x02\x02\u{2fd}\
	\x33\x03\x02\x02\x02\u{2fe}\u{302}\x07\x0e\x02\x02\u{2ff}\u{303}\x05\x30\
	\x19\x02\u{300}\u{303}\x05\x34\x1b\x02\u{301}\u{303}\x05\x32\x1a\x02\u{302}\
	\u{2ff}\x03\x02\x02\x02\u{302}\u{300}\x03\x02\x02\x02\u{302}\u{301}\x03\
	\x02\x02\x02\u{303}\x35\x03\x02\x02\x02\u{304}\u{307}\x05\x1a\x0e\x02\u{305}\
	\u{307}\x05\x34\x1b\x02\u{306}\u{304}\x03\x02\x02\x02\u{306}\u{305}\x03\
	\x02\x02\x02\u{307}\x37\x03\x02\x02\x02\u{308}\u{30b}\x05\x30\x19\x02\u{309}\
	\u{30b}\x05\x34\x1b\x02\u{30a}\u{308}\x03\x02\x02\x02\u{30a}\u{309}\x03\
	\x02\x02\x02\u{30b}\x39\x03\x02\x02\x02\u{30c}\u{310}\x05\x38\x1d\x02\u{30d}\
	\u{310}\x05\x1c\x0f\x02\u{30e}\u{310}\x05\x34\x1b\x02\u{30f}\u{30c}\x03\
	\x02\x02\x02\u{30f}\u{30d}\x03\x02\x02\x02\u{30f}\u{30e}\x03\x02\x02\x02\
	\u{310}\x3b\x03\x02\x02\x02\u{311}\u{312}\x07\u{12f}\x02\x02\u{312}\x3d\
	\x03\x02\x02\x02\u{313}\u{314}\x07\u{12e}\x02\x02\u{314}\x3f\x03\x02\x02\
	\x02\u{315}\u{31b}\x05\x3a\x1e\x02\u{316}\u{31b}\x05\x04\x03\x02\u{317}\
	\u{31b}\x05\x16\x0c\x02\u{318}\u{31b}\x05\x3c\x1f\x02\u{319}\u{31b}\x05\
	\x3e\x20\x02\u{31a}\u{315}\x03\x02\x02\x02\u{31a}\u{316}\x03\x02\x02\x02\
	\u{31a}\u{317}\x03\x02\x02\x02\u{31a}\u{318}\x03\x02\x02\x02\u{31a}\u{319}\
	\x03\x02\x02\x02\u{31b}\x41\x03\x02\x02\x02\u{31c}\u{31d}\x09\x04\x02\x02\
	\u{31d}\x43\x03\x02\x02\x02\u{31e}\u{31f}\x09\x05\x02\x02\u{31f}\x45\x03\
	\x02\x02\x02\u{320}\u{321}\x09\x06\x02\x02\u{321}\x47\x03\x02\x02\x02\u{322}\
	\u{323}\x05\x18\x0d\x02\u{323}\x49\x03\x02\x02\x02\u{324}\u{325}\x07\x14\
	\x02\x02\u{325}\u{326}\x05\x48\x25\x02\u{326}\x4b\x03\x02\x02\x02\u{327}\
	\u{328}\x05\x02\x02\x02\u{328}\x4d\x03\x02\x02\x02\u{329}\u{32a}\x05\x02\
	\x02\x02\u{32a}\x4f\x03\x02\x02\x02\u{32b}\u{330}\x05\x02\x02\x02\u{32c}\
	\u{32d}\x07\x18\x02\x02\u{32d}\u{32f}\x05\x02\x02\x02\u{32e}\u{32c}\x03\
	\x02\x02\x02\u{32f}\u{332}\x03\x02\x02\x02\u{330}\u{32e}\x03\x02\x02\x02\
	\u{330}\u{331}\x03\x02\x02\x02\u{331}\x51\x03\x02\x02\x02\u{332}\u{330}\
	\x03\x02\x02\x02\u{333}\u{334}\x07\x12\x02\x02\u{334}\u{335}\x05\x4c\x27\
	\x02\u{335}\u{336}\x07\x16\x02\x02\u{336}\u{337}\x07\x16\x02\x02\u{337}\
	\u{338}\x05\x4e\x28\x02\u{338}\u{339}\x07\x13\x02\x02\u{339}\x53\x03\x02\
	\x02\x02\u{33a}\u{33b}\x07\x12\x02\x02\u{33b}\u{341}\x07\x13\x02\x02\u{33c}\
	\u{33d}\x07\x12\x02\x02\u{33d}\u{33e}\x05\x50\x29\x02\u{33e}\u{33f}\x07\
	\x13\x02\x02\u{33f}\u{341}\x03\x02\x02\x02\u{340}\u{33a}\x03\x02\x02\x02\
	\u{340}\u{33c}\x03\x02\x02\x02\u{341}\x55\x03\x02\x02\x02\u{342}\u{343}\
	\x07\x70\x02\x02\u{343}\u{344}\x05\x4a\x26\x02\u{344}\x57\x03\x02\x02\x02\
	\u{345}\u{346}\x07\x71\x02\x02\u{346}\u{347}\x05\x4a\x26\x02\u{347}\x59\
	\x03\x02\x02\x02\u{348}\u{349}\x07\x72\x02\x02\u{349}\u{34a}\x05\x4a\x26\
	\x02\u{34a}\x5b\x03\x02\x02\x02\u{34b}\u{34c}\x07\x52\x02\x02\u{34c}\u{34d}\
	\x05\x02\x02\x02\u{34d}\x5d\x03\x02\x02\x02\u{34e}\u{34f}\x07\x53\x02\x02\
	\u{34f}\u{350}\x05\x02\x02\x02\u{350}\x5f\x03\x02\x02\x02\u{351}\u{352}\
	\x07\x54\x02\x02\u{352}\u{353}\x05\x02\x02\x02\u{353}\x61\x03\x02\x02\x02\
	\u{354}\u{355}\x07\x55\x02\x02\u{355}\u{356}\x05\x02\x02\x02\u{356}\x63\
	\x03\x02\x02\x02\u{357}\u{358}\x07\x57\x02\x02\u{358}\u{359}\x05\x02\x02\
	\x02\u{359}\x65\x03\x02\x02\x02\u{35a}\u{35b}\x07\x58\x02\x02\u{35b}\u{35c}\
	\x05\x02\x02\x02\u{35c}\x67\x03\x02\x02\x02\u{35d}\u{35e}\x07\x59\x02\x02\
	\u{35e}\u{35f}\x05\x02\x02\x02\u{35f}\x69\x03\x02\x02\x02\u{360}\u{361}\
	\x07\x65\x02\x02\u{361}\u{362}\x05\x02\x02\x02\u{362}\x6b\x03\x02\x02\x02\
	\u{363}\u{364}\x07\x66\x02\x02\u{364}\u{365}\x05\x02\x02\x02\u{365}\x6d\
	\x03\x02\x02\x02\u{366}\u{367}\x07\x6f\x02\x02\u{367}\u{368}\x05\x02\x02\
	\x02\u{368}\x6f\x03\x02\x02\x02\u{369}\u{36a}\x07\x56\x02\x02\u{36a}\x71\
	\x03\x02\x02\x02\u{36b}\u{36c}\x07\x48\x02\x02\u{36c}\x73\x03\x02\x02\x02\
	\u{36d}\u{36e}\x07\x49\x02\x02\u{36e}\u{36f}\x05\x4c\x27\x02\u{36f}\u{370}\
	\x07\x18\x02\x02\u{370}\u{371}\x05\x4e\x28\x02\u{371}\x75\x03\x02\x02\x02\
	\u{372}\u{373}\x07\x4a\x02\x02\u{373}\u{374}\x05\x4c\x27\x02\u{374}\u{375}\
	\x07\x18\x02\x02\u{375}\u{376}\x05\x4e\x28\x02\u{376}\x77\x03\x02\x02\x02\
	\u{377}\u{378}\x07\x4b\x02\x02\u{378}\u{379}\x05\x4c\x27\x02\u{379}\u{37a}\
	\x07\x18\x02\x02\u{37a}\u{37b}\x05\x4e\x28\x02\u{37b}\x79\x03\x02\x02\x02\
	\u{37c}\u{37d}\x07\x4c\x02\x02\u{37d}\u{37e}\x05\x4c\x27\x02\u{37e}\u{37f}\
	\x07\x18\x02\x02\u{37f}\u{380}\x05\x4e\x28\x02\u{380}\x7b\x03\x02\x02\x02\
	\u{381}\u{382}\x07\x4d\x02\x02\u{382}\u{383}\x05\x4c\x27\x02\u{383}\u{384}\
	\x07\x18\x02\x02\u{384}\u{385}\x05\x4e\x28\x02\u{385}\x7d\x03\x02\x02\x02\
	\u{386}\u{387}\x07\x4e\x02\x02\u{387}\u{388}\x05\x4c\x27\x02\u{388}\u{389}\
	\x07\x18\x02\x02\u{389}\u{38a}\x05\x4e\x28\x02\u{38a}\x7f\x03\x02\x02\x02\
	\u{38b}\u{38c}\x07\x4f\x02\x02\u{38c}\u{38d}\x05\x4c\x27\x02\u{38d}\u{38e}\
	\x07\x18\x02\x02\u{38e}\u{38f}\x05\x4e\x28\x02\u{38f}\u{81}\x03\x02\x02\
	\x02\u{390}\u{391}\x07\x50\x02\x02\u{391}\u{392}\x05\x4c\x27\x02\u{392}\
	\u{393}\x07\x18\x02\x02\u{393}\u{394}\x05\x4e\x28\x02\u{394}\u{83}\x03\x02\
	\x02\x02\u{395}\u{396}\x07\x51\x02\x02\u{396}\u{397}\x05\x4c\x27\x02\u{397}\
	\u{398}\x07\x18\x02\x02\u{398}\u{399}\x05\x4e\x28\x02\u{399}\u{85}\x03\x02\
	\x02\x02\u{39a}\u{39b}\x07\x5c\x02\x02\u{39b}\u{39c}\x05\x02\x02\x02\u{39c}\
	\u{39d}\x07\x18\x02\x02\u{39d}\u{39e}\x05\x16\x0c\x02\u{39e}\u{87}\x03\x02\
	\x02\x02\u{39f}\u{3a0}\x07\x5a\x02\x02\u{3a0}\u{3a1}\x05\x02\x02\x02\u{3a1}\
	\u{3a2}\x07\x18\x02\x02\u{3a2}\u{3a3}\x05\x16\x0c\x02\u{3a3}\u{89}\x03\x02\
	\x02\x02\u{3a4}\u{3a5}\x07\x5b\x02\x02\u{3a5}\u{3a6}\x05\x02\x02\x02\u{3a6}\
	\u{3a7}\x07\x18\x02\x02\u{3a7}\u{3a8}\x05\x16\x0c\x02\u{3a8}\u{8b}\x03\x02\
	\x02\x02\u{3a9}\u{3aa}\x07\x5d\x02\x02\u{3aa}\u{3ab}\x05\x02\x02\x02\u{3ab}\
	\u{3ac}\x07\x18\x02\x02\u{3ac}\u{3ad}\x05\x16\x0c\x02\u{3ad}\u{8d}\x03\x02\
	\x02\x02\u{3ae}\u{3af}\x07\x5e\x02\x02\u{3af}\u{3b0}\x05\x02\x02\x02\u{3b0}\
	\u{3b1}\x07\x18\x02\x02\u{3b1}\u{3b2}\x05\x16\x0c\x02\u{3b2}\u{8f}\x03\x02\
	\x02\x02\u{3b3}\u{3b4}\x07\x5f\x02\x02\u{3b4}\u{3b5}\x05\x02\x02\x02\u{3b5}\
	\u{3b6}\x07\x18\x02\x02\u{3b6}\u{3b7}\x05\x16\x0c\x02\u{3b7}\u{91}\x03\x02\
	\x02\x02\u{3b8}\u{3b9}\x07\x60\x02\x02\u{3b9}\u{3ba}\x05\x02\x02\x02\u{3ba}\
	\u{3bb}\x07\x18\x02\x02\u{3bb}\u{3bc}\x05\x16\x0c\x02\u{3bc}\u{93}\x03\x02\
	\x02\x02\u{3bd}\u{3be}\x07\x61\x02\x02\u{3be}\u{3bf}\x05\x02\x02\x02\u{3bf}\
	\u{3c0}\x07\x18\x02\x02\u{3c0}\u{3c1}\x05\x16\x0c\x02\u{3c1}\u{95}\x03\x02\
	\x02\x02\u{3c2}\u{3c3}\x07\x62\x02\x02\u{3c3}\u{3c4}\x05\x02\x02\x02\u{3c4}\
	\u{3c5}\x07\x18\x02\x02\u{3c5}\u{3c6}\x05\x04\x03\x02\u{3c6}\u{97}\x03\x02\
	\x02\x02\u{3c7}\u{3c8}\x07\x63\x02\x02\u{3c8}\u{3c9}\x05\x02\x02\x02\u{3c9}\
	\u{3ca}\x07\x18\x02\x02\u{3ca}\u{3cb}\x05\x04\x03\x02\u{3cb}\u{99}\x03\x02\
	\x02\x02\u{3cc}\u{3cd}\x07\x64\x02\x02\u{3cd}\u{3ce}\x05\x02\x02\x02\u{3ce}\
	\u{3cf}\x07\x18\x02\x02\u{3cf}\u{3d0}\x05\x36\x1c\x02\u{3d0}\u{9b}\x03\x02\
	\x02\x02\u{3d1}\u{3d2}\x07\u{a0}\x02\x02\u{3d2}\u{3d3}\x05\x02\x02\x02\u{3d3}\
	\u{3d4}\x07\x18\x02\x02\u{3d4}\u{3d5}\x05\u{246}\u{124}\x02\u{3d5}\u{9d}\
	\x03\x02\x02\x02\u{3d6}\u{3d7}\x07\u{a1}\x02\x02\u{3d7}\u{3d8}\x05\x02\x02\
	\x02\u{3d8}\u{3d9}\x07\x18\x02\x02\u{3d9}\u{3da}\x05\u{246}\u{124}\x02\u{3da}\
	\u{9f}\x03\x02\x02\x02\u{3db}\u{3dc}\x07\u{a2}\x02\x02\u{3dc}\u{3dd}\x05\
	\x02\x02\x02\u{3dd}\u{3de}\x07\x18\x02\x02\u{3de}\u{3df}\x05\u{246}\u{124}\
	\x02\u{3df}\u{a1}\x03\x02\x02\x02\u{3e0}\u{3e1}\x07\u{a3}\x02\x02\u{3e1}\
	\u{3e2}\x05\x02\x02\x02\u{3e2}\u{3e3}\x07\x18\x02\x02\u{3e3}\u{3e4}\x05\
	\u{246}\u{124}\x02\u{3e4}\u{a3}\x03\x02\x02\x02\u{3e5}\u{3e6}\x07\u{a4}\
	\x02\x02\u{3e6}\u{3e7}\x05\x02\x02\x02\u{3e7}\u{3e8}\x07\x18\x02\x02\u{3e8}\
	\u{3e9}\x05\u{246}\u{124}\x02\u{3e9}\u{a5}\x03\x02\x02\x02\u{3ea}\u{3eb}\
	\x07\u{a5}\x02\x02\u{3eb}\u{3ec}\x05\x02\x02\x02\u{3ec}\u{3ed}\x07\x18\x02\
	\x02\u{3ed}\u{3ee}\x05\u{246}\u{124}\x02\u{3ee}\u{a7}\x03\x02\x02\x02\u{3ef}\
	\u{3f0}\x07\u{a6}\x02\x02\u{3f0}\u{3f1}\x05\x02\x02\x02\u{3f1}\u{3f2}\x07\
	\x18\x02\x02\u{3f2}\u{3f3}\x05\u{246}\u{124}\x02\u{3f3}\u{a9}\x03\x02\x02\
	\x02\u{3f4}\u{3f5}\x07\u{a7}\x02\x02\u{3f5}\u{3f6}\x05\x02\x02\x02\u{3f6}\
	\u{3f7}\x07\x18\x02\x02\u{3f7}\u{3f8}\x05\u{246}\u{124}\x02\u{3f8}\u{ab}\
	\x03\x02\x02\x02\u{3f9}\u{3fa}\x07\u{a8}\x02\x02\u{3fa}\u{3fb}\x05\x02\x02\
	\x02\u{3fb}\u{3fc}\x07\x18\x02\x02\u{3fc}\u{3fd}\x05\u{246}\u{124}\x02\u{3fd}\
	\u{ad}\x03\x02\x02\x02\u{3fe}\u{3ff}\x07\u{a9}\x02\x02\u{3ff}\u{400}\x05\
	\x02\x02\x02\u{400}\u{401}\x07\x18\x02\x02\u{401}\u{402}\x05\u{246}\u{124}\
	\x02\u{402}\u{af}\x03\x02\x02\x02\u{403}\u{404}\x07\u{aa}\x02\x02\u{404}\
	\u{405}\x05\x02\x02\x02\u{405}\u{406}\x07\x18\x02\x02\u{406}\u{407}\x05\
	\u{246}\u{124}\x02\u{407}\u{b1}\x03\x02\x02\x02\u{408}\u{409}\x07\u{ab}\
	\x02\x02\u{409}\u{40a}\x05\x02\x02\x02\u{40a}\u{40b}\x07\x18\x02\x02\u{40b}\
	\u{40c}\x05\u{246}\u{124}\x02\u{40c}\u{b3}\x03\x02\x02\x02\u{40d}\u{40e}\
	\x07\u{ac}\x02\x02\u{40e}\u{40f}\x05\x02\x02\x02\u{40f}\u{410}\x07\x18\x02\
	\x02\u{410}\u{411}\x05\u{246}\u{124}\x02\u{411}\u{b5}\x03\x02\x02\x02\u{412}\
	\u{413}\x07\u{ad}\x02\x02\u{413}\u{414}\x05\x02\x02\x02\u{414}\u{415}\x07\
	\x18\x02\x02\u{415}\u{416}\x05\u{246}\u{124}\x02\u{416}\u{b7}\x03\x02\x02\
	\x02\u{417}\u{418}\x07\u{ae}\x02\x02\u{418}\u{419}\x05\x54\x2b\x02\u{419}\
	\u{41a}\x07\x18\x02\x02\u{41a}\u{41b}\x05\u{244}\u{123}\x02\u{41b}\u{b9}\
	\x03\x02\x02\x02\u{41c}\u{41d}\x07\u{af}\x02\x02\u{41d}\u{41e}\x05\x54\x2b\
	\x02\u{41e}\u{41f}\x07\x18\x02\x02\u{41f}\u{420}\x05\u{244}\u{123}\x02\u{420}\
	\u{bb}\x03\x02\x02\x02\u{421}\u{422}\x07\u{b0}\x02\x02\u{422}\u{423}\x05\
	\x54\x2b\x02\u{423}\u{424}\x07\x18\x02\x02\u{424}\u{425}\x05\u{244}\u{123}\
	\x02\u{425}\u{bd}\x03\x02\x02\x02\u{426}\u{427}\x07\u{b1}\x02\x02\u{427}\
	\u{428}\x05\x54\x2b\x02\u{428}\u{429}\x07\x18\x02\x02\u{429}\u{42a}\x05\
	\u{244}\u{123}\x02\u{42a}\u{bf}\x03\x02\x02\x02\u{42b}\u{42c}\x07\u{b2}\
	\x02\x02\u{42c}\u{42d}\x05\x54\x2b\x02\u{42d}\u{42e}\x07\x18\x02\x02\u{42e}\
	\u{42f}\x05\u{244}\u{123}\x02\u{42f}\u{c1}\x03\x02\x02\x02\u{430}\u{431}\
	\x07\u{b3}\x02\x02\u{431}\u{432}\x05\x52\x2a\x02\u{432}\u{433}\x07\x18\x02\
	\x02\u{433}\u{434}\x05\u{244}\u{123}\x02\u{434}\u{c3}\x03\x02\x02\x02\u{435}\
	\u{436}\x07\u{b4}\x02\x02\u{436}\u{437}\x05\x52\x2a\x02\u{437}\u{438}\x07\
	\x18\x02\x02\u{438}\u{439}\x05\u{244}\u{123}\x02\u{439}\u{c5}\x03\x02\x02\
	\x02\u{43a}\u{43b}\x07\u{b5}\x02\x02\u{43b}\u{43c}\x05\x52\x2a\x02\u{43c}\
	\u{43d}\x07\x18\x02\x02\u{43d}\u{43e}\x05\u{244}\u{123}\x02\u{43e}\u{c7}\
	\x03\x02\x02\x02\u{43f}\u{440}\x07\u{b6}\x02\x02\u{440}\u{441}\x05\x52\x2a\
	\x02\u{441}\u{442}\x07\x18\x02\x02\u{442}\u{443}\x05\u{244}\u{123}\x02\u{443}\
	\u{c9}\x03\x02\x02\x02\u{444}\u{445}\x07\u{b7}\x02\x02\u{445}\u{446}\x05\
	\x52\x2a\x02\u{446}\u{447}\x07\x18\x02\x02\u{447}\u{448}\x05\u{244}\u{123}\
	\x02\u{448}\u{cb}\x03\x02\x02\x02\u{449}\u{44a}\x07\u{be}\x02\x02\u{44a}\
	\u{44b}\x05\x4c\x27\x02\u{44b}\u{44c}\x07\x18\x02\x02\u{44c}\u{44d}\x05\
	\x4e\x28\x02\u{44d}\u{cd}\x03\x02\x02\x02\u{44e}\u{44f}\x07\u{bf}\x02\x02\
	\u{44f}\u{450}\x05\x4c\x27\x02\u{450}\u{451}\x07\x18\x02\x02\u{451}\u{452}\
	\x05\x4e\x28\x02\u{452}\u{cf}\x03\x02\x02\x02\u{453}\u{454}\x07\u{c0}\x02\
	\x02\u{454}\u{455}\x05\x4c\x27\x02\u{455}\u{456}\x07\x18\x02\x02\u{456}\
	\u{457}\x05\x4e\x28\x02\u{457}\u{d1}\x03\x02\x02\x02\u{458}\u{459}\x07\u{c1}\
	\x02\x02\u{459}\u{45a}\x05\x4c\x27\x02\u{45a}\u{45b}\x07\x18\x02\x02\u{45b}\
	\u{45c}\x05\x4e\x28\x02\u{45c}\u{d3}\x03\x02\x02\x02\u{45d}\u{45e}\x07\u{c2}\
	\x02\x02\u{45e}\u{45f}\x05\x4c\x27\x02\u{45f}\u{460}\x07\x18\x02\x02\u{460}\
	\u{461}\x05\x4e\x28\x02\u{461}\u{d5}\x03\x02\x02\x02\u{462}\u{463}\x07\u{c3}\
	\x02\x02\u{463}\u{464}\x05\x4c\x27\x02\u{464}\u{465}\x07\x18\x02\x02\u{465}\
	\u{466}\x05\x4e\x28\x02\u{466}\u{d7}\x03\x02\x02\x02\u{467}\u{468}\x07\u{c4}\
	\x02\x02\u{468}\u{469}\x05\x4c\x27\x02\u{469}\u{46a}\x07\x18\x02\x02\u{46a}\
	\u{46b}\x05\x4e\x28\x02\u{46b}\u{d9}\x03\x02\x02\x02\u{46c}\u{46d}\x07\u{c5}\
	\x02\x02\u{46d}\u{46e}\x05\x4c\x27\x02\u{46e}\u{46f}\x07\x18\x02\x02\u{46f}\
	\u{470}\x05\x4e\x28\x02\u{470}\u{db}\x03\x02\x02\x02\u{471}\u{472}\x07\u{c6}\
	\x02\x02\u{472}\u{473}\x05\x4c\x27\x02\u{473}\u{474}\x07\x18\x02\x02\u{474}\
	\u{475}\x05\x4e\x28\x02\u{475}\u{dd}\x03\x02\x02\x02\u{476}\u{477}\x07\u{c7}\
	\x02\x02\u{477}\u{478}\x05\x4c\x27\x02\u{478}\u{479}\x07\x18\x02\x02\u{479}\
	\u{47a}\x05\x4e\x28\x02\u{47a}\u{df}\x03\x02\x02\x02\u{47b}\u{47c}\x07\u{c8}\
	\x02\x02\u{47c}\u{47d}\x05\x4c\x27\x02\u{47d}\u{47e}\x07\x18\x02\x02\u{47e}\
	\u{47f}\x05\x4e\x28\x02\u{47f}\u{e1}\x03\x02\x02\x02\u{480}\u{481}\x07\u{c9}\
	\x02\x02\u{481}\u{482}\x05\x4c\x27\x02\u{482}\u{483}\x07\x18\x02\x02\u{483}\
	\u{484}\x05\x4e\x28\x02\u{484}\u{e3}\x03\x02\x02\x02\u{485}\u{486}\x07\u{ca}\
	\x02\x02\u{486}\u{487}\x05\x4c\x27\x02\u{487}\u{488}\x07\x18\x02\x02\u{488}\
	\u{489}\x05\x4e\x28\x02\u{489}\u{e5}\x03\x02\x02\x02\u{48a}\u{48b}\x07\u{cb}\
	\x02\x02\u{48b}\u{48c}\x05\x4c\x27\x02\u{48c}\u{48d}\x07\x18\x02\x02\u{48d}\
	\u{48e}\x05\x4e\x28\x02\u{48e}\u{e7}\x03\x02\x02\x02\u{48f}\u{490}\x07\u{cc}\
	\x02\x02\u{490}\u{491}\x05\x4c\x27\x02\u{491}\u{492}\x07\x18\x02\x02\u{492}\
	\u{493}\x05\x4e\x28\x02\u{493}\u{e9}\x03\x02\x02\x02\u{494}\u{495}\x05\x4a\
	\x26\x02\u{495}\u{eb}\x03\x02\x02\x02\u{496}\u{497}\x07\x7e\x02\x02\u{497}\
	\u{498}\x05\x02\x02\x02\u{498}\u{499}\x07\x18\x02\x02\u{499}\u{49a}\x05\
	\u{ea}\x76\x02\u{49a}\u{ed}\x03\x02\x02\x02\u{49b}\u{49c}\x07\x7f\x02\x02\
	\u{49c}\u{49d}\x05\x02\x02\x02\u{49d}\u{49e}\x07\x18\x02\x02\u{49e}\u{49f}\
	\x05\u{ea}\x76\x02\u{49f}\u{ef}\x03\x02\x02\x02\u{4a0}\u{4a1}\x07\u{80}\
	\x02\x02\u{4a1}\u{4a2}\x05\x02\x02\x02\u{4a2}\u{4a3}\x07\x18\x02\x02\u{4a3}\
	\u{4a4}\x05\u{ea}\x76\x02\u{4a4}\u{f1}\x03\x02\x02\x02\u{4a5}\u{4a6}\x07\
	\u{81}\x02\x02\u{4a6}\u{4a7}\x05\x02\x02\x02\u{4a7}\u{4a8}\x07\x18\x02\x02\
	\u{4a8}\u{4a9}\x05\u{ea}\x76\x02\u{4a9}\u{f3}\x03\x02\x02\x02\u{4aa}\u{4ab}\
	\x07\u{82}\x02\x02\u{4ab}\u{4ac}\x05\x02\x02\x02\u{4ac}\u{4ad}\x07\x18\x02\
	\x02\u{4ad}\u{4ae}\x05\u{ea}\x76\x02\u{4ae}\u{f5}\x03\x02\x02\x02\u{4af}\
	\u{4b0}\x07\u{83}\x02\x02\u{4b0}\u{4b1}\x05\x02\x02\x02\u{4b1}\u{4b2}\x07\
	\x18\x02\x02\u{4b2}\u{4b3}\x05\u{ea}\x76\x02\u{4b3}\u{f7}\x03\x02\x02\x02\
	\u{4b4}\u{4b5}\x07\u{b8}\x02\x02\u{4b5}\u{4b6}\x05\x4c\x27\x02\u{4b6}\u{4b7}\
	\x07\x18\x02\x02\u{4b7}\u{4b8}\x05\x4e\x28\x02\u{4b8}\u{f9}\x03\x02\x02\
	\x02\u{4b9}\u{4ba}\x07\u{b9}\x02\x02\u{4ba}\u{4bb}\x05\x4c\x27\x02\u{4bb}\
	\u{4bc}\x07\x18\x02\x02\u{4bc}\u{4bd}\x05\x4e\x28\x02\u{4bd}\u{fb}\x03\x02\
	\x02\x02\u{4be}\u{4bf}\x07\u{ba}\x02\x02\u{4bf}\u{4c0}\x05\x4c\x27\x02\u{4c0}\
	\u{4c1}\x07\x18\x02\x02\u{4c1}\u{4c2}\x05\x4e\x28\x02\u{4c2}\u{fd}\x03\x02\
	\x02\x02\u{4c3}\u{4c4}\x07\u{bb}\x02\x02\u{4c4}\u{4c5}\x05\x4c\x27\x02\u{4c5}\
	\u{4c6}\x07\x18\x02\x02\u{4c6}\u{4c7}\x05\x4e\x28\x02\u{4c7}\u{ff}\x03\x02\
	\x02\x02\u{4c8}\u{4c9}\x07\u{bc}\x02\x02\u{4c9}\u{4ca}\x05\x4c\x27\x02\u{4ca}\
	\u{4cb}\x07\x18\x02\x02\u{4cb}\u{4cc}\x05\x4e\x28\x02\u{4cc}\u{101}\x03\
	\x02\x02\x02\u{4cd}\u{4ce}\x07\u{bd}\x02\x02\u{4ce}\u{4cf}\x05\x4c\x27\x02\
	\u{4cf}\u{4d0}\x07\x18\x02\x02\u{4d0}\u{4d1}\x05\x4e\x28\x02\u{4d1}\u{103}\
	\x03\x02\x02\x02\u{4d2}\u{4d3}\x07\x78\x02\x02\u{4d3}\u{4d4}\x05\x4c\x27\
	\x02\u{4d4}\u{4d5}\x07\x18\x02\x02\u{4d5}\u{4d6}\x05\x4e\x28\x02\u{4d6}\
	\u{4d7}\x07\x18\x02\x02\u{4d7}\u{4d8}\x05\u{ea}\x76\x02\u{4d8}\u{105}\x03\
	\x02\x02\x02\u{4d9}\u{4da}\x07\x79\x02\x02\u{4da}\u{4db}\x05\x4c\x27\x02\
	\u{4db}\u{4dc}\x07\x18\x02\x02\u{4dc}\u{4dd}\x05\x4e\x28\x02\u{4dd}\u{4de}\
	\x07\x18\x02\x02\u{4de}\u{4df}\x05\u{ea}\x76\x02\u{4df}\u{107}\x03\x02\x02\
	\x02\u{4e0}\u{4e1}\x07\x7a\x02\x02\u{4e1}\u{4e2}\x05\x4c\x27\x02\u{4e2}\
	\u{4e3}\x07\x18\x02\x02\u{4e3}\u{4e4}\x05\x4e\x28\x02\u{4e4}\u{4e5}\x07\
	\x18\x02\x02\u{4e5}\u{4e6}\x05\u{ea}\x76\x02\u{4e6}\u{109}\x03\x02\x02\x02\
	\u{4e7}\u{4e8}\x07\x7b\x02\x02\u{4e8}\u{4e9}\x05\x4c\x27\x02\u{4e9}\u{4ea}\
	\x07\x18\x02\x02\u{4ea}\u{4eb}\x05\x4e\x28\x02\u{4eb}\u{4ec}\x07\x18\x02\
	\x02\u{4ec}\u{4ed}\x05\u{ea}\x76\x02\u{4ed}\u{10b}\x03\x02\x02\x02\u{4ee}\
	\u{4ef}\x07\x7c\x02\x02\u{4ef}\u{4f0}\x05\x4c\x27\x02\u{4f0}\u{4f1}\x07\
	\x18\x02\x02\u{4f1}\u{4f2}\x05\x4e\x28\x02\u{4f2}\u{4f3}\x07\x18\x02\x02\
	\u{4f3}\u{4f4}\x05\u{ea}\x76\x02\u{4f4}\u{10d}\x03\x02\x02\x02\u{4f5}\u{4f6}\
	\x07\x7d\x02\x02\u{4f6}\u{4f7}\x05\x4c\x27\x02\u{4f7}\u{4f8}\x07\x18\x02\
	\x02\u{4f8}\u{4f9}\x05\x4e\x28\x02\u{4f9}\u{4fa}\x07\x18\x02\x02\u{4fa}\
	\u{4fb}\x05\u{ea}\x76\x02\u{4fb}\u{10f}\x03\x02\x02\x02\u{4fc}\u{4fd}\x07\
	\u{ed}\x02\x02\u{4fd}\u{4fe}\x05\x4c\x27\x02\u{4fe}\u{4ff}\x07\x18\x02\x02\
	\u{4ff}\u{500}\x05\x4e\x28\x02\u{500}\u{111}\x03\x02\x02\x02\u{501}\u{502}\
	\x07\u{ee}\x02\x02\u{502}\u{503}\x05\x4c\x27\x02\u{503}\u{504}\x07\x18\x02\
	\x02\u{504}\u{505}\x05\x4e\x28\x02\u{505}\u{113}\x03\x02\x02\x02\u{506}\
	\u{507}\x07\u{ef}\x02\x02\u{507}\u{508}\x05\x4c\x27\x02\u{508}\u{509}\x07\
	\x18\x02\x02\u{509}\u{50a}\x05\x4e\x28\x02\u{50a}\u{115}\x03\x02\x02\x02\
	\u{50b}\u{50c}\x07\u{f0}\x02\x02\u{50c}\u{50d}\x05\x4c\x27\x02\u{50d}\u{50e}\
	\x07\x18\x02\x02\u{50e}\u{50f}\x05\x4e\x28\x02\u{50f}\u{117}\x03\x02\x02\
	\x02\u{510}\u{511}\x07\u{f1}\x02\x02\u{511}\u{512}\x05\x4c\x27\x02\u{512}\
	\u{513}\x07\x18\x02\x02\u{513}\u{514}\x05\x4e\x28\x02\u{514}\u{119}\x03\
	\x02\x02\x02\u{515}\u{516}\x07\u{f2}\x02\x02\u{516}\u{517}\x05\x4c\x27\x02\
	\u{517}\u{518}\x07\x18\x02\x02\u{518}\u{519}\x05\x4e\x28\x02\u{519}\u{11b}\
	\x03\x02\x02\x02\u{51a}\u{51b}\x07\u{f3}\x02\x02\u{51b}\u{51c}\x05\x4c\x27\
	\x02\u{51c}\u{51d}\x07\x18\x02\x02\u{51d}\u{51e}\x05\x4e\x28\x02\u{51e}\
	\u{11d}\x03\x02\x02\x02\u{51f}\u{520}\x07\u{f4}\x02\x02\u{520}\u{521}\x05\
	\x4c\x27\x02\u{521}\u{522}\x07\x18\x02\x02\u{522}\u{523}\x05\x4e\x28\x02\
	\u{523}\u{11f}\x03\x02\x02\x02\u{524}\u{525}\x07\u{f5}\x02\x02\u{525}\u{526}\
	\x05\x4c\x27\x02\u{526}\u{527}\x07\x18\x02\x02\u{527}\u{528}\x05\x4e\x28\
	\x02\u{528}\u{121}\x03\x02\x02\x02\u{529}\u{52a}\x07\u{f6}\x02\x02\u{52a}\
	\u{52b}\x05\x4c\x27\x02\u{52b}\u{52c}\x07\x18\x02\x02\u{52c}\u{52d}\x05\
	\x4e\x28\x02\u{52d}\u{123}\x03\x02\x02\x02\u{52e}\u{52f}\x07\u{f7}\x02\x02\
	\u{52f}\u{530}\x05\x4c\x27\x02\u{530}\u{531}\x07\x18\x02\x02\u{531}\u{532}\
	\x05\x4e\x28\x02\u{532}\u{125}\x03\x02\x02\x02\u{533}\u{534}\x07\u{f8}\x02\
	\x02\u{534}\u{535}\x05\x4c\x27\x02\u{535}\u{536}\x07\x18\x02\x02\u{536}\
	\u{537}\x05\x4e\x28\x02\u{537}\u{127}\x03\x02\x02\x02\u{538}\u{539}\x07\
	\u{f9}\x02\x02\u{539}\u{53a}\x05\x4c\x27\x02\u{53a}\u{53b}\x07\x18\x02\x02\
	\u{53b}\u{53c}\x05\x4e\x28\x02\u{53c}\u{129}\x03\x02\x02\x02\u{53d}\u{53e}\
	\x07\u{fa}\x02\x02\u{53e}\u{53f}\x05\x4c\x27\x02\u{53f}\u{540}\x07\x18\x02\
	\x02\u{540}\u{541}\x05\x4e\x28\x02\u{541}\u{12b}\x03\x02\x02\x02\u{542}\
	\u{543}\x07\u{fb}\x02\x02\u{543}\u{544}\x05\x4c\x27\x02\u{544}\u{545}\x07\
	\x18\x02\x02\u{545}\u{546}\x05\x4e\x28\x02\u{546}\u{12d}\x03\x02\x02\x02\
	\u{547}\u{548}\x07\u{fc}\x02\x02\u{548}\u{549}\x05\x4c\x27\x02\u{549}\u{54a}\
	\x07\x18\x02\x02\u{54a}\u{54b}\x05\x4e\x28\x02\u{54b}\u{12f}\x03\x02\x02\
	\x02\u{54c}\u{54d}\x07\u{fd}\x02\x02\u{54d}\u{54e}\x05\x4c\x27\x02\u{54e}\
	\u{54f}\x07\x18\x02\x02\u{54f}\u{550}\x05\x4e\x28\x02\u{550}\u{131}\x03\
	\x02\x02\x02\u{551}\u{552}\x07\u{fe}\x02\x02\u{552}\u{553}\x05\x4c\x27\x02\
	\u{553}\u{554}\x07\x18\x02\x02\u{554}\u{555}\x05\x4e\x28\x02\u{555}\u{133}\
	\x03\x02\x02\x02\u{556}\u{557}\x07\u{ff}\x02\x02\u{557}\u{558}\x05\x4c\x27\
	\x02\u{558}\u{559}\x07\x18\x02\x02\u{559}\u{55a}\x05\x4e\x28\x02\u{55a}\
	\u{135}\x03\x02\x02\x02\u{55b}\u{55c}\x07\u{100}\x02\x02\u{55c}\u{55d}\x05\
	\x4c\x27\x02\u{55d}\u{55e}\x07\x18\x02\x02\u{55e}\u{55f}\x05\x4e\x28\x02\
	\u{55f}\u{137}\x03\x02\x02\x02\u{560}\u{561}\x07\u{101}\x02\x02\u{561}\u{562}\
	\x05\x4c\x27\x02\u{562}\u{563}\x07\x18\x02\x02\u{563}\u{564}\x05\x4e\x28\
	\x02\u{564}\u{139}\x03\x02\x02\x02\u{565}\u{566}\x07\u{102}\x02\x02\u{566}\
	\u{567}\x05\x4c\x27\x02\u{567}\u{568}\x07\x18\x02\x02\u{568}\u{569}\x05\
	\x4e\x28\x02\u{569}\u{13b}\x03\x02\x02\x02\u{56a}\u{56b}\x07\u{103}\x02\
	\x02\u{56b}\u{56c}\x05\x4c\x27\x02\u{56c}\u{56d}\x07\x18\x02\x02\u{56d}\
	\u{56e}\x05\x4e\x28\x02\u{56e}\u{13d}\x03\x02\x02\x02\u{56f}\u{570}\x07\
	\u{104}\x02\x02\u{570}\u{571}\x05\x4c\x27\x02\u{571}\u{572}\x07\x18\x02\
	\x02\u{572}\u{573}\x05\x4e\x28\x02\u{573}\u{13f}\x03\x02\x02\x02\u{574}\
	\u{575}\x07\u{105}\x02\x02\u{575}\u{576}\x05\x4c\x27\x02\u{576}\u{577}\x07\
	\x18\x02\x02\u{577}\u{578}\x05\x4e\x28\x02\u{578}\u{141}\x03\x02\x02\x02\
	\u{579}\u{57a}\x07\u{106}\x02\x02\u{57a}\u{57b}\x05\x4c\x27\x02\u{57b}\u{57c}\
	\x07\x18\x02\x02\u{57c}\u{57d}\x05\x4e\x28\x02\u{57d}\u{143}\x03\x02\x02\
	\x02\u{57e}\u{57f}\x07\u{107}\x02\x02\u{57f}\u{580}\x05\x4c\x27\x02\u{580}\
	\u{581}\x07\x18\x02\x02\u{581}\u{582}\x05\x4e\x28\x02\u{582}\u{145}\x03\
	\x02\x02\x02\u{583}\u{584}\x07\u{108}\x02\x02\u{584}\u{585}\x05\x4c\x27\
	\x02\u{585}\u{586}\x07\x18\x02\x02\u{586}\u{587}\x05\x4e\x28\x02\u{587}\
	\u{147}\x03\x02\x02\x02\u{588}\u{589}\x07\u{109}\x02\x02\u{589}\u{58a}\x05\
	\x4c\x27\x02\u{58a}\u{58b}\x07\x18\x02\x02\u{58b}\u{58c}\x05\x4e\x28\x02\
	\u{58c}\u{149}\x03\x02\x02\x02\u{58d}\u{58e}\x07\u{10a}\x02\x02\u{58e}\u{58f}\
	\x05\x4c\x27\x02\u{58f}\u{590}\x07\x18\x02\x02\u{590}\u{591}\x05\x4e\x28\
	\x02\u{591}\u{14b}\x03\x02\x02\x02\u{592}\u{593}\x07\u{10b}\x02\x02\u{593}\
	\u{594}\x05\x4c\x27\x02\u{594}\u{595}\x07\x18\x02\x02\u{595}\u{596}\x05\
	\x4e\x28\x02\u{596}\u{14d}\x03\x02\x02\x02\u{597}\u{598}\x07\u{10c}\x02\
	\x02\u{598}\u{599}\x05\x4c\x27\x02\u{599}\u{59a}\x07\x18\x02\x02\u{59a}\
	\u{59b}\x05\x4e\x28\x02\u{59b}\u{14f}\x03\x02\x02\x02\u{59c}\u{59d}\x07\
	\x73\x02\x02\u{59d}\u{59e}\x05\u{164}\u{b3}\x02\u{59e}\u{59f}\x07\x18\x02\
	\x02\u{59f}\u{5a0}\x05\x4c\x27\x02\u{5a0}\u{5a1}\x07\x18\x02\x02\u{5a1}\
	\u{5a2}\x05\x4e\x28\x02\u{5a2}\u{151}\x03\x02\x02\x02\u{5a3}\u{5a4}\x07\
	\x74\x02\x02\u{5a4}\u{5a5}\x05\u{164}\u{b3}\x02\u{5a5}\u{5a6}\x07\x18\x02\
	\x02\u{5a6}\u{5a7}\x05\x4c\x27\x02\u{5a7}\u{5a8}\x07\x18\x02\x02\u{5a8}\
	\u{5a9}\x05\x4e\x28\x02\u{5a9}\u{153}\x03\x02\x02\x02\u{5aa}\u{5ab}\x07\
	\x75\x02\x02\u{5ab}\u{5ac}\x05\u{164}\u{b3}\x02\u{5ac}\u{5ad}\x07\x18\x02\
	\x02\u{5ad}\u{5ae}\x05\x4c\x27\x02\u{5ae}\u{5af}\x07\x18\x02\x02\u{5af}\
	\u{5b0}\x05\x4e\x28\x02\u{5b0}\u{155}\x03\x02\x02\x02\u{5b1}\u{5b2}\x07\
	\x76\x02\x02\u{5b2}\u{5b3}\x05\u{164}\u{b3}\x02\u{5b3}\u{5b4}\x07\x18\x02\
	\x02\u{5b4}\u{5b5}\x05\x4c\x27\x02\u{5b5}\u{5b6}\x07\x18\x02\x02\u{5b6}\
	\u{5b7}\x05\x4e\x28\x02\u{5b7}\u{157}\x03\x02\x02\x02\u{5b8}\u{5b9}\x07\
	\x77\x02\x02\u{5b9}\u{5ba}\x05\u{164}\u{b3}\x02\u{5ba}\u{5bb}\x07\x18\x02\
	\x02\u{5bb}\u{5bc}\x05\x4c\x27\x02\u{5bc}\u{5bd}\x07\x18\x02\x02\u{5bd}\
	\u{5be}\x05\x4e\x28\x02\u{5be}\u{159}\x03\x02\x02\x02\u{5bf}\u{5c0}\x05\
	\x02\x02\x02\u{5c0}\u{15b}\x03\x02\x02\x02\u{5c1}\u{5c2}\x05\x02\x02\x02\
	\u{5c2}\u{15d}\x03\x02\x02\x02\u{5c3}\u{5c4}\x05\x02\x02\x02\u{5c4}\u{15f}\
	\x03\x02\x02\x02\u{5c5}\u{5c6}\x05\x02\x02\x02\u{5c6}\u{161}\x03\x02\x02\
	\x02\u{5c7}\u{5c8}\x05\x02\x02\x02\u{5c8}\u{163}\x03\x02\x02\x02\u{5c9}\
	\u{5ca}\x05\x02\x02\x02\u{5ca}\u{165}\x03\x02\x02\x02\u{5cb}\u{5cc}\x05\
	\u{246}\u{124}\x02\u{5cc}\u{167}\x03\x02\x02\x02\u{5cd}\u{5ce}\x07\u{84}\
	\x02\x02\u{5ce}\u{5cf}\x05\u{164}\u{b3}\x02\u{5cf}\u{5d0}\x07\x18\x02\x02\
	\u{5d0}\u{5d1}\x05\u{15c}\u{af}\x02\u{5d1}\u{5d2}\x07\x18\x02\x02\u{5d2}\
	\u{5d3}\x05\u{15e}\u{b0}\x02\u{5d3}\u{169}\x03\x02\x02\x02\u{5d4}\u{5d5}\
	\x07\u{85}\x02\x02\u{5d5}\u{5d6}\x05\u{164}\u{b3}\x02\u{5d6}\u{5d7}\x07\
	\x18\x02\x02\u{5d7}\u{5d8}\x05\u{15c}\u{af}\x02\u{5d8}\u{5d9}\x07\x18\x02\
	\x02\u{5d9}\u{5da}\x05\u{15e}\u{b0}\x02\u{5da}\u{16b}\x03\x02\x02\x02\u{5db}\
	\u{5dc}\x07\u{86}\x02\x02\u{5dc}\u{5dd}\x05\u{164}\u{b3}\x02\u{5dd}\u{5de}\
	\x07\x18\x02\x02\u{5de}\u{5df}\x05\u{15c}\u{af}\x02\u{5df}\u{5e0}\x07\x18\
	\x02\x02\u{5e0}\u{5e1}\x05\u{15e}\u{b0}\x02\u{5e1}\u{16d}\x03\x02\x02\x02\
	\u{5e2}\u{5e3}\x07\u{87}\x02\x02\u{5e3}\u{5e4}\x05\u{164}\u{b3}\x02\u{5e4}\
	\u{5e5}\x07\x18\x02\x02\u{5e5}\u{5e6}\x05\u{15c}\u{af}\x02\u{5e6}\u{5e7}\
	\x07\x18\x02\x02\u{5e7}\u{5e8}\x05\u{15e}\u{b0}\x02\u{5e8}\u{16f}\x03\x02\
	\x02\x02\u{5e9}\u{5ea}\x07\u{88}\x02\x02\u{5ea}\u{5eb}\x05\u{164}\u{b3}\
	\x02\u{5eb}\u{5ec}\x07\x18\x02\x02\u{5ec}\u{5ed}\x05\u{15c}\u{af}\x02\u{5ed}\
	\u{5ee}\x07\x18\x02\x02\u{5ee}\u{5ef}\x05\u{15e}\u{b0}\x02\u{5ef}\u{171}\
	\x03\x02\x02\x02\u{5f0}\u{5f1}\x07\u{89}\x02\x02\u{5f1}\u{5f2}\x05\u{164}\
	\u{b3}\x02\u{5f2}\u{5f3}\x07\x18\x02\x02\u{5f3}\u{5f4}\x05\u{15c}\u{af}\
	\x02\u{5f4}\u{5f5}\x07\x18\x02\x02\u{5f5}\u{5f6}\x05\u{15e}\u{b0}\x02\u{5f6}\
	\u{173}\x03\x02\x02\x02\u{5f7}\u{5f8}\x07\u{8a}\x02\x02\u{5f8}\u{5f9}\x05\
	\u{164}\u{b3}\x02\u{5f9}\u{5fa}\x07\x18\x02\x02\u{5fa}\u{5fb}\x05\u{15c}\
	\u{af}\x02\u{5fb}\u{5fc}\x07\x18\x02\x02\u{5fc}\u{5fd}\x05\u{15e}\u{b0}\
	\x02\u{5fd}\u{175}\x03\x02\x02\x02\u{5fe}\u{5ff}\x07\u{8b}\x02\x02\u{5ff}\
	\u{600}\x05\u{162}\u{b2}\x02\u{600}\u{601}\x07\x18\x02\x02\u{601}\u{602}\
	\x05\u{15c}\u{af}\x02\u{602}\u{603}\x07\x18\x02\x02\u{603}\u{604}\x05\u{15e}\
	\u{b0}\x02\u{604}\u{177}\x03\x02\x02\x02\u{605}\u{606}\x07\u{8c}\x02\x02\
	\u{606}\u{607}\x05\u{162}\u{b2}\x02\u{607}\u{608}\x07\x18\x02\x02\u{608}\
	\u{609}\x05\u{15c}\u{af}\x02\u{609}\u{60a}\x07\x18\x02\x02\u{60a}\u{60b}\
	\x05\u{15e}\u{b0}\x02\u{60b}\u{179}\x03\x02\x02\x02\u{60c}\u{60d}\x07\u{8d}\
	\x02\x02\u{60d}\u{60e}\x05\u{162}\u{b2}\x02\u{60e}\u{60f}\x07\x18\x02\x02\
	\u{60f}\u{610}\x05\u{15c}\u{af}\x02\u{610}\u{611}\x07\x18\x02\x02\u{611}\
	\u{612}\x05\u{15e}\u{b0}\x02\u{612}\u{17b}\x03\x02\x02\x02\u{613}\u{614}\
	\x07\u{8e}\x02\x02\u{614}\u{615}\x05\u{162}\u{b2}\x02\u{615}\u{616}\x07\
	\x18\x02\x02\u{616}\u{617}\x05\u{15c}\u{af}\x02\u{617}\u{618}\x07\x18\x02\
	\x02\u{618}\u{619}\x05\u{15e}\u{b0}\x02\u{619}\u{17d}\x03\x02\x02\x02\u{61a}\
	\u{61b}\x07\u{8f}\x02\x02\u{61b}\u{61c}\x05\u{162}\u{b2}\x02\u{61c}\u{61d}\
	\x07\x18\x02\x02\u{61d}\u{61e}\x05\u{15c}\u{af}\x02\u{61e}\u{61f}\x07\x18\
	\x02\x02\u{61f}\u{620}\x05\u{15e}\u{b0}\x02\u{620}\u{17f}\x03\x02\x02\x02\
	\u{621}\u{622}\x07\u{90}\x02\x02\u{622}\u{623}\x05\u{162}\u{b2}\x02\u{623}\
	\u{624}\x07\x18\x02\x02\u{624}\u{625}\x05\u{15c}\u{af}\x02\u{625}\u{626}\
	\x07\x18\x02\x02\u{626}\u{627}\x05\u{15e}\u{b0}\x02\u{627}\u{181}\x03\x02\
	\x02\x02\u{628}\u{629}\x07\u{91}\x02\x02\u{629}\u{62a}\x05\u{162}\u{b2}\
	\x02\u{62a}\u{62b}\x07\x18\x02\x02\u{62b}\u{62c}\x05\u{15c}\u{af}\x02\u{62c}\
	\u{62d}\x07\x18\x02\x02\u{62d}\u{62e}\x05\u{15e}\u{b0}\x02\u{62e}\u{183}\
	\x03\x02\x02\x02\u{62f}\u{630}\x07\u{92}\x02\x02\u{630}\u{631}\x05\u{164}\
	\u{b3}\x02\u{631}\u{632}\x07\x18\x02\x02\u{632}\u{633}\x05\u{160}\u{b1}\
	\x02\u{633}\u{634}\x07\x18\x02\x02\u{634}\u{635}\x05\u{166}\u{b4}\x02\u{635}\
	\u{185}\x03\x02\x02\x02\u{636}\u{637}\x07\u{93}\x02\x02\u{637}\u{638}\x05\
	\u{164}\u{b3}\x02\u{638}\u{639}\x07\x18\x02\x02\u{639}\u{63a}\x05\u{160}\
	\u{b1}\x02\u{63a}\u{63b}\x07\x18\x02\x02\u{63b}\u{63c}\x05\u{166}\u{b4}\
	\x02\u{63c}\u{187}\x03\x02\x02\x02\u{63d}\u{63e}\x07\u{94}\x02\x02\u{63e}\
	\u{63f}\x05\u{164}\u{b3}\x02\u{63f}\u{640}\x07\x18\x02\x02\u{640}\u{641}\
	\x05\u{160}\u{b1}\x02\u{641}\u{642}\x07\x18\x02\x02\u{642}\u{643}\x05\u{166}\
	\u{b4}\x02\u{643}\u{189}\x03\x02\x02\x02\u{644}\u{645}\x07\u{95}\x02\x02\
	\u{645}\u{646}\x05\u{164}\u{b3}\x02\u{646}\u{647}\x07\x18\x02\x02\u{647}\
	\u{648}\x05\u{160}\u{b1}\x02\u{648}\u{649}\x07\x18\x02\x02\u{649}\u{64a}\
	\x05\u{166}\u{b4}\x02\u{64a}\u{18b}\x03\x02\x02\x02\u{64b}\u{64c}\x07\u{96}\
	\x02\x02\u{64c}\u{64d}\x05\u{164}\u{b3}\x02\u{64d}\u{64e}\x07\x18\x02\x02\
	\u{64e}\u{64f}\x05\u{160}\u{b1}\x02\u{64f}\u{650}\x07\x18\x02\x02\u{650}\
	\u{651}\x05\u{166}\u{b4}\x02\u{651}\u{18d}\x03\x02\x02\x02\u{652}\u{653}\
	\x07\u{97}\x02\x02\u{653}\u{654}\x05\u{164}\u{b3}\x02\u{654}\u{655}\x07\
	\x18\x02\x02\u{655}\u{656}\x05\u{160}\u{b1}\x02\u{656}\u{657}\x07\x18\x02\
	\x02\u{657}\u{658}\x05\u{166}\u{b4}\x02\u{658}\u{18f}\x03\x02\x02\x02\u{659}\
	\u{65a}\x07\u{98}\x02\x02\u{65a}\u{65b}\x05\u{164}\u{b3}\x02\u{65b}\u{65c}\
	\x07\x18\x02\x02\u{65c}\u{65d}\x05\u{160}\u{b1}\x02\u{65d}\u{65e}\x07\x18\
	\x02\x02\u{65e}\u{65f}\x05\u{166}\u{b4}\x02\u{65f}\u{191}\x03\x02\x02\x02\
	\u{660}\u{661}\x07\u{99}\x02\x02\u{661}\u{662}\x05\u{162}\u{b2}\x02\u{662}\
	\u{663}\x07\x18\x02\x02\u{663}\u{664}\x05\u{160}\u{b1}\x02\u{664}\u{665}\
	\x07\x18\x02\x02\u{665}\u{666}\x05\u{166}\u{b4}\x02\u{666}\u{193}\x03\x02\
	\x02\x02\u{667}\u{668}\x07\u{9a}\x02\x02\u{668}\u{669}\x05\u{162}\u{b2}\
	\x02\u{669}\u{66a}\x07\x18\x02\x02\u{66a}\u{66b}\x05\u{160}\u{b1}\x02\u{66b}\
	\u{66c}\x07\x18\x02\x02\u{66c}\u{66d}\x05\u{166}\u{b4}\x02\u{66d}\u{195}\
	\x03\x02\x02\x02\u{66e}\u{66f}\x07\u{9b}\x02\x02\u{66f}\u{670}\x05\u{162}\
	\u{b2}\x02\u{670}\u{671}\x07\x18\x02\x02\u{671}\u{672}\x05\u{160}\u{b1}\
	\x02\u{672}\u{673}\x07\x18\x02\x02\u{673}\u{674}\x05\u{166}\u{b4}\x02\u{674}\
	\u{197}\x03\x02\x02\x02\u{675}\u{676}\x07\u{9c}\x02\x02\u{676}\u{677}\x05\
	\u{162}\u{b2}\x02\u{677}\u{678}\x07\x18\x02\x02\u{678}\u{679}\x05\u{160}\
	\u{b1}\x02\u{679}\u{67a}\x07\x18\x02\x02\u{67a}\u{67b}\x05\u{166}\u{b4}\
	\x02\u{67b}\u{199}\x03\x02\x02\x02\u{67c}\u{67d}\x07\u{9d}\x02\x02\u{67d}\
	\u{67e}\x05\u{162}\u{b2}\x02\u{67e}\u{67f}\x07\x18\x02\x02\u{67f}\u{680}\
	\x05\u{160}\u{b1}\x02\u{680}\u{681}\x07\x18\x02\x02\u{681}\u{682}\x05\u{166}\
	\u{b4}\x02\u{682}\u{19b}\x03\x02\x02\x02\u{683}\u{684}\x07\u{9e}\x02\x02\
	\u{684}\u{685}\x05\u{162}\u{b2}\x02\u{685}\u{686}\x07\x18\x02\x02\u{686}\
	\u{687}\x05\u{160}\u{b1}\x02\u{687}\u{688}\x07\x18\x02\x02\u{688}\u{689}\
	\x05\u{166}\u{b4}\x02\u{689}\u{19d}\x03\x02\x02\x02\u{68a}\u{68b}\x07\u{9f}\
	\x02\x02\u{68b}\u{68c}\x05\u{162}\u{b2}\x02\u{68c}\u{68d}\x07\x18\x02\x02\
	\u{68d}\u{68e}\x05\u{160}\u{b1}\x02\u{68e}\u{68f}\x07\x18\x02\x02\u{68f}\
	\u{690}\x05\u{166}\u{b4}\x02\u{690}\u{19f}\x03\x02\x02\x02\u{691}\u{692}\
	\x07\u{cd}\x02\x02\u{692}\u{693}\x05\u{164}\u{b3}\x02\u{693}\u{694}\x07\
	\x18\x02\x02\u{694}\u{695}\x05\x4c\x27\x02\u{695}\u{696}\x07\x18\x02\x02\
	\u{696}\u{697}\x05\x4e\x28\x02\u{697}\u{1a1}\x03\x02\x02\x02\u{698}\u{699}\
	\x07\u{ce}\x02\x02\u{699}\u{69a}\x05\u{164}\u{b3}\x02\u{69a}\u{69b}\x07\
	\x18\x02\x02\u{69b}\u{69c}\x05\x4c\x27\x02\u{69c}\u{69d}\x07\x18\x02\x02\
	\u{69d}\u{69e}\x05\x4e\x28\x02\u{69e}\u{1a3}\x03\x02\x02\x02\u{69f}\u{6a0}\
	\x07\u{cf}\x02\x02\u{6a0}\u{6a1}\x05\u{164}\u{b3}\x02\u{6a1}\u{6a2}\x07\
	\x18\x02\x02\u{6a2}\u{6a3}\x05\x4c\x27\x02\u{6a3}\u{6a4}\x07\x18\x02\x02\
	\u{6a4}\u{6a5}\x05\x4e\x28\x02\u{6a5}\u{1a5}\x03\x02\x02\x02\u{6a6}\u{6a7}\
	\x07\u{d0}\x02\x02\u{6a7}\u{6a8}\x05\u{164}\u{b3}\x02\u{6a8}\u{6a9}\x07\
	\x18\x02\x02\u{6a9}\u{6aa}\x05\x4c\x27\x02\u{6aa}\u{6ab}\x07\x18\x02\x02\
	\u{6ab}\u{6ac}\x05\x4e\x28\x02\u{6ac}\u{1a7}\x03\x02\x02\x02\u{6ad}\u{6ae}\
	\x07\u{d1}\x02\x02\u{6ae}\u{6af}\x05\u{164}\u{b3}\x02\u{6af}\u{6b0}\x07\
	\x18\x02\x02\u{6b0}\u{6b1}\x05\x4c\x27\x02\u{6b1}\u{6b2}\x07\x18\x02\x02\
	\u{6b2}\u{6b3}\x05\x4e\x28\x02\u{6b3}\u{1a9}\x03\x02\x02\x02\u{6b4}\u{6b5}\
	\x07\u{d2}\x02\x02\u{6b5}\u{6b6}\x05\u{164}\u{b3}\x02\u{6b6}\u{6b7}\x07\
	\x18\x02\x02\u{6b7}\u{6b8}\x05\x4c\x27\x02\u{6b8}\u{6b9}\x07\x18\x02\x02\
	\u{6b9}\u{6ba}\x05\x4e\x28\x02\u{6ba}\u{1ab}\x03\x02\x02\x02\u{6bb}\u{6bc}\
	\x07\u{d3}\x02\x02\u{6bc}\u{6bd}\x05\u{164}\u{b3}\x02\u{6bd}\u{6be}\x07\
	\x18\x02\x02\u{6be}\u{6bf}\x05\x4c\x27\x02\u{6bf}\u{6c0}\x07\x18\x02\x02\
	\u{6c0}\u{6c1}\x05\x4e\x28\x02\u{6c1}\u{1ad}\x03\x02\x02\x02\u{6c2}\u{6c3}\
	\x07\u{d4}\x02\x02\u{6c3}\u{6c4}\x05\u{164}\u{b3}\x02\u{6c4}\u{6c5}\x07\
	\x18\x02\x02\u{6c5}\u{6c6}\x05\x4c\x27\x02\u{6c6}\u{6c7}\x07\x18\x02\x02\
	\u{6c7}\u{6c8}\x05\x4e\x28\x02\u{6c8}\u{1af}\x03\x02\x02\x02\u{6c9}\u{6ca}\
	\x07\u{d5}\x02\x02\u{6ca}\u{6cb}\x05\u{164}\u{b3}\x02\u{6cb}\u{6cc}\x07\
	\x18\x02\x02\u{6cc}\u{6cd}\x05\x4c\x27\x02\u{6cd}\u{6ce}\x07\x18\x02\x02\
	\u{6ce}\u{6cf}\x05\x4e\x28\x02\u{6cf}\u{1b1}\x03\x02\x02\x02\u{6d0}\u{6d1}\
	\x07\u{d6}\x02\x02\u{6d1}\u{6d2}\x05\u{164}\u{b3}\x02\u{6d2}\u{6d3}\x07\
	\x18\x02\x02\u{6d3}\u{6d4}\x05\x4c\x27\x02\u{6d4}\u{6d5}\x07\x18\x02\x02\
	\u{6d5}\u{6d6}\x05\x4e\x28\x02\u{6d6}\u{1b3}\x03\x02\x02\x02\u{6d7}\u{6d8}\
	\x07\u{d7}\x02\x02\u{6d8}\u{6d9}\x05\u{164}\u{b3}\x02\u{6d9}\u{6da}\x07\
	\x18\x02\x02\u{6da}\u{6db}\x05\x4c\x27\x02\u{6db}\u{6dc}\x07\x18\x02\x02\
	\u{6dc}\u{6dd}\x05\x4e\x28\x02\u{6dd}\u{1b5}\x03\x02\x02\x02\u{6de}\u{6df}\
	\x07\u{10e}\x02\x02\u{6df}\u{6e0}\x05\u{164}\u{b3}\x02\u{6e0}\u{6e1}\x07\
	\x18\x02\x02\u{6e1}\u{6e2}\x05\x4c\x27\x02\u{6e2}\u{6e3}\x07\x18\x02\x02\
	\u{6e3}\u{6e4}\x05\x4e\x28\x02\u{6e4}\u{1b7}\x03\x02\x02\x02\u{6e5}\u{6e6}\
	\x07\u{d8}\x02\x02\u{6e6}\u{6e7}\x05\u{164}\u{b3}\x02\u{6e7}\u{6e8}\x07\
	\x18\x02\x02\u{6e8}\u{6e9}\x05\x4c\x27\x02\u{6e9}\u{6ea}\x07\x18\x02\x02\
	\u{6ea}\u{6eb}\x05\x4e\x28\x02\u{6eb}\u{1b9}\x03\x02\x02\x02\u{6ec}\u{6ed}\
	\x07\u{d9}\x02\x02\u{6ed}\u{6ee}\x05\u{164}\u{b3}\x02\u{6ee}\u{6ef}\x07\
	\x18\x02\x02\u{6ef}\u{6f0}\x05\x4c\x27\x02\u{6f0}\u{6f1}\x07\x18\x02\x02\
	\u{6f1}\u{6f2}\x05\x4e\x28\x02\u{6f2}\u{1bb}\x03\x02\x02\x02\u{6f3}\u{6f4}\
	\x07\u{da}\x02\x02\u{6f4}\u{6f5}\x05\u{164}\u{b3}\x02\u{6f5}\u{6f6}\x07\
	\x18\x02\x02\u{6f6}\u{6f7}\x05\x4c\x27\x02\u{6f7}\u{6f8}\x07\x18\x02\x02\
	\u{6f8}\u{6f9}\x05\x4e\x28\x02\u{6f9}\u{1bd}\x03\x02\x02\x02\u{6fa}\u{6fb}\
	\x07\u{db}\x02\x02\u{6fb}\u{6fc}\x05\u{164}\u{b3}\x02\u{6fc}\u{6fd}\x07\
	\x18\x02\x02\u{6fd}\u{6fe}\x05\x4c\x27\x02\u{6fe}\u{6ff}\x07\x18\x02\x02\
	\u{6ff}\u{700}\x05\x4e\x28\x02\u{700}\u{1bf}\x03\x02\x02\x02\u{701}\u{702}\
	\x07\u{dc}\x02\x02\u{702}\u{703}\x05\u{164}\u{b3}\x02\u{703}\u{704}\x07\
	\x18\x02\x02\u{704}\u{705}\x05\x4c\x27\x02\u{705}\u{706}\x07\x18\x02\x02\
	\u{706}\u{707}\x05\x4e\x28\x02\u{707}\u{1c1}\x03\x02\x02\x02\u{708}\u{709}\
	\x07\u{dd}\x02\x02\u{709}\u{70a}\x05\u{164}\u{b3}\x02\u{70a}\u{70b}\x07\
	\x18\x02\x02\u{70b}\u{70c}\x05\x4c\x27\x02\u{70c}\u{70d}\x07\x18\x02\x02\
	\u{70d}\u{70e}\x05\x4e\x28\x02\u{70e}\u{1c3}\x03\x02\x02\x02\u{70f}\u{710}\
	\x07\u{de}\x02\x02\u{710}\u{711}\x05\u{164}\u{b3}\x02\u{711}\u{712}\x07\
	\x18\x02\x02\u{712}\u{713}\x05\x4c\x27\x02\u{713}\u{714}\x07\x18\x02\x02\
	\u{714}\u{715}\x05\x4e\x28\x02\u{715}\u{1c5}\x03\x02\x02\x02\u{716}\u{717}\
	\x07\u{df}\x02\x02\u{717}\u{718}\x05\u{164}\u{b3}\x02\u{718}\u{719}\x07\
	\x18\x02\x02\u{719}\u{71a}\x05\x4c\x27\x02\u{71a}\u{71b}\x07\x18\x02\x02\
	\u{71b}\u{71c}\x05\x4e\x28\x02\u{71c}\u{1c7}\x03\x02\x02\x02\u{71d}\u{71e}\
	\x07\u{e0}\x02\x02\u{71e}\u{71f}\x05\u{164}\u{b3}\x02\u{71f}\u{720}\x07\
	\x18\x02\x02\u{720}\u{721}\x05\x4c\x27\x02\u{721}\u{722}\x07\x18\x02\x02\
	\u{722}\u{723}\x05\x4e\x28\x02\u{723}\u{1c9}\x03\x02\x02\x02\u{724}\u{725}\
	\x07\u{e1}\x02\x02\u{725}\u{726}\x05\u{164}\u{b3}\x02\u{726}\u{727}\x07\
	\x18\x02\x02\u{727}\u{728}\x05\x4c\x27\x02\u{728}\u{729}\x07\x18\x02\x02\
	\u{729}\u{72a}\x05\x4e\x28\x02\u{72a}\u{1cb}\x03\x02\x02\x02\u{72b}\u{72c}\
	\x07\u{e2}\x02\x02\u{72c}\u{72d}\x05\u{164}\u{b3}\x02\u{72d}\u{72e}\x07\
	\x18\x02\x02\u{72e}\u{72f}\x05\x4c\x27\x02\u{72f}\u{730}\x07\x18\x02\x02\
	\u{730}\u{731}\x05\x4e\x28\x02\u{731}\u{1cd}\x03\x02\x02\x02\u{732}\u{733}\
	\x07\u{e3}\x02\x02\u{733}\u{734}\x05\u{164}\u{b3}\x02\u{734}\u{735}\x07\
	\x18\x02\x02\u{735}\u{736}\x05\x4c\x27\x02\u{736}\u{737}\x07\x18\x02\x02\
	\u{737}\u{738}\x05\x4e\x28\x02\u{738}\u{1cf}\x03\x02\x02\x02\u{739}\u{73a}\
	\x07\u{e4}\x02\x02\u{73a}\u{73b}\x05\u{164}\u{b3}\x02\u{73b}\u{73c}\x07\
	\x18\x02\x02\u{73c}\u{73d}\x05\x4c\x27\x02\u{73d}\u{73e}\x07\x18\x02\x02\
	\u{73e}\u{73f}\x05\x4e\x28\x02\u{73f}\u{1d1}\x03\x02\x02\x02\u{740}\u{741}\
	\x07\u{e5}\x02\x02\u{741}\u{742}\x05\u{164}\u{b3}\x02\u{742}\u{743}\x07\
	\x18\x02\x02\u{743}\u{744}\x05\x4c\x27\x02\u{744}\u{745}\x07\x18\x02\x02\
	\u{745}\u{746}\x05\x4e\x28\x02\u{746}\u{1d3}\x03\x02\x02\x02\u{747}\u{748}\
	\x07\u{e6}\x02\x02\u{748}\u{749}\x05\u{164}\u{b3}\x02\u{749}\u{74a}\x07\
	\x18\x02\x02\u{74a}\u{74b}\x05\x4c\x27\x02\u{74b}\u{74c}\x07\x18\x02\x02\
	\u{74c}\u{74d}\x05\x4e\x28\x02\u{74d}\u{1d5}\x03\x02\x02\x02\u{74e}\u{74f}\
	\x07\u{e7}\x02\x02\u{74f}\u{750}\x05\u{164}\u{b3}\x02\u{750}\u{751}\x07\
	\x18\x02\x02\u{751}\u{752}\x05\x4c\x27\x02\u{752}\u{753}\x07\x18\x02\x02\
	\u{753}\u{754}\x05\x4e\x28\x02\u{754}\u{1d7}\x03\x02\x02\x02\u{755}\u{756}\
	\x07\u{e8}\x02\x02\u{756}\u{757}\x05\u{164}\u{b3}\x02\u{757}\u{758}\x07\
	\x18\x02\x02\u{758}\u{759}\x05\x4c\x27\x02\u{759}\u{75a}\x07\x18\x02\x02\
	\u{75a}\u{75b}\x05\x4e\x28\x02\u{75b}\u{1d9}\x03\x02\x02\x02\u{75c}\u{75d}\
	\x07\u{e9}\x02\x02\u{75d}\u{75e}\x05\u{164}\u{b3}\x02\u{75e}\u{75f}\x07\
	\x18\x02\x02\u{75f}\u{760}\x05\x4c\x27\x02\u{760}\u{761}\x07\x18\x02\x02\
	\u{761}\u{762}\x05\x4e\x28\x02\u{762}\u{1db}\x03\x02\x02\x02\u{763}\u{764}\
	\x07\u{ea}\x02\x02\u{764}\u{765}\x05\u{164}\u{b3}\x02\u{765}\u{766}\x07\
	\x18\x02\x02\u{766}\u{767}\x05\x4c\x27\x02\u{767}\u{768}\x07\x18\x02\x02\
	\u{768}\u{769}\x05\x4e\x28\x02\u{769}\u{1dd}\x03\x02\x02\x02\u{76a}\u{76b}\
	\x07\u{eb}\x02\x02\u{76b}\u{76c}\x05\u{164}\u{b3}\x02\u{76c}\u{76d}\x07\
	\x18\x02\x02\u{76d}\u{76e}\x05\x4c\x27\x02\u{76e}\u{76f}\x07\x18\x02\x02\
	\u{76f}\u{770}\x05\x4e\x28\x02\u{770}\u{1df}\x03\x02\x02\x02\u{771}\u{772}\
	\x07\u{ec}\x02\x02\u{772}\u{773}\x05\u{164}\u{b3}\x02\u{773}\u{774}\x07\
	\x18\x02\x02\u{774}\u{775}\x05\x4c\x27\x02\u{775}\u{776}\x07\x18\x02\x02\
	\u{776}\u{777}\x05\x4e\x28\x02\u{777}\u{1e1}\x03\x02\x02\x02\u{778}\u{779}\
	\x07\u{10d}\x02\x02\u{779}\u{77a}\x05\u{164}\u{b3}\x02\u{77a}\u{77b}\x07\
	\x18\x02\x02\u{77b}\u{77c}\x05\x4c\x27\x02\u{77c}\u{77d}\x07\x18\x02\x02\
	\u{77d}\u{77e}\x05\x16\x0c\x02\u{77e}\u{1e3}\x03\x02\x02\x02\u{77f}\u{780}\
	\x07\u{10f}\x02\x02\u{780}\u{781}\x05\u{164}\u{b3}\x02\u{781}\u{782}\x07\
	\x18\x02\x02\u{782}\u{783}\x05\x4c\x27\x02\u{783}\u{784}\x07\x18\x02\x02\
	\u{784}\u{785}\x05\x16\x0c\x02\u{785}\u{1e5}\x03\x02\x02\x02\u{786}\u{787}\
	\x07\u{110}\x02\x02\u{787}\u{788}\x05\u{164}\u{b3}\x02\u{788}\u{789}\x07\
	\x18\x02\x02\u{789}\u{78a}\x05\x4c\x27\x02\u{78a}\u{78b}\x07\x18\x02\x02\
	\u{78b}\u{78c}\x05\x16\x0c\x02\u{78c}\u{1e7}\x03\x02\x02\x02\u{78d}\u{78e}\
	\x07\u{111}\x02\x02\u{78e}\u{78f}\x05\u{164}\u{b3}\x02\u{78f}\u{790}\x07\
	\x18\x02\x02\u{790}\u{791}\x05\x4c\x27\x02\u{791}\u{792}\x07\x18\x02\x02\
	\u{792}\u{793}\x05\x16\x0c\x02\u{793}\u{1e9}\x03\x02\x02\x02\u{794}\u{795}\
	\x07\u{112}\x02\x02\u{795}\u{796}\x05\u{164}\u{b3}\x02\u{796}\u{797}\x07\
	\x18\x02\x02\u{797}\u{798}\x05\x4c\x27\x02\u{798}\u{799}\x07\x18\x02\x02\
	\u{799}\u{79a}\x05\x16\x0c\x02\u{79a}\u{1eb}\x03\x02\x02\x02\u{79b}\u{79c}\
	\x07\u{113}\x02\x02\u{79c}\u{79d}\x05\u{164}\u{b3}\x02\u{79d}\u{79e}\x07\
	\x18\x02\x02\u{79e}\u{79f}\x05\x4c\x27\x02\u{79f}\u{7a0}\x07\x18\x02\x02\
	\u{7a0}\u{7a1}\x05\x16\x0c\x02\u{7a1}\u{1ed}\x03\x02\x02\x02\u{7a2}\u{7a3}\
	\x07\u{114}\x02\x02\u{7a3}\u{7a4}\x05\u{164}\u{b3}\x02\u{7a4}\u{7a5}\x07\
	\x18\x02\x02\u{7a5}\u{7a6}\x05\x4c\x27\x02\u{7a6}\u{7a7}\x07\x18\x02\x02\
	\u{7a7}\u{7a8}\x05\x16\x0c\x02\u{7a8}\u{1ef}\x03\x02\x02\x02\u{7a9}\u{7aa}\
	\x07\u{115}\x02\x02\u{7aa}\u{7ab}\x05\u{164}\u{b3}\x02\u{7ab}\u{7ac}\x07\
	\x18\x02\x02\u{7ac}\u{7ad}\x05\x4c\x27\x02\u{7ad}\u{7ae}\x07\x18\x02\x02\
	\u{7ae}\u{7af}\x05\x16\x0c\x02\u{7af}\u{1f1}\x03\x02\x02\x02\u{7b0}\u{7b1}\
	\x07\u{116}\x02\x02\u{7b1}\u{7b2}\x05\u{164}\u{b3}\x02\u{7b2}\u{7b3}\x07\
	\x18\x02\x02\u{7b3}\u{7b4}\x05\x4c\x27\x02\u{7b4}\u{7b5}\x07\x18\x02\x02\
	\u{7b5}\u{7b6}\x05\x16\x0c\x02\u{7b6}\u{1f3}\x03\x02\x02\x02\u{7b7}\u{7b8}\
	\x07\u{117}\x02\x02\u{7b8}\u{7b9}\x05\u{164}\u{b3}\x02\u{7b9}\u{7ba}\x07\
	\x18\x02\x02\u{7ba}\u{7bb}\x05\x4c\x27\x02\u{7bb}\u{7bc}\x07\x18\x02\x02\
	\u{7bc}\u{7bd}\x05\x16\x0c\x02\u{7bd}\u{1f5}\x03\x02\x02\x02\u{7be}\u{7bf}\
	\x07\u{118}\x02\x02\u{7bf}\u{7c0}\x05\u{164}\u{b3}\x02\u{7c0}\u{7c1}\x07\
	\x18\x02\x02\u{7c1}\u{7c2}\x05\x4c\x27\x02\u{7c2}\u{7c3}\x07\x18\x02\x02\
	\u{7c3}\u{7c4}\x05\x16\x0c\x02\u{7c4}\u{1f7}\x03\x02\x02\x02\u{7c5}\u{7c6}\
	\x07\u{119}\x02\x02\u{7c6}\u{7c7}\x05\u{164}\u{b3}\x02\u{7c7}\u{7c8}\x07\
	\x18\x02\x02\u{7c8}\u{7c9}\x05\x4c\x27\x02\u{7c9}\u{7ca}\x07\x18\x02\x02\
	\u{7ca}\u{7cb}\x05\x16\x0c\x02\u{7cb}\u{1f9}\x03\x02\x02\x02\u{7cc}\u{7cd}\
	\x07\u{11a}\x02\x02\u{7cd}\u{7ce}\x05\u{164}\u{b3}\x02\u{7ce}\u{7cf}\x07\
	\x18\x02\x02\u{7cf}\u{7d0}\x05\x4c\x27\x02\u{7d0}\u{7d1}\x07\x18\x02\x02\
	\u{7d1}\u{7d2}\x05\x16\x0c\x02\u{7d2}\u{1fb}\x03\x02\x02\x02\u{7d3}\u{7d4}\
	\x07\u{11b}\x02\x02\u{7d4}\u{7d5}\x05\u{164}\u{b3}\x02\u{7d5}\u{7d6}\x07\
	\x18\x02\x02\u{7d6}\u{7d7}\x05\x4c\x27\x02\u{7d7}\u{7d8}\x07\x18\x02\x02\
	\u{7d8}\u{7d9}\x05\x16\x0c\x02\u{7d9}\u{1fd}\x03\x02\x02\x02\u{7da}\u{7db}\
	\x07\u{11c}\x02\x02\u{7db}\u{7dc}\x05\u{164}\u{b3}\x02\u{7dc}\u{7dd}\x07\
	\x18\x02\x02\u{7dd}\u{7de}\x05\x4c\x27\x02\u{7de}\u{7df}\x07\x18\x02\x02\
	\u{7df}\u{7e0}\x05\x16\x0c\x02\u{7e0}\u{1ff}\x03\x02\x02\x02\u{7e1}\u{7e2}\
	\x07\u{11d}\x02\x02\u{7e2}\u{7e3}\x05\u{164}\u{b3}\x02\u{7e3}\u{7e4}\x07\
	\x18\x02\x02\u{7e4}\u{7e5}\x05\x4c\x27\x02\u{7e5}\u{7e6}\x07\x18\x02\x02\
	\u{7e6}\u{7e7}\x05\x16\x0c\x02\u{7e7}\u{201}\x03\x02\x02\x02\u{7e8}\u{7e9}\
	\x07\u{11e}\x02\x02\u{7e9}\u{7ea}\x05\u{164}\u{b3}\x02\u{7ea}\u{7eb}\x07\
	\x18\x02\x02\u{7eb}\u{7ec}\x05\x4c\x27\x02\u{7ec}\u{7ed}\x07\x18\x02\x02\
	\u{7ed}\u{7ee}\x05\x16\x0c\x02\u{7ee}\u{203}\x03\x02\x02\x02\u{7ef}\u{7f0}\
	\x07\u{11f}\x02\x02\u{7f0}\u{7f1}\x05\u{164}\u{b3}\x02\u{7f1}\u{7f2}\x07\
	\x18\x02\x02\u{7f2}\u{7f3}\x05\x4c\x27\x02\u{7f3}\u{7f4}\x07\x18\x02\x02\
	\u{7f4}\u{7f5}\x05\x16\x0c\x02\u{7f5}\u{205}\x03\x02\x02\x02\u{7f6}\u{7f7}\
	\x05\x1a\x0e\x02\u{7f7}\u{207}\x03\x02\x02\x02\u{7f8}\u{7f9}\x07\x6a\x02\
	\x02\u{7f9}\u{7fa}\x05\u{164}\u{b3}\x02\u{7fa}\u{7fb}\x07\x18\x02\x02\u{7fb}\
	\u{7fc}\x05\u{206}\u{104}\x02\u{7fc}\u{209}\x03\x02\x02\x02\u{7fd}\u{7fe}\
	\x05\x36\x1c\x02\u{7fe}\u{20b}\x03\x02\x02\x02\u{7ff}\u{800}\x07\x67\x02\
	\x02\u{800}\u{801}\x05\u{164}\u{b3}\x02\u{801}\u{802}\x07\x18\x02\x02\u{802}\
	\u{803}\x05\u{20a}\u{106}\x02\u{803}\u{20d}\x03\x02\x02\x02\u{804}\u{805}\
	\x07\x69\x02\x02\u{805}\u{806}\x05\u{164}\u{b3}\x02\u{806}\u{807}\x07\x18\
	\x02\x02\u{807}\u{808}\x05\u{15c}\u{af}\x02\u{808}\u{20f}\x03\x02\x02\x02\
	\u{809}\u{80a}\x05\x38\x1d\x02\u{80a}\u{211}\x03\x02\x02\x02\u{80b}\u{80c}\
	\x05\x52\x2a\x02\u{80c}\u{213}\x03\x02\x02\x02\u{80d}\u{80e}\x05\x54\x2b\
	\x02\u{80e}\u{215}\x03\x02\x02\x02\u{80f}\u{810}\x07\x6d\x02\x02\u{810}\
	\u{811}\x05\u{212}\u{10a}\x02\u{811}\u{812}\x07\x18\x02\x02\u{812}\u{813}\
	\x05\u{210}\u{109}\x02\u{813}\u{217}\x03\x02\x02\x02\u{814}\u{815}\x07\x6c\
	\x02\x02\u{815}\u{816}\x05\u{214}\u{10b}\x02\u{816}\u{817}\x07\x18\x02\x02\
	\u{817}\u{818}\x05\u{210}\u{109}\x02\u{818}\u{219}\x03\x02\x02\x02\u{819}\
	\u{81a}\x05\x4a\x26\x02\u{81a}\u{21b}\x03\x02\x02\x02\u{81b}\u{81c}\x07\
	\x6e\x02\x02\u{81c}\u{81d}\x05\u{164}\u{b3}\x02\u{81d}\u{81e}\x07\x18\x02\
	\x02\u{81e}\u{81f}\x05\u{21a}\u{10e}\x02\u{81f}\u{21d}\x03\x02\x02\x02\u{820}\
	\u{821}\x05\x38\x1d\x02\u{821}\u{21f}\x03\x02\x02\x02\u{822}\u{823}\x07\
	\x68\x02\x02\u{823}\u{824}\x05\u{164}\u{b3}\x02\u{824}\u{825}\x07\x18\x02\
	\x02\u{825}\u{826}\x05\u{160}\u{b1}\x02\u{826}\u{827}\x07\x18\x02\x02\u{827}\
	\u{828}\x05\u{21e}\u{110}\x02\u{828}\u{221}\x03\x02\x02\x02\u{829}\u{82a}\
	\x05\x02\x02\x02\u{82a}\u{223}\x03\x02\x02\x02\u{82b}\u{82c}\x07\x6b\x02\
	\x02\u{82c}\u{82d}\x05\u{164}\u{b3}\x02\u{82d}\u{82e}\x07\x18\x02\x02\u{82e}\
	\u{82f}\x05\u{222}\u{112}\x02\u{82f}\u{830}\x07\x18\x02\x02\u{830}\u{831}\
	\x05\u{210}\u{109}\x02\u{831}\u{225}\x03\x02\x02\x02\u{832}\u{833}\x05\x02\
	\x02\x02\u{833}\u{227}\x03\x02\x02\x02\u{834}\u{835}\x05\x4a\x26\x02\u{835}\
	\u{229}\x03\x02\x02\x02\u{836}\u{837}\x05\x02\x02\x02\u{837}\u{22b}\x03\
	\x02\x02\x02\u{838}\u{839}\x05\x4a\x26\x02\u{839}\u{22d}\x03\x02\x02\x02\
	\u{83a}\u{83b}\x07\u{126}\x02\x02\u{83b}\u{83c}\x05\u{226}\u{114}\x02\u{83c}\
	\u{83d}\x07\x18\x02\x02\u{83d}\u{83e}\x05\u{228}\u{115}\x02\u{83e}\u{22f}\
	\x03\x02\x02\x02\u{83f}\u{840}\x07\u{127}\x02\x02\u{840}\u{841}\x05\u{22a}\
	\u{116}\x02\u{841}\u{842}\x07\x18\x02\x02\u{842}\u{843}\x05\u{22c}\u{117}\
	\x02\u{843}\u{231}\x03\x02\x02\x02\u{844}\u{845}\x07\u{120}\x02\x02\u{845}\
	\u{233}\x03\x02\x02\x02\u{846}\u{847}\x07\u{121}\x02\x02\u{847}\u{235}\x03\
	\x02\x02\x02\u{848}\u{849}\x07\u{122}\x02\x02\u{849}\u{237}\x03\x02\x02\
	\x02\u{84a}\u{84b}\x07\u{123}\x02\x02\u{84b}\u{239}\x03\x02\x02\x02\u{84c}\
	\u{84d}\x07\u{124}\x02\x02\u{84d}\u{23b}\x03\x02\x02\x02\u{84e}\u{84f}\x07\
	\u{125}\x02\x02\u{84f}\u{23d}\x03\x02\x02\x02\u{850}\u{8cb}\x05\u{216}\u{10c}\
	\x02\u{851}\u{8cb}\x05\u{218}\u{10d}\x02\u{852}\u{8cb}\x05\u{21c}\u{10f}\
	\x02\u{853}\u{8cb}\x05\u{20e}\u{108}\x02\u{854}\u{8cb}\x05\u{22e}\u{118}\
	\x02\u{855}\u{8cb}\x05\u{230}\u{119}\x02\u{856}\u{8cb}\x05\u{208}\u{105}\
	\x02\u{857}\u{8cb}\x05\u{20c}\u{107}\x02\u{858}\u{8cb}\x05\x74\x3b\x02\u{859}\
	\u{8cb}\x05\x76\x3c\x02\u{85a}\u{8cb}\x05\x78\x3d\x02\u{85b}\u{8cb}\x05\
	\x7a\x3e\x02\u{85c}\u{8cb}\x05\x7c\x3f\x02\u{85d}\u{8cb}\x05\x7e\x40\x02\
	\u{85e}\u{8cb}\x05\u{80}\x41\x02\u{85f}\u{8cb}\x05\u{82}\x42\x02\u{860}\
	\u{8cb}\x05\u{84}\x43\x02\u{861}\u{8cb}\x05\u{86}\x44\x02\u{862}\u{8cb}\
	\x05\u{88}\x45\x02\u{863}\u{8cb}\x05\u{8a}\x46\x02\u{864}\u{8cb}\x05\u{8c}\
	\x47\x02\u{865}\u{8cb}\x05\u{8e}\x48\x02\u{866}\u{8cb}\x05\u{90}\x49\x02\
	\u{867}\u{8cb}\x05\u{92}\x4a\x02\u{868}\u{8cb}\x05\u{94}\x4b\x02\u{869}\
	\u{8cb}\x05\u{96}\x4c\x02\u{86a}\u{8cb}\x05\u{98}\x4d\x02\u{86b}\u{8cb}\
	\x05\u{9a}\x4e\x02\u{86c}\u{8cb}\x05\u{9c}\x4f\x02\u{86d}\u{8cb}\x05\u{9e}\
	\x50\x02\u{86e}\u{8cb}\x05\u{a0}\x51\x02\u{86f}\u{8cb}\x05\u{a2}\x52\x02\
	\u{870}\u{8cb}\x05\u{a4}\x53\x02\u{871}\u{8cb}\x05\u{a6}\x54\x02\u{872}\
	\u{8cb}\x05\u{a8}\x55\x02\u{873}\u{8cb}\x05\u{aa}\x56\x02\u{874}\u{8cb}\
	\x05\u{ac}\x57\x02\u{875}\u{8cb}\x05\u{ae}\x58\x02\u{876}\u{8cb}\x05\u{b0}\
	\x59\x02\u{877}\u{8cb}\x05\u{b2}\x5a\x02\u{878}\u{8cb}\x05\u{b4}\x5b\x02\
	\u{879}\u{8cb}\x05\u{b6}\x5c\x02\u{87a}\u{8cb}\x05\u{b8}\x5d\x02\u{87b}\
	\u{8cb}\x05\u{ba}\x5e\x02\u{87c}\u{8cb}\x05\u{bc}\x5f\x02\u{87d}\u{8cb}\
	\x05\u{be}\x60\x02\u{87e}\u{8cb}\x05\u{c0}\x61\x02\u{87f}\u{8cb}\x05\u{c2}\
	\x62\x02\u{880}\u{8cb}\x05\u{c4}\x63\x02\u{881}\u{8cb}\x05\u{c6}\x64\x02\
	\u{882}\u{8cb}\x05\u{c8}\x65\x02\u{883}\u{8cb}\x05\u{ca}\x66\x02\u{884}\
	\u{8cb}\x05\u{cc}\x67\x02\u{885}\u{8cb}\x05\u{ce}\x68\x02\u{886}\u{8cb}\
	\x05\u{d0}\x69\x02\u{887}\u{8cb}\x05\u{d2}\x6a\x02\u{888}\u{8cb}\x05\u{d4}\
	\x6b\x02\u{889}\u{8cb}\x05\u{d6}\x6c\x02\u{88a}\u{8cb}\x05\u{d8}\x6d\x02\
	\u{88b}\u{8cb}\x05\u{da}\x6e\x02\u{88c}\u{8cb}\x05\u{dc}\x6f\x02\u{88d}\
	\u{8cb}\x05\u{de}\x70\x02\u{88e}\u{8cb}\x05\u{e0}\x71\x02\u{88f}\u{8cb}\
	\x05\u{e2}\x72\x02\u{890}\u{8cb}\x05\u{e4}\x73\x02\u{891}\u{8cb}\x05\u{e6}\
	\x74\x02\u{892}\u{8cb}\x05\u{e8}\x75\x02\u{893}\u{8cb}\x05\u{ec}\x77\x02\
	\u{894}\u{8cb}\x05\u{ee}\x78\x02\u{895}\u{8cb}\x05\u{f0}\x79\x02\u{896}\
	\u{8cb}\x05\u{f2}\x7a\x02\u{897}\u{8cb}\x05\u{f4}\x7b\x02\u{898}\u{8cb}\
	\x05\u{f6}\x7c\x02\u{899}\u{8cb}\x05\u{f8}\x7d\x02\u{89a}\u{8cb}\x05\u{fa}\
	\x7e\x02\u{89b}\u{8cb}\x05\u{fc}\x7f\x02\u{89c}\u{8cb}\x05\u{fe}\u{80}\x02\
	\u{89d}\u{8cb}\x05\u{100}\u{81}\x02\u{89e}\u{8cb}\x05\u{102}\u{82}\x02\u{89f}\
	\u{8cb}\x05\u{104}\u{83}\x02\u{8a0}\u{8cb}\x05\u{106}\u{84}\x02\u{8a1}\u{8cb}\
	\x05\u{108}\u{85}\x02\u{8a2}\u{8cb}\x05\u{10a}\u{86}\x02\u{8a3}\u{8cb}\x05\
	\u{10c}\u{87}\x02\u{8a4}\u{8cb}\x05\u{10e}\u{88}\x02\u{8a5}\u{8cb}\x05\u{110}\
	\u{89}\x02\u{8a6}\u{8cb}\x05\u{112}\u{8a}\x02\u{8a7}\u{8cb}\x05\u{114}\u{8b}\
	\x02\u{8a8}\u{8cb}\x05\u{116}\u{8c}\x02\u{8a9}\u{8cb}\x05\u{118}\u{8d}\x02\
	\u{8aa}\u{8cb}\x05\u{11a}\u{8e}\x02\u{8ab}\u{8cb}\x05\u{11c}\u{8f}\x02\u{8ac}\
	\u{8cb}\x05\u{11e}\u{90}\x02\u{8ad}\u{8cb}\x05\u{120}\u{91}\x02\u{8ae}\u{8cb}\
	\x05\u{122}\u{92}\x02\u{8af}\u{8cb}\x05\u{124}\u{93}\x02\u{8b0}\u{8cb}\x05\
	\u{126}\u{94}\x02\u{8b1}\u{8cb}\x05\u{128}\u{95}\x02\u{8b2}\u{8cb}\x05\u{12a}\
	\u{96}\x02\u{8b3}\u{8cb}\x05\u{12c}\u{97}\x02\u{8b4}\u{8cb}\x05\u{12e}\u{98}\
	\x02\u{8b5}\u{8cb}\x05\u{130}\u{99}\x02\u{8b6}\u{8cb}\x05\u{132}\u{9a}\x02\
	\u{8b7}\u{8cb}\x05\u{134}\u{9b}\x02\u{8b8}\u{8cb}\x05\u{136}\u{9c}\x02\u{8b9}\
	\u{8cb}\x05\u{138}\u{9d}\x02\u{8ba}\u{8cb}\x05\u{13a}\u{9e}\x02\u{8bb}\u{8cb}\
	\x05\u{13c}\u{9f}\x02\u{8bc}\u{8cb}\x05\u{13e}\u{a0}\x02\u{8bd}\u{8cb}\x05\
	\u{140}\u{a1}\x02\u{8be}\u{8cb}\x05\u{142}\u{a2}\x02\u{8bf}\u{8cb}\x05\u{144}\
	\u{a3}\x02\u{8c0}\u{8cb}\x05\u{146}\u{a4}\x02\u{8c1}\u{8cb}\x05\u{148}\u{a5}\
	\x02\u{8c2}\u{8cb}\x05\u{14a}\u{a6}\x02\u{8c3}\u{8cb}\x05\u{14c}\u{a7}\x02\
	\u{8c4}\u{8cb}\x05\u{14e}\u{a8}\x02\u{8c5}\u{8cb}\x05\u{150}\u{a9}\x02\u{8c6}\
	\u{8cb}\x05\u{152}\u{aa}\x02\u{8c7}\u{8cb}\x05\u{154}\u{ab}\x02\u{8c8}\u{8cb}\
	\x05\u{156}\u{ac}\x02\u{8c9}\u{8cb}\x05\u{158}\u{ad}\x02\u{8ca}\u{850}\x03\
	\x02\x02\x02\u{8ca}\u{851}\x03\x02\x02\x02\u{8ca}\u{852}\x03\x02\x02\x02\
	\u{8ca}\u{853}\x03\x02\x02\x02\u{8ca}\u{854}\x03\x02\x02\x02\u{8ca}\u{855}\
	\x03\x02\x02\x02\u{8ca}\u{856}\x03\x02\x02\x02\u{8ca}\u{857}\x03\x02\x02\
	\x02\u{8ca}\u{858}\x03\x02\x02\x02\u{8ca}\u{859}\x03\x02\x02\x02\u{8ca}\
	\u{85a}\x03\x02\x02\x02\u{8ca}\u{85b}\x03\x02\x02\x02\u{8ca}\u{85c}\x03\
	\x02\x02\x02\u{8ca}\u{85d}\x03\x02\x02\x02\u{8ca}\u{85e}\x03\x02\x02\x02\
	\u{8ca}\u{85f}\x03\x02\x02\x02\u{8ca}\u{860}\x03\x02\x02\x02\u{8ca}\u{861}\
	\x03\x02\x02\x02\u{8ca}\u{862}\x03\x02\x02\x02\u{8ca}\u{863}\x03\x02\x02\
	\x02\u{8ca}\u{864}\x03\x02\x02\x02\u{8ca}\u{865}\x03\x02\x02\x02\u{8ca}\
	\u{866}\x03\x02\x02\x02\u{8ca}\u{867}\x03\x02\x02\x02\u{8ca}\u{868}\x03\
	\x02\x02\x02\u{8ca}\u{869}\x03\x02\x02\x02\u{8ca}\u{86a}\x03\x02\x02\x02\
	\u{8ca}\u{86b}\x03\x02\x02\x02\u{8ca}\u{86c}\x03\x02\x02\x02\u{8ca}\u{86d}\
	\x03\x02\x02\x02\u{8ca}\u{86e}\x03\x02\x02\x02\u{8ca}\u{86f}\x03\x02\x02\
	\x02\u{8ca}\u{870}\x03\x02\x02\x02\u{8ca}\u{871}\x03\x02\x02\x02\u{8ca}\
	\u{872}\x03\x02\x02\x02\u{8ca}\u{873}\x03\x02\x02\x02\u{8ca}\u{874}\x03\
	\x02\x02\x02\u{8ca}\u{875}\x03\x02\x02\x02\u{8ca}\u{876}\x03\x02\x02\x02\
	\u{8ca}\u{877}\x03\x02\x02\x02\u{8ca}\u{878}\x03\x02\x02\x02\u{8ca}\u{879}\
	\x03\x02\x02\x02\u{8ca}\u{87a}\x03\x02\x02\x02\u{8ca}\u{87b}\x03\x02\x02\
	\x02\u{8ca}\u{87c}\x03\x02\x02\x02\u{8ca}\u{87d}\x03\x02\x02\x02\u{8ca}\
	\u{87e}\x03\x02\x02\x02\u{8ca}\u{87f}\x03\x02\x02\x02\u{8ca}\u{880}\x03\
	\x02\x02\x02\u{8ca}\u{881}\x03\x02\x02\x02\u{8ca}\u{882}\x03\x02\x02\x02\
	\u{8ca}\u{883}\x03\x02\x02\x02\u{8ca}\u{884}\x03\x02\x02\x02\u{8ca}\u{885}\
	\x03\x02\x02\x02\u{8ca}\u{886}\x03\x02\x02\x02\u{8ca}\u{887}\x03\x02\x02\
	\x02\u{8ca}\u{888}\x03\x02\x02\x02\u{8ca}\u{889}\x03\x02\x02\x02\u{8ca}\
	\u{88a}\x03\x02\x02\x02\u{8ca}\u{88b}\x03\x02\x02\x02\u{8ca}\u{88c}\x03\
	\x02\x02\x02\u{8ca}\u{88d}\x03\x02\x02\x02\u{8ca}\u{88e}\x03\x02\x02\x02\
	\u{8ca}\u{88f}\x03\x02\x02\x02\u{8ca}\u{890}\x03\x02\x02\x02\u{8ca}\u{891}\
	\x03\x02\x02\x02\u{8ca}\u{892}\x03\x02\x02\x02\u{8ca}\u{893}\x03\x02\x02\
	\x02\u{8ca}\u{894}\x03\x02\x02\x02\u{8ca}\u{895}\x03\x02\x02\x02\u{8ca}\
	\u{896}\x03\x02\x02\x02\u{8ca}\u{897}\x03\x02\x02\x02\u{8ca}\u{898}\x03\
	\x02\x02\x02\u{8ca}\u{899}\x03\x02\x02\x02\u{8ca}\u{89a}\x03\x02\x02\x02\
	\u{8ca}\u{89b}\x03\x02\x02\x02\u{8ca}\u{89c}\x03\x02\x02\x02\u{8ca}\u{89d}\
	\x03\x02\x02\x02\u{8ca}\u{89e}\x03\x02\x02\x02\u{8ca}\u{89f}\x03\x02\x02\
	\x02\u{8ca}\u{8a0}\x03\x02\x02\x02\u{8ca}\u{8a1}\x03\x02\x02\x02\u{8ca}\
	\u{8a2}\x03\x02\x02\x02\u{8ca}\u{8a3}\x03\x02\x02\x02\u{8ca}\u{8a4}\x03\
	\x02\x02\x02\u{8ca}\u{8a5}\x03\x02\x02\x02\u{8ca}\u{8a6}\x03\x02\x02\x02\
	\u{8ca}\u{8a7}\x03\x02\x02\x02\u{8ca}\u{8a8}\x03\x02\x02\x02\u{8ca}\u{8a9}\
	\x03\x02\x02\x02\u{8ca}\u{8aa}\x03\x02\x02\x02\u{8ca}\u{8ab}\x03\x02\x02\
	\x02\u{8ca}\u{8ac}\x03\x02\x02\x02\u{8ca}\u{8ad}\x03\x02\x02\x02\u{8ca}\
	\u{8ae}\x03\x02\x02\x02\u{8ca}\u{8af}\x03\x02\x02\x02\u{8ca}\u{8b0}\x03\
	\x02\x02\x02\u{8ca}\u{8b1}\x03\x02\x02\x02\u{8ca}\u{8b2}\x03\x02\x02\x02\
	\u{8ca}\u{8b3}\x03\x02\x02\x02\u{8ca}\u{8b4}\x03\x02\x02\x02\u{8ca}\u{8b5}\
	\x03\x02\x02\x02\u{8ca}\u{8b6}\x03\x02\x02\x02\u{8ca}\u{8b7}\x03\x02\x02\
	\x02\u{8ca}\u{8b8}\x03\x02\x02\x02\u{8ca}\u{8b9}\x03\x02\x02\x02\u{8ca}\
	\u{8ba}\x03\x02\x02\x02\u{8ca}\u{8bb}\x03\x02\x02\x02\u{8ca}\u{8bc}\x03\
	\x02\x02\x02\u{8ca}\u{8bd}\x03\x02\x02\x02\u{8ca}\u{8be}\x03\x02\x02\x02\
	\u{8ca}\u{8bf}\x03\x02\x02\x02\u{8ca}\u{8c0}\x03\x02\x02\x02\u{8ca}\u{8c1}\
	\x03\x02\x02\x02\u{8ca}\u{8c2}\x03\x02\x02\x02\u{8ca}\u{8c3}\x03\x02\x02\
	\x02\u{8ca}\u{8c4}\x03\x02\x02\x02\u{8ca}\u{8c5}\x03\x02\x02\x02\u{8ca}\
	\u{8c6}\x03\x02\x02\x02\u{8ca}\u{8c7}\x03\x02\x02\x02\u{8ca}\u{8c8}\x03\
	\x02\x02\x02\u{8ca}\u{8c9}\x03\x02\x02\x02\u{8cb}\u{23f}\x03\x02\x02\x02\
	\u{8cc}\u{924}\x05\u{232}\u{11a}\x02\u{8cd}\u{924}\x05\u{234}\u{11b}\x02\
	\u{8ce}\u{924}\x05\u{236}\u{11c}\x02\u{8cf}\u{924}\x05\u{238}\u{11d}\x02\
	\u{8d0}\u{924}\x05\u{23a}\u{11e}\x02\u{8d1}\u{924}\x05\u{23c}\u{11f}\x02\
	\u{8d2}\u{924}\x05\u{220}\u{111}\x02\u{8d3}\u{924}\x05\u{224}\u{113}\x02\
	\u{8d4}\u{924}\x05\u{168}\u{b5}\x02\u{8d5}\u{924}\x05\u{16a}\u{b6}\x02\u{8d6}\
	\u{924}\x05\u{16c}\u{b7}\x02\u{8d7}\u{924}\x05\u{16e}\u{b8}\x02\u{8d8}\u{924}\
	\x05\u{170}\u{b9}\x02\u{8d9}\u{924}\x05\u{172}\u{ba}\x02\u{8da}\u{924}\x05\
	\u{174}\u{bb}\x02\u{8db}\u{924}\x05\u{176}\u{bc}\x02\u{8dc}\u{924}\x05\u{178}\
	\u{bd}\x02\u{8dd}\u{924}\x05\u{17a}\u{be}\x02\u{8de}\u{924}\x05\u{17c}\u{bf}\
	\x02\u{8df}\u{924}\x05\u{17e}\u{c0}\x02\u{8e0}\u{924}\x05\u{180}\u{c1}\x02\
	\u{8e1}\u{924}\x05\u{182}\u{c2}\x02\u{8e2}\u{924}\x05\u{184}\u{c3}\x02\u{8e3}\
	\u{924}\x05\u{186}\u{c4}\x02\u{8e4}\u{924}\x05\u{188}\u{c5}\x02\u{8e5}\u{924}\
	\x05\u{18a}\u{c6}\x02\u{8e6}\u{924}\x05\u{18c}\u{c7}\x02\u{8e7}\u{924}\x05\
	\u{18e}\u{c8}\x02\u{8e8}\u{924}\x05\u{190}\u{c9}\x02\u{8e9}\u{924}\x05\u{192}\
	\u{ca}\x02\u{8ea}\u{924}\x05\u{194}\u{cb}\x02\u{8eb}\u{924}\x05\u{196}\u{cc}\
	\x02\u{8ec}\u{924}\x05\u{198}\u{cd}\x02\u{8ed}\u{924}\x05\u{19a}\u{ce}\x02\
	\u{8ee}\u{924}\x05\u{19c}\u{cf}\x02\u{8ef}\u{924}\x05\u{19e}\u{d0}\x02\u{8f0}\
	\u{924}\x05\u{1a0}\u{d1}\x02\u{8f1}\u{924}\x05\u{1a2}\u{d2}\x02\u{8f2}\u{924}\
	\x05\u{1a4}\u{d3}\x02\u{8f3}\u{924}\x05\u{1a6}\u{d4}\x02\u{8f4}\u{924}\x05\
	\u{1a8}\u{d5}\x02\u{8f5}\u{924}\x05\u{1aa}\u{d6}\x02\u{8f6}\u{924}\x05\u{1ac}\
	\u{d7}\x02\u{8f7}\u{924}\x05\u{1ae}\u{d8}\x02\u{8f8}\u{924}\x05\u{1b0}\u{d9}\
	\x02\u{8f9}\u{924}\x05\u{1b2}\u{da}\x02\u{8fa}\u{924}\x05\u{1b4}\u{db}\x02\
	\u{8fb}\u{924}\x05\u{1b6}\u{dc}\x02\u{8fc}\u{924}\x05\u{1b8}\u{dd}\x02\u{8fd}\
	\u{924}\x05\u{1ba}\u{de}\x02\u{8fe}\u{924}\x05\u{1bc}\u{df}\x02\u{8ff}\u{924}\
	\x05\u{1be}\u{e0}\x02\u{900}\u{924}\x05\u{1c0}\u{e1}\x02\u{901}\u{924}\x05\
	\u{1c2}\u{e2}\x02\u{902}\u{924}\x05\u{1c4}\u{e3}\x02\u{903}\u{924}\x05\u{1c6}\
	\u{e4}\x02\u{904}\u{924}\x05\u{1c8}\u{e5}\x02\u{905}\u{924}\x05\u{1ca}\u{e6}\
	\x02\u{906}\u{924}\x05\u{1cc}\u{e7}\x02\u{907}\u{924}\x05\u{1ce}\u{e8}\x02\
	\u{908}\u{924}\x05\u{1d0}\u{e9}\x02\u{909}\u{924}\x05\u{1d2}\u{ea}\x02\u{90a}\
	\u{924}\x05\u{1d4}\u{eb}\x02\u{90b}\u{924}\x05\u{1d6}\u{ec}\x02\u{90c}\u{924}\
	\x05\u{1d8}\u{ed}\x02\u{90d}\u{924}\x05\u{1da}\u{ee}\x02\u{90e}\u{924}\x05\
	\u{1dc}\u{ef}\x02\u{90f}\u{924}\x05\u{1de}\u{f0}\x02\u{910}\u{924}\x05\u{1e0}\
	\u{f1}\x02\u{911}\u{924}\x05\u{1e2}\u{f2}\x02\u{912}\u{924}\x05\u{1e4}\u{f3}\
	\x02\u{913}\u{924}\x05\u{1e6}\u{f4}\x02\u{914}\u{924}\x05\u{1e8}\u{f5}\x02\
	\u{915}\u{924}\x05\u{1ea}\u{f6}\x02\u{916}\u{924}\x05\u{1ec}\u{f7}\x02\u{917}\
	\u{924}\x05\u{1ee}\u{f8}\x02\u{918}\u{924}\x05\u{1f0}\u{f9}\x02\u{919}\u{924}\
	\x05\u{1f2}\u{fa}\x02\u{91a}\u{924}\x05\u{1f4}\u{fb}\x02\u{91b}\u{924}\x05\
	\u{1f6}\u{fc}\x02\u{91c}\u{924}\x05\u{1f8}\u{fd}\x02\u{91d}\u{924}\x05\u{1fa}\
	\u{fe}\x02\u{91e}\u{924}\x05\u{1fc}\u{ff}\x02\u{91f}\u{924}\x05\u{1fe}\u{100}\
	\x02\u{920}\u{924}\x05\u{200}\u{101}\x02\u{921}\u{924}\x05\u{202}\u{102}\
	\x02\u{922}\u{924}\x05\u{204}\u{103}\x02\u{923}\u{8cc}\x03\x02\x02\x02\u{923}\
	\u{8cd}\x03\x02\x02\x02\u{923}\u{8ce}\x03\x02\x02\x02\u{923}\u{8cf}\x03\
	\x02\x02\x02\u{923}\u{8d0}\x03\x02\x02\x02\u{923}\u{8d1}\x03\x02\x02\x02\
	\u{923}\u{8d2}\x03\x02\x02\x02\u{923}\u{8d3}\x03\x02\x02\x02\u{923}\u{8d4}\
	\x03\x02\x02\x02\u{923}\u{8d5}\x03\x02\x02\x02\u{923}\u{8d6}\x03\x02\x02\
	\x02\u{923}\u{8d7}\x03\x02\x02\x02\u{923}\u{8d8}\x03\x02\x02\x02\u{923}\
	\u{8d9}\x03\x02\x02\x02\u{923}\u{8da}\x03\x02\x02\x02\u{923}\u{8db}\x03\
	\x02\x02\x02\u{923}\u{8dc}\x03\x02\x02\x02\u{923}\u{8dd}\x03\x02\x02\x02\
	\u{923}\u{8de}\x03\x02\x02\x02\u{923}\u{8df}\x03\x02\x02\x02\u{923}\u{8e0}\
	\x03\x02\x02\x02\u{923}\u{8e1}\x03\x02\x02\x02\u{923}\u{8e2}\x03\x02\x02\
	\x02\u{923}\u{8e3}\x03\x02\x02\x02\u{923}\u{8e4}\x03\x02\x02\x02\u{923}\
	\u{8e5}\x03\x02\x02\x02\u{923}\u{8e6}\x03\x02\x02\x02\u{923}\u{8e7}\x03\
	\x02\x02\x02\u{923}\u{8e8}\x03\x02\x02\x02\u{923}\u{8e9}\x03\x02\x02\x02\
	\u{923}\u{8ea}\x03\x02\x02\x02\u{923}\u{8eb}\x03\x02\x02\x02\u{923}\u{8ec}\
	\x03\x02\x02\x02\u{923}\u{8ed}\x03\x02\x02\x02\u{923}\u{8ee}\x03\x02\x02\
	\x02\u{923}\u{8ef}\x03\x02\x02\x02\u{923}\u{8f0}\x03\x02\x02\x02\u{923}\
	\u{8f1}\x03\x02\x02\x02\u{923}\u{8f2}\x03\x02\x02\x02\u{923}\u{8f3}\x03\
	\x02\x02\x02\u{923}\u{8f4}\x03\x02\x02\x02\u{923}\u{8f5}\x03\x02\x02\x02\
	\u{923}\u{8f6}\x03\x02\x02\x02\u{923}\u{8f7}\x03\x02\x02\x02\u{923}\u{8f8}\
	\x03\x02\x02\x02\u{923}\u{8f9}\x03\x02\x02\x02\u{923}\u{8fa}\x03\x02\x02\
	\x02\u{923}\u{8fb}\x03\x02\x02\x02\u{923}\u{8fc}\x03\x02\x02\x02\u{923}\
	\u{8fd}\x03\x02\x02\x02\u{923}\u{8fe}\x03\x02\x02\x02\u{923}\u{8ff}\x03\
	\x02\x02\x02\u{923}\u{900}\x03\x02\x02\x02\u{923}\u{901}\x03\x02\x02\x02\
	\u{923}\u{902}\x03\x02\x02\x02\u{923}\u{903}\x03\x02\x02\x02\u{923}\u{904}\
	\x03\x02\x02\x02\u{923}\u{905}\x03\x02\x02\x02\u{923}\u{906}\x03\x02\x02\
	\x02\u{923}\u{907}\x03\x02\x02\x02\u{923}\u{908}\x03\x02\x02\x02\u{923}\
	\u{909}\x03\x02\x02\x02\u{923}\u{90a}\x03\x02\x02\x02\u{923}\u{90b}\x03\
	\x02\x02\x02\u{923}\u{90c}\x03\x02\x02\x02\u{923}\u{90d}\x03\x02\x02\x02\
	\u{923}\u{90e}\x03\x02\x02\x02\u{923}\u{90f}\x03\x02\x02\x02\u{923}\u{910}\
	\x03\x02\x02\x02\u{923}\u{911}\x03\x02\x02\x02\u{923}\u{912}\x03\x02\x02\
	\x02\u{923}\u{913}\x03\x02\x02\x02\u{923}\u{914}\x03\x02\x02\x02\u{923}\
	\u{915}\x03\x02\x02\x02\u{923}\u{916}\x03\x02\x02\x02\u{923}\u{917}\x03\
	\x02\x02\x02\u{923}\u{918}\x03\x02\x02\x02\u{923}\u{919}\x03\x02\x02\x02\
	\u{923}\u{91a}\x03\x02\x02\x02\u{923}\u{91b}\x03\x02\x02\x02\u{923}\u{91c}\
	\x03\x02\x02\x02\u{923}\u{91d}\x03\x02\x02\x02\u{923}\u{91e}\x03\x02\x02\
	\x02\u{923}\u{91f}\x03\x02\x02\x02\u{923}\u{920}\x03\x02\x02\x02\u{923}\
	\u{921}\x03\x02\x02\x02\u{923}\u{922}\x03\x02\x02\x02\u{924}\u{241}\x03\
	\x02\x02\x02\u{925}\u{937}\x05\u{240}\u{121}\x02\u{926}\u{937}\x05\u{23e}\
	\u{120}\x02\u{927}\u{937}\x05\x70\x39\x02\u{928}\u{937}\x05\x72\x3a\x02\
	\u{929}\u{937}\x05\x56\x2c\x02\u{92a}\u{937}\x05\x58\x2d\x02\u{92b}\u{937}\
	\x05\x5a\x2e\x02\u{92c}\u{937}\x05\x5c\x2f\x02\u{92d}\u{937}\x05\x5e\x30\
	\x02\u{92e}\u{937}\x05\x60\x31\x02\u{92f}\u{937}\x05\x62\x32\x02\u{930}\
	\u{937}\x05\x64\x33\x02\u{931}\u{937}\x05\x66\x34\x02\u{932}\u{937}\x05\
	\x68\x35\x02\u{933}\u{937}\x05\x6a\x36\x02\u{934}\u{937}\x05\x6c\x37\x02\
	\u{935}\u{937}\x05\x6e\x38\x02\u{936}\u{925}\x03\x02\x02\x02\u{936}\u{926}\
	\x03\x02\x02\x02\u{936}\u{927}\x03\x02\x02\x02\u{936}\u{928}\x03\x02\x02\
	\x02\u{936}\u{929}\x03\x02\x02\x02\u{936}\u{92a}\x03\x02\x02\x02\u{936}\
	\u{92b}\x03\x02\x02\x02\u{936}\u{92c}\x03\x02\x02\x02\u{936}\u{92d}\x03\
	\x02\x02\x02\u{936}\u{92e}\x03\x02\x02\x02\u{936}\u{92f}\x03\x02\x02\x02\
	\u{936}\u{930}\x03\x02\x02\x02\u{936}\u{931}\x03\x02\x02\x02\u{936}\u{932}\
	\x03\x02\x02\x02\u{936}\u{933}\x03\x02\x02\x02\u{936}\u{934}\x03\x02\x02\
	\x02\u{936}\u{935}\x03\x02\x02\x02\u{937}\u{243}\x03\x02\x02\x02\u{938}\
	\u{939}\x05\x36\x1c\x02\u{939}\u{93a}\x07\x1c\x02\x02\u{93a}\u{93b}\x05\
	\u{264}\u{133}\x02\u{93b}\u{245}\x03\x02\x02\x02\u{93c}\u{93d}\x05\x36\x1c\
	\x02\u{93d}\u{93e}\x07\x1c\x02\x02\u{93e}\u{93f}\x05\u{24c}\u{127}\x02\u{93f}\
	\u{247}\x03\x02\x02\x02\u{940}\u{941}\x05\x18\x0d\x02\u{941}\u{249}\x03\
	\x02\x02\x02\u{942}\u{943}\x05\x3a\x1e\x02\u{943}\u{24b}\x03\x02\x02\x02\
	\u{944}\u{945}\x05\u{248}\u{125}\x02\u{945}\u{946}\x07\x14\x02\x02\u{946}\
	\u{947}\x05\u{24a}\u{126}\x02\u{947}\u{24d}\x03\x02\x02\x02\u{948}\u{94c}\
	\x07\x23\x02\x02\u{949}\u{94b}\x05\x46\x24\x02\u{94a}\u{949}\x03\x02\x02\
	\x02\u{94b}\u{94e}\x03\x02\x02\x02\u{94c}\u{94a}\x03\x02\x02\x02\u{94c}\
	\u{94d}\x03\x02\x02\x02\u{94d}\u{94f}\x03\x02\x02\x02\u{94e}\u{94c}\x03\
	\x02\x02\x02\u{94f}\u{952}\x05\u{24c}\u{127}\x02\u{950}\u{951}\x07\x15\x02\
	\x02\u{951}\u{953}\x05\x40\x21\x02\u{952}\u{950}\x03\x02\x02\x02\u{952}\
	\u{953}\x03\x02\x02\x02\u{953}\u{24f}\x03\x02\x02\x02\u{954}\u{955}\x05\
	\x1a\x0e\x02\u{955}\u{251}\x03\x02\x02\x02\u{956}\u{95a}\x07\x20\x02\x02\
	\u{957}\u{959}\x05\x42\x22\x02\u{958}\u{957}\x03\x02\x02\x02\u{959}\u{95c}\
	\x03\x02\x02\x02\u{95a}\u{958}\x03\x02\x02\x02\u{95a}\u{95b}\x03\x02\x02\
	\x02\u{95b}\u{95d}\x03\x02\x02\x02\u{95c}\u{95a}\x03\x02\x02\x02\u{95d}\
	\u{95e}\x05\u{250}\u{129}\x02\u{95e}\u{253}\x03\x02\x02\x02\u{95f}\u{960}\
	\x05\x1a\x0e\x02\u{960}\u{255}\x03\x02\x02\x02\u{961}\u{962}\x07\x22\x02\
	\x02\u{962}\u{963}\x05\u{254}\u{12b}\x02\u{963}\u{257}\x03\x02\x02\x02\u{964}\
	\u{965}\x05\x04\x03\x02\u{965}\u{259}\x03\x02\x02\x02\u{966}\u{967}\x07\
	\x21\x02\x02\u{967}\u{968}\x05\u{258}\u{12d}\x02\u{968}\u{25b}\x03\x02\x02\
	\x02\u{969}\u{96f}\x05\x18\x0d\x02\u{96a}\u{96b}\x07\x1a\x02\x02\u{96b}\
	\u{96c}\x05\x18\x0d\x02\u{96c}\u{96d}\x07\x1b\x02\x02\u{96d}\u{96f}\x03\
	\x02\x02\x02\u{96e}\u{969}\x03\x02\x02\x02\u{96e}\u{96a}\x03\x02\x02\x02\
	\u{96f}\u{25d}\x03\x02\x02\x02\u{970}\u{971}\x05\x3a\x1e\x02\u{971}\u{25f}\
	\x03\x02\x02\x02\u{972}\u{975}\x05\x38\x1d\x02\u{973}\u{975}\x05\x32\x1a\
	\x02\u{974}\u{972}\x03\x02\x02\x02\u{974}\u{973}\x03\x02\x02\x02\u{975}\
	\u{261}\x03\x02\x02\x02\u{976}\u{978}\x05\u{260}\u{131}\x02\u{977}\u{976}\
	\x03\x02\x02\x02\u{978}\u{979}\x03\x02\x02\x02\u{979}\u{977}\x03\x02\x02\
	\x02\u{979}\u{97a}\x03\x02\x02\x02\u{97a}\u{263}\x03\x02\x02\x02\u{97b}\
	\u{97c}\x05\u{25c}\u{12f}\x02\u{97c}\u{97e}\x07\x10\x02\x02\u{97d}\u{97f}\
	\x05\u{262}\u{132}\x02\u{97e}\u{97d}\x03\x02\x02\x02\u{97e}\u{97f}\x03\x02\
	\x02\x02\u{97f}\u{980}\x03\x02\x02\x02\u{980}\u{981}\x07\x11\x02\x02\u{981}\
	\u{982}\x05\u{25e}\u{130}\x02\u{982}\u{265}\x03\x02\x02\x02\u{983}\u{985}\
	\x05\x44\x23\x02\u{984}\u{983}\x03\x02\x02\x02\u{985}\u{988}\x03\x02\x02\
	\x02\u{986}\u{984}\x03\x02\x02\x02\u{986}\u{987}\x03\x02\x02\x02\u{987}\
	\u{989}\x03\x02\x02\x02\u{988}\u{986}\x03\x02\x02\x02\u{989}\u{98a}\x05\
	\u{264}\u{133}\x02\u{98a}\u{267}\x03\x02\x02\x02\u{98b}\u{98c}\x07\u{132}\
	\x02\x02\u{98c}\u{269}\x03\x02\x02\x02\u{98d}\u{98e}\x05\x1a\x0e\x02\u{98e}\
	\u{26b}\x03\x02\x02\x02\u{98f}\u{992}\x05\x40\x21\x02\u{990}\u{992}\x05\
	\x1a\x0e\x02\u{991}\u{98f}\x03\x02\x02\x02\u{991}\u{990}\x03\x02\x02\x02\
	\u{992}\u{26d}\x03\x02\x02\x02\u{993}\u{99c}\x07\x12\x02\x02\u{994}\u{999}\
	\x05\u{26c}\u{137}\x02\u{995}\u{996}\x07\x18\x02\x02\u{996}\u{998}\x05\u{26c}\
	\u{137}\x02\u{997}\u{995}\x03\x02\x02\x02\u{998}\u{99b}\x03\x02\x02\x02\
	\u{999}\u{997}\x03\x02\x02\x02\u{999}\u{99a}\x03\x02\x02\x02\u{99a}\u{99d}\
	\x03\x02\x02\x02\u{99b}\u{999}\x03\x02\x02\x02\u{99c}\u{994}\x03\x02\x02\
	\x02\u{99c}\u{99d}\x03\x02\x02\x02\u{99d}\u{99e}\x03\x02\x02\x02\u{99e}\
	\u{99f}\x07\x13\x02\x02\u{99f}\u{26f}\x03\x02\x02\x02\u{9a0}\u{9a1}\x05\
	\u{248}\u{125}\x02\u{9a1}\u{9a4}\x07\x15\x02\x02\u{9a2}\u{9a5}\x05\u{26c}\
	\u{137}\x02\u{9a3}\u{9a5}\x05\u{26e}\u{138}\x02\u{9a4}\u{9a2}\x03\x02\x02\
	\x02\u{9a4}\u{9a3}\x03\x02\x02\x02\u{9a5}\u{271}\x03\x02\x02\x02\u{9a6}\
	\u{9a7}\x07\x2a\x02\x02\u{9a7}\u{9a8}\x05\u{268}\u{135}\x02\u{9a8}\u{9ac}\
	\x05\u{26a}\u{136}\x02\u{9a9}\u{9ab}\x05\u{270}\u{139}\x02\u{9aa}\u{9a9}\
	\x03\x02\x02\x02\u{9ab}\u{9ae}\x03\x02\x02\x02\u{9ac}\u{9aa}\x03\x02\x02\
	\x02\u{9ac}\u{9ad}\x03\x02\x02\x02\u{9ad}\u{9af}\x03\x02\x02\x02\u{9ae}\
	\u{9ac}\x03\x02\x02\x02\u{9af}\u{9b0}\x07\x2b\x02\x02\u{9b0}\u{273}\x03\
	\x02\x02\x02\u{9b1}\u{9b2}\x05\x04\x03\x02\u{9b2}\u{275}\x03\x02\x02\x02\
	\u{9b3}\u{9b4}\x05\x38\x1d\x02\u{9b4}\u{277}\x03\x02\x02\x02\u{9b5}\u{9b6}\
	\x05\x04\x03\x02\u{9b6}\u{279}\x03\x02\x02\x02\u{9b7}\u{9b8}\x05\x02\x02\
	\x02\u{9b8}\u{27b}\x03\x02\x02\x02\u{9b9}\u{9ba}\x07\x2c\x02\x02\u{9ba}\
	\u{9bb}\x05\u{27a}\u{13e}\x02\u{9bb}\u{9bc}\x07\x18\x02\x02\u{9bc}\u{9bf}\
	\x05\u{274}\u{13b}\x02\u{9bd}\u{9be}\x07\x14\x02\x02\u{9be}\u{9c0}\x05\u{276}\
	\u{13c}\x02\u{9bf}\u{9bd}\x03\x02\x02\x02\u{9bf}\u{9c0}\x03\x02\x02\x02\
	\u{9c0}\u{9c3}\x03\x02\x02\x02\u{9c1}\u{9c2}\x07\x18\x02\x02\u{9c2}\u{9c4}\
	\x05\u{278}\u{13d}\x02\u{9c3}\u{9c1}\x03\x02\x02\x02\u{9c3}\u{9c4}\x03\x02\
	\x02\x02\u{9c4}\u{27d}\x03\x02\x02\x02\u{9c5}\u{9c6}\x07\x2d\x02\x02\u{9c6}\
	\u{9c7}\x05\x02\x02\x02\u{9c7}\u{27f}\x03\x02\x02\x02\u{9c8}\u{9c9}\x07\
	\x2e\x02\x02\u{9c9}\u{9ca}\x05\x02\x02\x02\u{9ca}\u{281}\x03\x02\x02\x02\
	\u{9cb}\u{9cc}\x05\x4a\x26\x02\u{9cc}\u{283}\x03\x02\x02\x02\u{9cd}\u{9dd}\
	\x05\u{292}\u{14a}\x02\u{9ce}\u{9dd}\x05\u{294}\u{14b}\x02\u{9cf}\u{9dd}\
	\x05\u{29a}\u{14e}\x02\u{9d0}\u{9dd}\x05\u{29c}\u{14f}\x02\u{9d1}\u{9dd}\
	\x05\u{242}\u{122}\x02\u{9d2}\u{9dd}\x05\u{282}\u{142}\x02\u{9d3}\u{9dd}\
	\x05\u{2a6}\u{154}\x02\u{9d4}\u{9dd}\x05\u{2a8}\u{155}\x02\u{9d5}\u{9dd}\
	\x05\u{272}\u{13a}\x02\u{9d6}\u{9dd}\x05\u{27c}\u{13f}\x02\u{9d7}\u{9dd}\
	\x05\u{27e}\u{140}\x02\u{9d8}\u{9dd}\x05\u{280}\u{141}\x02\u{9d9}\u{9dd}\
	\x05\u{28e}\u{148}\x02\u{9da}\u{9dd}\x05\u{2aa}\u{156}\x02\u{9db}\u{9dd}\
	\x05\u{2b0}\u{159}\x02\u{9dc}\u{9cd}\x03\x02\x02\x02\u{9dc}\u{9ce}\x03\x02\
	\x02\x02\u{9dc}\u{9cf}\x03\x02\x02\x02\u{9dc}\u{9d0}\x03\x02\x02\x02\u{9dc}\
	\u{9d1}\x03\x02\x02\x02\u{9dc}\u{9d2}\x03\x02\x02\x02\u{9dc}\u{9d3}\x03\
	\x02\x02\x02\u{9dc}\u{9d4}\x03\x02\x02\x02\u{9dc}\u{9d5}\x03\x02\x02\x02\
	\u{9dc}\u{9d6}\x03\x02\x02\x02\u{9dc}\u{9d7}\x03\x02\x02\x02\u{9dc}\u{9d8}\
	\x03\x02\x02\x02\u{9dc}\u{9d9}\x03\x02\x02\x02\u{9dc}\u{9da}\x03\x02\x02\
	\x02\u{9dc}\u{9db}\x03\x02\x02\x02\u{9dd}\u{285}\x03\x02\x02\x02\u{9de}\
	\u{9e0}\x05\u{284}\u{143}\x02\u{9df}\u{9de}\x03\x02\x02\x02\u{9e0}\u{9e1}\
	\x03\x02\x02\x02\u{9e1}\u{9df}\x03\x02\x02\x02\u{9e1}\u{9e2}\x03\x02\x02\
	\x02\u{9e2}\u{287}\x03\x02\x02\x02\u{9e3}\u{9e4}\x05\x16\x0c\x02\u{9e4}\
	\u{289}\x03\x02\x02\x02\u{9e5}\u{9e6}\x05\x4a\x26\x02\u{9e6}\u{28b}\x03\
	\x02\x02\x02\u{9e7}\u{9e9}\x05\u{28a}\u{146}\x02\u{9e8}\u{9e7}\x03\x02\x02\
	\x02\u{9e9}\u{9ea}\x03\x02\x02\x02\u{9ea}\u{9e8}\x03\x02\x02\x02\u{9ea}\
	\u{9eb}\x03\x02\x02\x02\u{9eb}\u{28d}\x03\x02\x02\x02\u{9ec}\u{9ed}\x07\
	\x2f\x02\x02\u{9ed}\u{9ef}\x05\u{288}\u{145}\x02\u{9ee}\u{9f0}\x05\u{28c}\
	\u{147}\x02\u{9ef}\u{9ee}\x03\x02\x02\x02\u{9ef}\u{9f0}\x03\x02\x02\x02\
	\u{9f0}\u{9f1}\x03\x02\x02\x02\u{9f1}\u{9f2}\x07\x30\x02\x02\u{9f2}\u{28f}\
	\x03\x02\x02\x02\u{9f3}\u{9f4}\x07\x1e\x02\x02\u{9f4}\u{9f6}\x05\u{266}\
	\u{134}\x02\u{9f5}\u{9f7}\x05\u{286}\u{144}\x02\u{9f6}\u{9f5}\x03\x02\x02\
	\x02\u{9f6}\u{9f7}\x03\x02\x02\x02\u{9f7}\u{9f8}\x03\x02\x02\x02\u{9f8}\
	\u{9f9}\x07\x1f\x02\x02\u{9f9}\u{291}\x03\x02\x02\x02\u{9fa}\u{9fb}\x07\
	\x24\x02\x02\u{9fb}\u{9fc}\x05\x16\x0c\x02\u{9fc}\u{293}\x03\x02\x02\x02\
	\u{9fd}\u{9fe}\x07\x25\x02\x02\u{9fe}\u{9ff}\x05\x16\x0c\x02\u{9ff}\u{295}\
	\x03\x02\x02\x02\u{a00}\u{a01}\x07\x18\x02\x02\u{a01}\u{a02}\x05\x04\x03\
	\x02\u{a02}\u{297}\x03\x02\x02\x02\u{a03}\u{a05}\x05\u{272}\u{13a}\x02\u{a04}\
	\u{a03}\x03\x02\x02\x02\u{a05}\u{a08}\x03\x02\x02\x02\u{a06}\u{a04}\x03\
	\x02\x02\x02\u{a06}\u{a07}\x03\x02\x02\x02\u{a07}\u{a09}\x03\x02\x02\x02\
	\u{a08}\u{a06}\x03\x02\x02\x02\u{a09}\u{a0a}\x07\x35\x02\x02\u{a0a}\u{299}\
	\x03\x02\x02\x02\u{a0b}\u{a0c}\x07\x26\x02\x02\u{a0c}\u{a0f}\x05\x02\x02\
	\x02\u{a0d}\u{a10}\x05\u{298}\u{14d}\x02\u{a0e}\u{a10}\x05\u{296}\u{14c}\
	\x02\u{a0f}\u{a0d}\x03\x02\x02\x02\u{a0f}\u{a0e}\x03\x02\x02\x02\u{a10}\
	\u{29b}\x03\x02\x02\x02\u{a11}\u{a12}\x07\x27\x02\x02\u{a12}\u{a13}\x05\
	\x16\x0c\x02\u{a13}\u{29d}\x03\x02\x02\x02\u{a14}\u{a15}\x05\x4a\x26\x02\
	\u{a15}\u{29f}\x03\x02\x02\x02\u{a16}\u{a17}\x05\x4a\x26\x02\u{a17}\u{2a1}\
	\x03\x02\x02\x02\u{a18}\u{a19}\x05\x4a\x26\x02\u{a19}\u{2a3}\x03\x02\x02\
	\x02\u{a1a}\u{a1b}\x05\x1a\x0e\x02\u{a1b}\u{2a5}\x03\x02\x02\x02\u{a1c}\
	\u{a1d}\x07\x28\x02\x02\u{a1d}\u{a1e}\x05\u{2a4}\u{153}\x02\u{a1e}\u{a1f}\
	\x07\x12\x02\x02\u{a1f}\u{a20}\x05\u{29e}\u{150}\x02\u{a20}\u{a21}\x07\x16\
	\x02\x02\u{a21}\u{a22}\x07\x16\x02\x02\u{a22}\u{a23}\x05\u{2a0}\u{151}\x02\
	\u{a23}\u{a24}\x07\x13\x02\x02\u{a24}\u{a25}\x05\u{2a2}\u{152}\x02\u{a25}\
	\u{2a7}\x03\x02\x02\x02\u{a26}\u{a27}\x07\x29\x02\x02\u{a27}\u{a28}\x07\
	\x12\x02\x02\u{a28}\u{a29}\x05\u{29e}\u{150}\x02\u{a29}\u{a2a}\x07\x16\x02\
	\x02\u{a2a}\u{a2b}\x07\x16\x02\x02\u{a2b}\u{a2c}\x05\u{2a0}\u{151}\x02\u{a2c}\
	\u{a2d}\x07\x13\x02\x02\u{a2d}\u{a2e}\x05\u{2a2}\u{152}\x02\u{a2e}\u{2a9}\
	\x03\x02\x02\x02\u{a2f}\u{a30}\x07\x31\x02\x02\u{a30}\u{a34}\x05\x16\x0c\
	\x02\u{a31}\u{a33}\x05\u{2ac}\u{157}\x02\u{a32}\u{a31}\x03\x02\x02\x02\u{a33}\
	\u{a36}\x03\x02\x02\x02\u{a34}\u{a32}\x03\x02\x02\x02\u{a34}\u{a35}\x03\
	\x02\x02\x02\u{a35}\u{a37}\x03\x02\x02\x02\u{a36}\u{a34}\x03\x02\x02\x02\
	\u{a37}\u{a38}\x07\x32\x02\x02\u{a38}\u{2ab}\x03\x02\x02\x02\u{a39}\u{a3b}\
	\x05\x16\x0c\x02\u{a3a}\u{a3c}\x07\u{132}\x02\x02\u{a3b}\u{a3a}\x03\x02\
	\x02\x02\u{a3b}\u{a3c}\x03\x02\x02\x02\u{a3c}\u{2ad}\x03\x02\x02\x02\u{a3d}\
	\u{a3e}\x05\x16\x0c\x02\u{a3e}\u{a3f}\x07\x1c\x02\x02\u{a3f}\u{a40}\x05\
	\x4a\x26\x02\u{a40}\u{2af}\x03\x02\x02\x02\u{a41}\u{a45}\x07\x33\x02\x02\
	\u{a42}\u{a44}\x05\u{2ae}\u{158}\x02\u{a43}\u{a42}\x03\x02\x02\x02\u{a44}\
	\u{a47}\x03\x02\x02\x02\u{a45}\u{a43}\x03\x02\x02\x02\u{a45}\u{a46}\x03\
	\x02\x02\x02\u{a46}\u{a48}\x03\x02\x02\x02\u{a47}\u{a45}\x03\x02\x02\x02\
	\u{a48}\u{a49}\x07\x34\x02\x02\u{a49}\u{2b1}\x03\x02\x02\x02\u{a4a}\u{a50}\
	\x05\u{252}\u{12a}\x02\u{a4b}\u{a50}\x05\u{256}\u{12c}\x02\u{a4c}\u{a50}\
	\x05\u{25a}\u{12e}\x02\u{a4d}\u{a50}\x05\u{24e}\u{128}\x02\u{a4e}\u{a50}\
	\x05\u{290}\u{149}\x02\u{a4f}\u{a4a}\x03\x02\x02\x02\u{a4f}\u{a4b}\x03\x02\
	\x02\x02\u{a4f}\u{a4c}\x03\x02\x02\x02\u{a4f}\u{a4d}\x03\x02\x02\x02\u{a4f}\
	\u{a4e}\x03\x02\x02\x02\u{a50}\u{2b3}\x03\x02\x02\x02\u{a51}\u{a53}\x05\
	\u{2b2}\u{15a}\x02\u{a52}\u{a51}\x03\x02\x02\x02\u{a53}\u{a54}\x03\x02\x02\
	\x02\u{a54}\u{a52}\x03\x02\x02\x02\u{a54}\u{a55}\x03\x02\x02\x02\u{a55}\
	\u{2b5}\x03\x02\x02\x02\x2c\u{2cf}\u{2d3}\u{2d8}\u{2f6}\u{2fa}\u{302}\u{306}\
	\u{30a}\u{30f}\u{31a}\u{330}\u{340}\u{8ca}\u{923}\u{936}\u{94c}\u{952}\u{95a}\
	\u{96e}\u{974}\u{979}\u{97e}\u{986}\u{991}\u{999}\u{99c}\u{9a4}\u{9ac}\u{9bf}\
	\u{9c3}\u{9dc}\u{9e1}\u{9ea}\u{9ef}\u{9f6}\u{a06}\u{a0f}\u{a34}\u{a3b}\u{a45}\
	\u{a4f}\u{a54}";

